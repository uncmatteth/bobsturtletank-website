<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê¢ Bob The Turtle: Hero Of Turtle Dungeon Depths</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rot-js@2.2.1/dist/rot.min.js"></script>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        // Complete working game without any external dependencies
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.hero = null;
                this.enemies = null;
                this.cursors = null;
                this.floorNumber = 1;
                this.score = 0;
                this.health = 100;
                this.maxHealth = 100;
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                this.gold = 0;
            }
            
            preload() {
                // Create pixel art textures programmatically
                this.createTextures();
            }
            
            createTextures() {
                // Hero texture
                const heroCanvas = this.textures.createCanvas('hero', 32, 32);
                const heroCtx = heroCanvas.getContext();
                
                // Shell (dark green)
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(8, 8, 16, 16);
                
                // Shell pattern (lighter green)
                heroCtx.fillStyle = '#4a7c23';
                heroCtx.fillRect(10, 10, 12, 12);
                heroCtx.fillRect(12, 12, 8, 8);
                
                // Head (medium green)
                heroCtx.fillStyle = '#3d6b1a';
                heroCtx.fillRect(4, 12, 8, 8);
                
                // Eyes (white with black dots)
                heroCtx.fillStyle = '#ffffff';
                heroCtx.fillRect(5, 13, 2, 2);
                heroCtx.fillRect(5, 17, 2, 2);
                heroCtx.fillStyle = '#000000';
                heroCtx.fillRect(5, 13, 1, 1);
                heroCtx.fillRect(5, 17, 1, 1);
                
                // Legs (dark green)
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(6, 6, 4, 4);   // front left
                heroCtx.fillRect(6, 22, 4, 4);  // front right
                heroCtx.fillRect(22, 6, 4, 4);  // back left
                heroCtx.fillRect(22, 22, 4, 4); // back right
                
                heroCanvas.refresh();
                
                // Enemy texture
                const enemyCanvas = this.textures.createCanvas('enemy', 32, 32);
                const enemyCtx = enemyCanvas.getContext();
                
                // Body (red)
                enemyCtx.fillStyle = '#8b0000';
                enemyCtx.fillRect(8, 8, 16, 16);
                
                // Details (darker red)
                enemyCtx.fillStyle = '#660000';
                enemyCtx.fillRect(10, 10, 12, 12);
                
                // Eyes (yellow)
                enemyCtx.fillStyle = '#ffff00';
                enemyCtx.fillRect(10, 12, 2, 2);
                enemyCtx.fillRect(20, 12, 2, 2);
                
                // Pupils (black)
                enemyCtx.fillStyle = '#000000';
                enemyCtx.fillRect(10, 12, 1, 1);
                enemyCtx.fillRect(20, 12, 1, 1);
                
                enemyCanvas.refresh();
                
                // Floor texture
                const floorCanvas = this.textures.createCanvas('floor', 32, 32);
                const floorCtx = floorCanvas.getContext();
                floorCtx.fillStyle = '#8B4513';
                floorCtx.fillRect(0, 0, 32, 32);
                floorCtx.fillStyle = '#A0522D';
                floorCtx.fillRect(2, 2, 28, 28);
                floorCanvas.refresh();
                
                // Wall texture
                const wallCanvas = this.textures.createCanvas('wall', 32, 32);
                const wallCtx = wallCanvas.getContext();
                wallCtx.fillStyle = '#555555';
                wallCtx.fillRect(0, 0, 32, 32);
                wallCtx.fillStyle = '#777777';
                wallCtx.fillRect(2, 2, 28, 28);
                wallCtx.fillStyle = '#999999';
                wallCtx.fillRect(4, 4, 24, 24);
                wallCanvas.refresh();
            }
            
            create() {
                // Create world bounds
                this.physics.world.setBounds(0, 0, 1280, 720);
                
                // Generate simple dungeon
                this.generateDungeon();
                
                // Create hero
                this.hero = this.physics.add.sprite(640, 360, 'hero');
                this.hero.setCollideWorldBounds(true);
                this.hero.setScale(1.5);
                
                // Create enemies group
                this.enemies = this.physics.add.group();
                this.spawnEnemies();
                
                // Set up physics
                this.physics.add.collider(this.hero, this.enemies, this.hitEnemy, null, this);
                
                // Set up controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasd = this.input.keyboard.addKeys('W,S,A,D');
                
                // Camera follows hero
                this.cameras.main.startFollow(this.hero);
                this.cameras.main.setZoom(1);
                
                // Create UI
                this.createUI();
                
                // Welcome message
                this.showMessage('üê¢ Welcome to the Turtle Dungeon Depths!');
            }
            
            generateDungeon() {
                // Simple dungeon generation
                const tileSize = 32;
                const mapWidth = Math.floor(1280 / tileSize);
                const mapHeight = Math.floor(720 / tileSize);
                
                // Create floor tiles
                for (let x = 0; x < mapWidth; x++) {
                    for (let y = 0; y < mapHeight; y++) {
                        if (x === 0 || x === mapWidth - 1 || y === 0 || y === mapHeight - 1) {
                            // Walls around border
                            const wall = this.physics.add.staticSprite(x * tileSize + 16, y * tileSize + 16, 'wall');
                            wall.setScale(1);
                        } else {
                            // Floor tiles
                            const floor = this.add.sprite(x * tileSize + 16, y * tileSize + 16, 'floor');
                            floor.setScale(1);
                        }
                    }
                }
                
                // Add some interior walls
                for (let i = 0; i < 10; i++) {
                    const x = Phaser.Math.Between(2, mapWidth - 3);
                    const y = Phaser.Math.Between(2, mapHeight - 3);
                    const wall = this.physics.add.staticSprite(x * tileSize + 16, y * tileSize + 16, 'wall');
                    wall.setScale(1);
                }
            }
            
            spawnEnemies() {
                const enemyCount = Math.min(5 + this.floorNumber, 15);
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    do {
                        x = Phaser.Math.Between(100, 1180);
                        y = Phaser.Math.Between(100, 620);
                    } while (Phaser.Math.Distance.Between(x, y, this.hero.x, this.hero.y) < 200);
                    
                    const enemy = this.physics.add.sprite(x, y, 'enemy');
                    enemy.setScale(1.2);
                    enemy.setTint(Phaser.Math.Between(0x800000, 0xff0000));
                    enemy.health = 20 + (this.floorNumber * 5);
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 50 + (this.floorNumber * 10);
                    
                    this.enemies.add(enemy);
                }
            }
            
            createUI() {
                // UI background
                const uiHeight = 60;
                const uiBg = this.add.rectangle(640, 30, 1280, uiHeight, 0x000000, 0.7);
                uiBg.setScrollFactor(0);
                
                // Health bar
                this.healthBarBg = this.add.rectangle(150, 30, 200, 20, 0x660000);
                this.healthBarBg.setScrollFactor(0);
                this.healthBar = this.add.rectangle(150, 30, 200, 20, 0x00ff00);
                this.healthBar.setScrollFactor(0);
                
                // Stats text
                this.statsText = this.add.text(20, 15, '', {
                    fontSize: '16px',
                    color: '#ffffff',
                    fontFamily: 'Arial'
                });
                this.statsText.setScrollFactor(0);
                
                // Floor and score
                this.floorText = this.add.text(1100, 15, '', {
                    fontSize: '16px',
                    color: '#00ff88',
                    fontFamily: 'Arial'
                });
                this.floorText.setScrollFactor(0);
                
                // Message text
                this.messageText = this.add.text(640, 100, '', {
                    fontSize: '24px',
                    color: '#ffff00',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 4
                });
                this.messageText.setOrigin(0.5);
                this.messageText.setScrollFactor(0);
            }
            
            update() {
                if (!this.hero || !this.hero.active) return;
                
                // Hero movement
                const speed = 200;
                this.hero.setVelocity(0);
                
                if (this.cursors.left.isDown || this.wasd.A.isDown) {
                    this.hero.setVelocityX(-speed);
                } else if (this.cursors.right.isDown || this.wasd.D.isDown) {
                    this.hero.setVelocityX(speed);
                }
                
                if (this.cursors.up.isDown || this.wasd.W.isDown) {
                    this.hero.setVelocityY(-speed);
                } else if (this.cursors.down.isDown || this.wasd.S.isDown) {
                    this.hero.setVelocityY(speed);
                }
                
                // Enemy AI
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        const distance = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.hero.x, this.hero.y);
                        
                        if (distance < 300) {
                            // Chase player
                            this.physics.moveToObject(enemy, this.hero, enemy.speed);
                        } else {
                            enemy.setVelocity(0);
                        }
                    }
                });
                
                // Update UI
                this.updateUI();
                
                // Check for level completion
                if (this.enemies.children.entries.length === 0 || this.enemies.children.entries.every(e => !e.active)) {
                    this.nextFloor();
                }
            }
            
            hitEnemy(hero, enemy) {
                if (!enemy.active) return;
                
                // Damage enemy
                enemy.health -= 25;
                enemy.setTint(0xff0000);
                
                this.time.delayedCall(200, () => {
                    if (enemy.active) {
                        enemy.clearTint();
                        enemy.setTint(Phaser.Math.Between(0x800000, 0xff0000));
                    }
                });
                
                if (enemy.health <= 0) {
                    // Enemy defeated
                    this.addExperience(10 + this.floorNumber);
                    this.gold += 5 + this.floorNumber;
                    this.score += 100 * this.floorNumber;
                    
                    enemy.setActive(false);
                    enemy.setVisible(false);
                    enemy.body.enable = false;
                    
                    this.showMessage(`+${10 + this.floorNumber} XP, +${5 + this.floorNumber} Gold!`);
                } else {
                    // Damage hero
                    this.takeDamage(5 + this.floorNumber);
                }
            }
            
            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                
                // Flash screen red
                this.cameras.main.flash(200, 255, 0, 0, 0.3);
                
                if (this.health <= 0) {
                    this.gameOver();
                }
            }
            
            addExperience(amount) {
                this.experience += amount;
                
                while (this.experience >= this.experienceToNext) {
                    this.experience -= this.experienceToNext;
                    this.level++;
                    this.experienceToNext = Math.floor(this.experienceToNext * 1.2);
                    this.maxHealth += 10;
                    this.health = this.maxHealth;
                    
                    this.showMessage(`üéâ LEVEL UP! Level ${this.level}`);
                    
                    // Flash screen gold
                    this.cameras.main.flash(500, 255, 215, 0, 0.5);
                }
            }
            
            nextFloor() {
                this.floorNumber++;
                
                // Heal player partially
                this.health = Math.min(this.maxHealth, this.health + Math.floor(this.maxHealth * 0.3));
                
                // Clear enemies
                this.enemies.clear(true, true);
                
                // Spawn new enemies
                this.spawnEnemies();
                
                this.showMessage(`üè∞ Floor ${this.floorNumber} - Enemies grow stronger!`);
                
                // Flash screen blue
                this.cameras.main.flash(300, 0, 100, 255, 0.3);
            }
            
            updateUI() {
                // Health bar
                const healthPercent = this.health / this.maxHealth;
                this.healthBar.scaleX = healthPercent;
                this.healthBar.setTint(healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000);
                
                // Stats
                this.statsText.setText(`‚ù§Ô∏è ${this.health}/${this.maxHealth}  ‚≠ê Lv.${this.level}  üí∞ ${this.gold}G`);
                
                // Floor and score
                this.floorText.setText(`üè∞ Floor ${this.floorNumber}  üéØ ${this.score}`);
            }
            
            showMessage(text) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);
                
                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    duration: 3000,
                    ease: 'Power2'
                });
            }
            
            gameOver() {
                this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.8);
                
                const gameOverText = this.add.text(640, 300, 'üíÄ GAME OVER', {
                    fontSize: '64px',
                    color: '#ff0000',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 6
                });
                gameOverText.setOrigin(0.5);
                
                const finalScore = this.add.text(640, 380, `Final Score: ${this.score}\nFloor Reached: ${this.floorNumber}\nLevel: ${this.level}`, {
                    fontSize: '24px',
                    color: '#ffffff',
                    fontFamily: 'Arial',
                    align: 'center'
                });
                finalScore.setOrigin(0.5);
                
                const restartText = this.add.text(640, 480, 'Press R to Restart', {
                    fontSize: '20px',
                    color: '#00ff88',
                    fontFamily: 'Arial'
                });
                restartText.setOrigin(0.5);
                
                // Restart input
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
            }
        }
        
        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            parent: 'game-container',
            backgroundColor: '#2c3e50',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: GameScene
        };
        
        // Start the game
        const game = new Phaser.Game(config);
        
        console.log('üê¢ Bob The Turtle: Standalone Edition Loaded!');
    </script>
</body>
</html>




