<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê¢ Bob The Turtle: Hero Of Turtle Dungeon Depths</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
    <script src="tileset-integration.js"></script>
    <script>
        // Skip Service Worker operations when running from file:// protocol
        console.log('üê¢ Bob The Turtle game loading...');
    </script>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
        // Complete working game without any external dependencies
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.hero = null;
                this.enemies = null;
                this.cursors = null;
                this.floorNumber = 1;
                this.score = 0;
                this.health = 100;
                this.maxHealth = 100;
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                this.gold = 0;
                
                // Visual effects properties
                this.particles = null;
                this.lights = null;
                this.screenShakeIntensity = 0;
                this.hitPauseTimer = 0;
                this.colorFlashTimer = 0;
                this.dynamicLights = [];
                this.floatingTexts = [];
                
                // Tileset system
                this.tilesetManager = null;
                this.dungeonTiles = [];
            }
            
            preload() {
                // Create pixel art textures programmatically
                this.createTextures();
            }
            
            createTextures() {
                // Hero texture
                const heroCanvas = this.textures.createCanvas('hero', 32, 32);
                const heroCtx = heroCanvas.getContext();
                
                // Shell (dark green)
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(8, 8, 16, 16);
                
                // Shell pattern (lighter green)
                heroCtx.fillStyle = '#4a7c23';
                heroCtx.fillRect(10, 10, 12, 12);
                heroCtx.fillRect(12, 12, 8, 8);
                
                // Head (medium green)
                heroCtx.fillStyle = '#3d6b1a';
                heroCtx.fillRect(4, 12, 8, 8);
                
                // Eyes (white with black dots)
                heroCtx.fillStyle = '#ffffff';
                heroCtx.fillRect(5, 13, 2, 2);
                heroCtx.fillRect(5, 17, 2, 2);
                heroCtx.fillStyle = '#000000';
                heroCtx.fillRect(5, 13, 1, 1);
                heroCtx.fillRect(5, 17, 1, 1);
                
                // Legs (dark green)
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(6, 6, 4, 4);   // front left
                heroCtx.fillRect(6, 22, 4, 4);  // front right
                heroCtx.fillRect(22, 6, 4, 4);  // back left
                heroCtx.fillRect(22, 22, 4, 4); // back right
                
                heroCanvas.refresh();
                
                // Enemy texture
                const enemyCanvas = this.textures.createCanvas('enemy', 32, 32);
                const enemyCtx = enemyCanvas.getContext();
                
                // Body (red)
                enemyCtx.fillStyle = '#8b0000';
                enemyCtx.fillRect(8, 8, 16, 16);
                
                // Details (darker red)
                enemyCtx.fillStyle = '#660000';
                enemyCtx.fillRect(10, 10, 12, 12);
                
                // Eyes (yellow)
                enemyCtx.fillStyle = '#ffff00';
                enemyCtx.fillRect(10, 12, 2, 2);
                enemyCtx.fillRect(20, 12, 2, 2);
                
                // Pupils (black)
                enemyCtx.fillStyle = '#000000';
                enemyCtx.fillRect(10, 12, 1, 1);
                enemyCtx.fillRect(20, 12, 1, 1);
                
                enemyCanvas.refresh();
                
                // Floor texture
                const floorCanvas = this.textures.createCanvas('floor', 32, 32);
                const floorCtx = floorCanvas.getContext();
                floorCtx.fillStyle = '#8B4513';
                floorCtx.fillRect(0, 0, 32, 32);
                floorCtx.fillStyle = '#A0522D';
                floorCtx.fillRect(2, 2, 28, 28);
                floorCanvas.refresh();
                
                // Wall texture
                const wallCanvas = this.textures.createCanvas('wall', 32, 32);
                const wallCtx = wallCanvas.getContext();
                wallCtx.fillStyle = '#555555';
                wallCtx.fillRect(0, 0, 32, 32);
                wallCtx.fillStyle = '#777777';
                wallCtx.fillRect(2, 2, 28, 28);
                wallCtx.fillStyle = '#999999';
                wallCtx.fillRect(4, 4, 24, 24);
                wallCanvas.refresh();
            }
            
            create() {
                // Enable lighting system for atmosphere
                this.lights.enable();
                this.lights.setAmbientColor(0x303030);
                
                // Create world bounds
                this.physics.world.setBounds(0, 0, 1280, 720);
                
                // Generate simple dungeon
                this.generateDungeon();
                
                // Initialize visual effects FIRST (before enemies need particles)
                this.setupVisualEffects();
                
                // Create hero with lighting
                this.hero = this.physics.add.sprite(640, 360, 'hero');
                this.hero.setCollideWorldBounds(true);
                this.hero.setScale(1.5);
                this.hero.setPipeline('Light2D');
                
                // Create enemies group
                this.enemies = this.physics.add.group();
                this.spawnEnemies();
                
                // Set up physics
                this.physics.add.collider(this.hero, this.enemies, this.hitEnemy, null, this);
                
                // Set up controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasd = this.input.keyboard.addKeys('W,S,A,D');
                
                // Camera follows hero
                this.cameras.main.startFollow(this.hero);
                this.cameras.main.setZoom(1);
                
                // Create UI
                this.createUI();
                
                // Initialize tileset system
                this.initializeTilesets();
                
                // Welcome message
                this.showMessage('üê¢ Welcome to the Turtle Dungeon Depths!');
            }
            
            generateDungeon() {
                // Simple dungeon generation
                const tileSize = 32;
                const mapWidth = Math.floor(1280 / tileSize);
                const mapHeight = Math.floor(720 / tileSize);
                
                // Create floor tiles
                for (let x = 0; x < mapWidth; x++) {
                    for (let y = 0; y < mapHeight; y++) {
                        if (x === 0 || x === mapWidth - 1 || y === 0 || y === mapHeight - 1) {
                            // Walls around border
                            const wall = this.physics.add.staticSprite(x * tileSize + 16, y * tileSize + 16, 'wall');
                            wall.setScale(1);
                        } else {
                            // Floor tiles
                            const floor = this.add.sprite(x * tileSize + 16, y * tileSize + 16, 'floor');
                            floor.setScale(1);
                        }
                    }
                }
                
                // Add some interior walls
                for (let i = 0; i < 10; i++) {
                    const x = Phaser.Math.Between(2, mapWidth - 3);
                    const y = Phaser.Math.Between(2, mapHeight - 3);
                    const wall = this.physics.add.staticSprite(x * tileSize + 16, y * tileSize + 16, 'wall');
                    wall.setScale(1);
                }
            }
            
            spawnEnemies() {
                const enemyCount = Math.min(5 + this.floorNumber, 15);
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    do {
                        x = Phaser.Math.Between(100, 1180);
                        y = Phaser.Math.Between(100, 620);
                    } while (Phaser.Math.Distance.Between(x, y, this.hero.x, this.hero.y) < 200);
                    
                    const enemy = this.physics.add.sprite(x, y, 'enemy');
                    enemy.setScale(1.2);
                    enemy.setTint(Phaser.Math.Between(0x800000, 0xff0000));
                    enemy.health = 20 + (this.floorNumber * 5);
                    enemy.maxHealth = enemy.health;
                    enemy.speed = 50 + (this.floorNumber * 10);
                    
                    // Enable lighting on enemies
                    enemy.setPipeline('Light2D');
                    
                    // JUICE: Spawn effect with particles and scale animation
                    this.createSpellEffect(x, y, 'fire');
                    enemy.setScale(0.1);
                    this.tweens.add({
                        targets: enemy,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 400,
                        ease: 'Back.easeOut'
                    });
                    
                    // Add menacing red light to enemies
                    const enemyLight = this.lights.addLight(x, y, 60, 0xff0000, 0.5);
                    this.dynamicLights.push(enemyLight);
                    enemy.enemyLight = enemyLight; // Store reference for updates
                    
                    this.enemies.add(enemy);
                }
            }
            
            createUI() {
                // UI background
                const uiHeight = 60;
                const uiBg = this.add.rectangle(640, 30, 1280, uiHeight, 0x000000, 0.7);
                uiBg.setScrollFactor(0);
                
                // Health bar
                this.healthBarBg = this.add.rectangle(150, 30, 200, 20, 0x660000);
                this.healthBarBg.setScrollFactor(0);
                this.healthBar = this.add.rectangle(150, 30, 200, 20, 0x00ff00);
                this.healthBar.setScrollFactor(0);
                
                // Stats text
                this.statsText = this.add.text(20, 15, '', {
                    fontSize: '16px',
                    color: '#ffffff',
                    fontFamily: 'Arial'
                });
                this.statsText.setScrollFactor(0);
                
                // Floor and score
                this.floorText = this.add.text(1100, 15, '', {
                    fontSize: '16px',
                    color: '#00ff88',
                    fontFamily: 'Arial'
                });
                this.floorText.setScrollFactor(0);
                
                // Message text
                this.messageText = this.add.text(640, 100, '', {
                    fontSize: '24px',
                    color: '#ffff00',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 4
                });
                this.messageText.setOrigin(0.5);
                this.messageText.setScrollFactor(0);
            }
            
            update() {
                if (!this.hero || !this.hero.active) return;
                
                // Hero movement
                const speed = 200;
                this.hero.setVelocity(0);
                
                if (this.cursors.left.isDown || this.wasd.A.isDown) {
                    this.hero.setVelocityX(-speed);
                } else if (this.cursors.right.isDown || this.wasd.D.isDown) {
                    this.hero.setVelocityX(speed);
                }
                
                if (this.cursors.up.isDown || this.wasd.W.isDown) {
                    this.hero.setVelocityY(-speed);
                } else if (this.cursors.down.isDown || this.wasd.S.isDown) {
                    this.hero.setVelocityY(speed);
                }
                
                // Enemy AI with lighting updates
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        const distance = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.hero.x, this.hero.y);
                        
                        if (distance < 300) {
                            // Chase player
                            this.physics.moveToObject(enemy, this.hero, enemy.speed);
                        } else {
                            enemy.setVelocity(0);
                        }
                        
                        // Update enemy lighting to follow them
                        if (enemy.enemyLight) {
                            enemy.enemyLight.x = enemy.x;
                            enemy.enemyLight.y = enemy.y;
                            
                            // Pulse enemy lights menacingly
                            const time = this.time.now * 0.008;
                            enemy.enemyLight.intensity = 0.3 + Math.sin(time + enemy.x * 0.01) * 0.2;
                        }
                    }
                });
                
                // Update dynamic lighting to follow hero
                if (this.dynamicLights.length > 0) {
                    const heroLight = this.dynamicLights[0];
                    heroLight.x = this.hero.x;
                    heroLight.y = this.hero.y;
                    
                    // Pulse hero light for magical effect
                    const time = this.time.now * 0.005;
                    heroLight.radius = 100 + Math.sin(time) * 20;
                    heroLight.intensity = 0.8 + Math.sin(time * 1.5) * 0.2;
                }
                
                // Update UI
                this.updateUI();
                
                // Check for level completion
                if (this.enemies.children.entries.length === 0 || this.enemies.children.entries.every(e => !e.active)) {
                    this.nextFloor();
                }
            }
            
            hitEnemy(hero, enemy) {
                if (!enemy.active) return;
                
                // JUICE: Screen shake and hit pause on impact
                this.screenShake(8, 150);
                this.hitPause(60);
                
                // JUICE: Impact effect at collision point
                this.createImpactEffect(enemy.x, enemy.y, 0xff4444);
                
                // Damage enemy
                enemy.health -= 25;
                enemy.setTint(0xff0000);
                
                // JUICE: Floating damage text
                this.createFloatingText(enemy.x, enemy.y - 20, '-25', '#ff4444', '20px');
                
                this.time.delayedCall(200, () => {
                    if (enemy.active) {
                        enemy.clearTint();
                        enemy.setTint(Phaser.Math.Between(0x800000, 0xff0000));
                    }
                });
                
                if (enemy.health <= 0) {
                    // JUICE: Epic death effect
                    this.createSpellEffect(enemy.x, enemy.y, 'fire');
                    this.screenShake(12, 200);
                    
                    // Enemy defeated
                    this.addExperience(10 + this.floorNumber);
                    this.gold += 5 + this.floorNumber;
                    this.score += 100 * this.floorNumber;
                    
                    // JUICE: Floating reward text
                    this.createFloatingText(enemy.x + 20, enemy.y - 30, `+${100 * this.floorNumber}`, '#00ff88', '18px');
                    this.createFloatingText(enemy.x - 20, enemy.y - 40, `+${10 + this.floorNumber} XP`, '#88ff00', '14px');
                    
                    enemy.setActive(false);
                    enemy.setVisible(false);
                    enemy.body.enable = false;
                    
                    this.showMessage(`+${10 + this.floorNumber} XP, +${5 + this.floorNumber} Gold!`);
                } else {
                    // JUICE: Hero damage with screen flash and shake
                    this.cameras.main.flash(100, 255, 0, 0, true);
                    this.screenShake(15, 300);
                    
                    // JUICE: Damage text on hero
                    this.createFloatingText(this.hero.x, this.hero.y - 30, `-${5 + this.floorNumber}`, '#ff0000', '24px');
                    
                    // Damage hero
                    this.takeDamage(5 + this.floorNumber);
                }
            }
            
            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                
                // Flash screen red
                this.cameras.main.flash(200, 255, 0, 0, 0.3);
                
                if (this.health <= 0) {
                    this.gameOver();
                }
            }
            
            addExperience(amount) {
                this.experience += amount;
                
                while (this.experience >= this.experienceToNext) {
                    this.experience -= this.experienceToNext;
                    this.level++;
                    this.experienceToNext = Math.floor(this.experienceToNext * 1.2);
                    this.maxHealth += 10;
                    this.health = this.maxHealth;
                    
                    // JUICE: Epic level up effects!
                    this.screenShake(15, 400);
                    this.cameras.main.flash(300, 255, 215, 0, true); // Golden flash
                    
                    // Massive spell effect around hero
                    this.createSpellEffect(this.hero.x, this.hero.y, 'magic');
                    this.createSpellEffect(this.hero.x + 20, this.hero.y - 20, 'magic');
                    this.createSpellEffect(this.hero.x - 20, this.hero.y + 20, 'magic');
                    
                    // Epic floating text
                    this.createFloatingText(this.hero.x, this.hero.y - 50, 'üéâ LEVEL UP! üéâ', '#ffff00', '28px');
                    this.createFloatingText(this.hero.x, this.hero.y - 80, `Level ${this.level}!`, '#ffd700', '20px');
                    this.createFloatingText(this.hero.x, this.hero.y + 30, '+10 Health!', '#00ff00', '18px');
                    
                    this.showMessage(`üéâ LEVEL UP! Level ${this.level}`);
                }
            }
            
            nextFloor() {
                this.floorNumber++;
                
                // Heal player partially
                this.health = Math.min(this.maxHealth, this.health + Math.floor(this.maxHealth * 0.3));
                
                // Clear enemies
                this.enemies.clear(true, true);
                
                // Spawn new enemies
                this.spawnEnemies();
                
                this.showMessage(`üè∞ Floor ${this.floorNumber} - Enemies grow stronger!`);
                
                // Flash screen blue
                this.cameras.main.flash(300, 0, 100, 255, 0.3);
            }
            
            updateUI() {
                // Health bar
                const healthPercent = this.health / this.maxHealth;
                this.healthBar.scaleX = healthPercent;
                this.healthBar.fillColor = healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000;
                
                // Stats
                this.statsText.setText(`‚ù§Ô∏è ${this.health}/${this.maxHealth}  ‚≠ê Lv.${this.level}  üí∞ ${this.gold}G`);
                
                // Floor and score
                this.floorText.setText(`üè∞ Floor ${this.floorNumber}  üéØ ${this.score}`);
            }
            
            showMessage(text) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);
                
                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    duration: 3000,
                    ease: 'Power2'
                });
            }
            
            setupVisualEffects() {
                // Create particle systems
                this.particles = this.add.particles();
                
                // Add dynamic lighting to hero (hero glow effect)
                const heroLight = this.lights.addLight(this.hero.x, this.hero.y, 100, 0x00ff88, 1);
                this.dynamicLights.push(heroLight);
                
                // Create floating text group
                this.floatingTexts = this.add.group();
            }
            
            screenShake(intensity = 10, duration = 200) {
                this.screenShakeIntensity = intensity;
                this.cameras.main.shake(duration, intensity);
            }
            
            hitPause(duration = 100) {
                this.hitPauseTimer = duration;
                this.physics.world.pause();
                this.time.delayedCall(duration, () => {
                    this.physics.world.resume();
                    this.hitPauseTimer = 0;
                });
            }
            
            createFloatingText(x, y, text, color = '#ffffff', fontSize = '16px') {
                const floatingText = this.add.text(x, y, text, {
                    fontSize: fontSize,
                    color: color,
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 3
                });
                floatingText.setOrigin(0.5);
                
                // Animate floating text
                this.tweens.add({
                    targets: floatingText,
                    y: y - 60,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Power2',
                    onComplete: () => floatingText.destroy()
                });
            }
            
            createImpactEffect(x, y, color = 0xffffff) {
                // Safety check for particles system
                if (!this.particles) {
                    console.warn('‚ö†Ô∏è Particles system not initialized, skipping impact effect');
                    return;
                }
                
                // Create particle burst on impact
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 50, max: 150 },
                    scale: { start: 0.3, end: 0 },
                    tint: color,
                    lifespan: 300,
                    quantity: 8
                });
                
                // Stop emitter after burst
                this.time.delayedCall(50, () => emitter.stop());
            }
            
            createSpellEffect(x, y, spellType = 'magic') {
                let color = 0x00ff88;
                if (spellType === 'fire') color = 0xff4444;
                if (spellType === 'ice') color = 0x4488ff;
                if (spellType === 'earth') color = 0x88ff44;
                
                // Safety check for particles system
                if (!this.particles) {
                    console.warn('‚ö†Ô∏è Particles system not initialized, skipping spell effect');
                    return;
                }
                
                // Create magical particle effect
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 30, max: 80 },
                    scale: { start: 0.5, end: 0 },
                    tint: color,
                    lifespan: 800,
                    quantity: 12,
                    blendMode: 'ADD'
                });
                
                this.time.delayedCall(100, () => emitter.stop());
            }
            
            async initializeTilesets() {
                console.log('üé® Initializing beautiful tileset system...');
                
                // Create tileset manager
                this.tilesetManager = new TilesetManager(this);
                
                // Load the stone-to-mossy tileset
                try {
                    await this.tilesetManager.loadTileset('stone_mossy', './tileset_stone_mossy.json');
                    
                    // Replace simple dungeon with beautiful tileset
                    this.regenerateDungeonWithTileset();
                    
                    console.log('‚úÖ Tileset system ready!');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Tileset loading failed, using fallback dungeon');
                }
            }
            
            regenerateDungeonWithTileset() {
                // Clear existing simple dungeon tiles
                this.dungeonTiles.forEach(tile => {
                    if (tile.sprite) tile.sprite.destroy();
                });
                this.dungeonTiles = [];
                
                // Generate beautiful tileset dungeon
                const dungeonWidth = Math.floor(1280 / 32) - 2; // Leave border
                const dungeonHeight = Math.floor(720 / 32) - 2;
                
                console.log(`üèóÔ∏è Generating ${dungeonWidth}x${dungeonHeight} tileset dungeon...`);
                
                const tiles = this.tilesetManager.generateDungeonWithTileset(
                    'stone_mossy', 
                    dungeonWidth, 
                    dungeonHeight
                );
                
                if (tiles) {
                    this.dungeonTiles = tiles;
                    console.log(`‚úÖ Generated ${tiles.length} beautiful tiles!`);
                    
                    // Add atmospheric lighting to dungeon
                    this.addDungeonLighting();
                }
            }
            
            addDungeonLighting() {
                // Add some torch-like lights around the dungeon
                const torchPositions = [
                    { x: 100, y: 100 },
                    { x: 1180, y: 100 },
                    { x: 100, y: 620 },
                    { x: 1180, y: 620 },
                    { x: 640, y: 100 },
                    { x: 640, y: 620 }
                ];
                
                torchPositions.forEach((pos, index) => {
                    const torchLight = this.lights.addLight(pos.x, pos.y, 120, 0xff8844, 0.6);
                    this.dynamicLights.push(torchLight);
                    
                    // Add flickering effect to torches
                    this.time.addEvent({
                        delay: 100 + index * 50, // Stagger the flicker
                        callback: () => {
                            if (torchLight) {
                                const flicker = 0.4 + Math.random() * 0.4;
                                torchLight.intensity = flicker;
                                torchLight.radius = 100 + Math.random() * 40;
                            }
                        },
                        loop: true
                    });
                });
            }

            gameOver() {
                // Epic screen shake on death
                this.screenShake(20, 500);
                
                this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.8);
                
                const gameOverText = this.add.text(640, 300, 'üíÄ GAME OVER', {
                    fontSize: '64px',
                    color: '#ff0000',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 6
                });
                gameOverText.setOrigin(0.5);
                
                // Animate game over text
                this.tweens.add({
                    targets: gameOverText,
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 500,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                const finalScore = this.add.text(640, 380, `Final Score: ${this.score}\nFloor Reached: ${this.floorNumber}\nLevel: ${this.level}`, {
                    fontSize: '24px',
                    color: '#ffffff',
                    fontFamily: 'Arial',
                    align: 'center'
                });
                finalScore.setOrigin(0.5);
                
                const restartText = this.add.text(640, 480, 'Press R to Restart', {
                    fontSize: '20px',
                    color: '#00ff88',
                    fontFamily: 'Arial'
                });
                restartText.setOrigin(0.5);
                
                // Restart input
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
            }
        }
        
        // Wait for all service workers to be unregistered
        window.addEventListener('load', function() {
            // Game configuration
            const config = {
                type: Phaser.AUTO,
                width: 1280,
                height: 720,
                parent: 'game-container',
                backgroundColor: '#2c3e50',
                physics: {
                    default: 'arcade',
                    arcade: {
                        gravity: { y: 0 },
                        debug: false
                    }
                },
                scene: GameScene
            };
            
            // Start the game
            const game = new Phaser.Game(config);
            
            console.log('üê¢ Bob The Turtle: Clean Edition Loaded!');
        });
    </script>
</body>
</html>
