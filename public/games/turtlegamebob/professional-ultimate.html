<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê¢ Bob The Turtle: Hero Of Turtle Dungeon Depths - PROFESSIONAL ULTIMATE EDITION</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            border: 2px solid #34495e;
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        
        .loading-title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
            color: #3498db;
        }
        
        .loading-subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            color: #2ecc71;
            text-align: center;
        }
        
        .loading-progress {
            width: 500px;
            height: 25px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            overflow: hidden;
            margin: 20px 0;
            border: 2px solid #34495e;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71, #f39c12);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-text {
            font-size: 18px;
            margin-top: 15px;
            text-align: center;
            color: #ecf0f1;
        }
        
        .professional-features {
            margin-top: 30px;
            text-align: center;
            font-size: 14px;
            color: #bdc3c7;
            max-width: 700px;
        }
        
        .professional-features h3 {
            color: #e74c3c;
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .professional-features ul {
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
            margin-top: 15px;
        }
        
        .professional-features li {
            padding: 4px;
            background: rgba(52, 73, 94, 0.3);
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .loading-title {
                font-size: 32px;
            }
            .loading-subtitle {
                font-size: 18px;
            }
            .loading-progress {
                width: 350px;
            }
            .professional-features {
                font-size: 12px;
                padding: 0 20px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-title">üê¢ Bob The Turtle</div>
        <div class="loading-subtitle">Hero Of Turtle Dungeon Depths - Professional Ultimate Edition</div>
        <div class="loading-progress">
            <div id="loading-bar" class="loading-bar"></div>
        </div>
        <div id="loading-text" class="loading-text">Loading professional PixelLab assets...</div>
        
        <div class="professional-features">
            <h3>üé® PROFESSIONAL PIXELLAB ASSETS</h3>
            <ul>
                <li>üê¢ 8-Directional Green Turtle Hero (48x48px)</li>
                <li>üëπ 4-Directional Professional Enemies (32x32px)</li>
                <li>üè∞ Wang Tileset System (16x16px tiles)</li>
                <li>üíé High-Quality Item & Effect Sprites</li>
                <li>‚ú® Magic Effect Animations (4-directional)</li>
                <li>üéµ 28 Professional Music Tracks (OGG/MP3)</li>
                <li>üîä Spatial Audio SFX System</li>
                <li>üéÆ Professional UI Elements</li>
                <li>üåü Procedural Dungeon Generation</li>
                <li>‚öîÔ∏è Real-time Combat System</li>
                <li>üì± Mobile Touch Controls</li>
                <li>üíæ Auto-Save System</li>
            </ul>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <script>
        // PROFESSIONAL PIXELLAB ULTIMATE IMPLEMENTATION
        // Using ALL professional assets with proper loading and Wang tilesets
        
        let gameInstance = null;
        let isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Professional asset paths (using public directory for Vite compatibility)
        const ASSET_PATHS = {
            sprites: {
                hero: 'public/assets/sprites/green_turtle/rotations/',
                enemies: 'public/assets/sprites/enemies/rotations/',
                items: 'public/assets/sprites/items/rotations/',
                effects: 'public/assets/sprites/effects/rotations/',
                ui: 'public/assets/sprites/ui/rotations/'
            },
            tilesets: 'public/assets/tilesets/',
            music: 'public/assets/music/',
            sfx: 'public/assets/sfx/'
        };
        
        // Hero directions for 8-directional movement
        const HERO_DIRECTIONS = {
            SOUTH: 'south',
            SOUTH_WEST: 'south-west', 
            WEST: 'west',
            NORTH_WEST: 'north-west',
            NORTH: 'north',
            NORTH_EAST: 'north-east',
            EAST: 'east',
            SOUTH_EAST: 'south-east'
        };
        
        // Enemy directions for 4-directional movement
        const ENEMY_DIRECTIONS = {
            SOUTH: 'south',
            WEST: 'west',
            NORTH: 'north',
            EAST: 'east'
        };
        
        // Loading manager
        class LoadingManager {
            constructor() {
                this.loadingScreen = document.getElementById('loading-screen');
                this.loadingBar = document.getElementById('loading-bar');
                this.loadingText = document.getElementById('loading-text');
                this.progress = 0;
            }
            
            updateProgress(progress, text) {
                this.progress = Math.min(100, Math.max(0, progress));
                this.loadingBar.style.width = this.progress + '%';
                if (text) this.loadingText.textContent = text;
            }
            
            hide() {
                this.loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                }, 500);
            }
        }
        
        // Professional Hero class with 8-directional sprites
        class ProfessionalHero extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y) {
                super(scene, x, y, 'hero_south');
                
                this.scene = scene;
                this.currentDirection = HERO_DIRECTIONS.SOUTH;
                this.isMoving = false;
                
                // Hero stats
                this.level = 1;
                this.health = 100;
                this.maxHealth = 100;
                this.mana = 50;
                this.maxMana = 50;
                this.attack = 15;
                this.defense = 10;
                this.speed = 120;
                this.experience = 0;
                this.experienceToNext = 100;
                
                // Combat state
                this.attackCooldown = 0;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                
                // Add to scene
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.setCollideWorldBounds(true);
                this.setScale(1.5);
                this.setSize(32, 32); // Collision box
                
                console.log('üê¢ Professional Hero created with 8-directional PixelLab sprites');
            }
            
            update(time, delta) {
                // Update cooldowns
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }
                
                if (this.invulnerabilityTime > 0) {
                    this.invulnerabilityTime -= delta;
                    if (this.invulnerabilityTime <= 0) {
                        this.invulnerable = false;
                        this.clearTint();
                    }
                }
                
                // Regenerate mana
                if (this.mana < this.maxMana) {
                    this.mana = Math.min(this.maxMana, this.mana + (delta * 0.02));
                }
                
                // Update sprite based on movement
                this.updateSprite();
            }
            
            updateSprite() {
                const velocity = this.body.velocity;
                const wasMoving = this.isMoving;
                this.isMoving = velocity.x !== 0 || velocity.y !== 0;
                
                if (this.isMoving) {
                    // Calculate 8-directional movement
                    const angle = Math.atan2(velocity.y, velocity.x);
                    const direction = this.angleToDirection(angle);
                    
                    if (direction !== this.currentDirection) {
                        this.currentDirection = direction;
                        this.setTexture(`hero_${direction}`);
                    }
                }
            }
            
            angleToDirection(angle) {
                // Convert angle to 8 directions
                const degrees = (angle * 180 / Math.PI + 360) % 360;
                
                if (degrees >= 337.5 || degrees < 22.5) return HERO_DIRECTIONS.EAST;
                if (degrees >= 22.5 && degrees < 67.5) return HERO_DIRECTIONS.SOUTH_EAST;
                if (degrees >= 67.5 && degrees < 112.5) return HERO_DIRECTIONS.SOUTH;
                if (degrees >= 112.5 && degrees < 157.5) return HERO_DIRECTIONS.SOUTH_WEST;
                if (degrees >= 157.5 && degrees < 202.5) return HERO_DIRECTIONS.WEST;
                if (degrees >= 202.5 && degrees < 247.5) return HERO_DIRECTIONS.NORTH_WEST;
                if (degrees >= 247.5 && degrees < 292.5) return HERO_DIRECTIONS.NORTH;
                if (degrees >= 292.5 && degrees < 337.5) return HERO_DIRECTIONS.NORTH_EAST;
                
                return HERO_DIRECTIONS.SOUTH; // Default
            }
            
            attack() {
                if (this.attackCooldown > 0) return;
                
                this.attackCooldown = 600;
                
                // Create attack effect
                this.scene.createAttackEffect(this.x, this.y, this.attack, this.currentDirection);
                
                // Screen shake
                this.scene.cameras.main.shake(100, 0.015);
                
                // Play attack sound
                this.scene.playSound('sword_hit');
            }
            
            takeDamage(amount) {
                if (this.invulnerable) return;
                
                const actualDamage = Math.max(1, amount - this.defense);
                this.health -= actualDamage;
                
                // Invulnerability frames
                this.invulnerable = true;
                this.invulnerabilityTime = 1000;
                this.setTint(0xff0000);
                
                // Screen flash
                this.scene.cameras.main.flash(200, 255, 0, 0, 0.3);
                
                // Floating damage text
                this.scene.showFloatingText(this.x, this.y - 20, `-${actualDamage}`, '#ff0000');
                
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            addExperience(amount) {
                this.experience += amount;
                
                while (this.experience >= this.experienceToNext) {
                    this.experience -= this.experienceToNext;
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.level++;
                this.experienceToNext = Math.floor(this.experienceToNext * 1.2);
                
                // Stat increases
                this.maxHealth += 15;
                this.health = this.maxHealth;
                this.maxMana += 8;
                this.mana = this.maxMana;
                this.attack += 3;
                this.defense += 2;
                
                // Epic level up effects
                this.scene.cameras.main.flash(300, 255, 215, 0, true);
                this.scene.cameras.main.shake(200, 0.02);
                this.scene.createMagicEffect(this.x, this.y, 'level_up');
                this.scene.showFloatingText(this.x, this.y - 50, `LEVEL ${this.level}!`, '#ffd700', '28px');
                
                // Play level up sound
                this.scene.playSound('level_up');
                
                console.log(`üéâ Level up! Now level ${this.level}`);
            }
            
            die() {
                this.scene.gameOver();
            }
        }
        
        // Professional Enemy class with 4-directional sprites
        class ProfessionalEnemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, enemyType, level = 1) {
                super(scene, x, y, 'enemy_south');
                
                this.scene = scene;
                this.enemyType = enemyType;
                this.level = level;
                this.currentDirection = ENEMY_DIRECTIONS.SOUTH;
                
                // Scale stats by level
                this.maxHealth = Math.floor(30 * (1 + level * 0.3));
                this.health = this.maxHealth;
                this.attack = Math.floor(8 * (1 + level * 0.2));
                this.speed = 60 + (level * 5);
                
                // AI state
                this.target = null;
                this.alertRadius = 120;
                this.attackRange = 40;
                this.attackCooldown = 0;
                this.stateTimer = 0;
                
                // Add to scene
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.setCollideWorldBounds(true);
                this.setScale(1.3);
                this.setSize(24, 24);
                
                // Health bar
                this.healthBar = scene.add.graphics();
                this.updateHealthBar();
            }
            
            update(time, delta) {
                // Update cooldowns
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }
                
                this.stateTimer += delta;
                
                // AI behavior
                this.updateAI(delta);
                
                // Update sprite direction
                this.updateSprite();
                
                // Update health bar position
                this.healthBar.x = this.x - 16;
                this.healthBar.y = this.y - 25;
            }
            
            updateSprite() {
                const velocity = this.body.velocity;
                
                if (velocity.x !== 0 || velocity.y !== 0) {
                    // Calculate 4-directional movement
                    const angle = Math.atan2(velocity.y, velocity.x);
                    const direction = this.angleToDirection4(angle);
                    
                    if (direction !== this.currentDirection) {
                        this.currentDirection = direction;
                        this.setTexture(`enemy_${direction}`);
                    }
                }
            }
            
            angleToDirection4(angle) {
                // Convert angle to 4 directions
                const degrees = (angle * 180 / Math.PI + 360) % 360;
                
                if (degrees >= 315 || degrees < 45) return ENEMY_DIRECTIONS.EAST;
                if (degrees >= 45 && degrees < 135) return ENEMY_DIRECTIONS.SOUTH;
                if (degrees >= 135 && degrees < 225) return ENEMY_DIRECTIONS.WEST;
                if (degrees >= 225 && degrees < 315) return ENEMY_DIRECTIONS.NORTH;
                
                return ENEMY_DIRECTIONS.SOUTH; // Default
            }
            
            updateAI(delta) {
                const hero = this.scene.hero;
                if (!hero) return;
                
                const distanceToHero = Phaser.Math.Distance.Between(this.x, this.y, hero.x, hero.y);
                
                if (distanceToHero < this.alertRadius) {
                    this.target = hero;
                    this.chaseTarget();
                } else {
                    this.patrol();
                }
            }
            
            chaseTarget() {
                if (!this.target) return;
                
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
                
                if (distance < this.attackRange && this.attackCooldown <= 0) {
                    this.attackTarget();
                } else if (distance < this.alertRadius * 1.5) {
                    this.scene.physics.moveToObject(this, this.target, this.speed);
                } else {
                    this.target = null;
                }
            }
            
            patrol() {
                if (this.stateTimer > 2000) {
                    // Change direction every 2 seconds
                    const randomAngle = Math.random() * Math.PI * 2;
                    const moveX = Math.cos(randomAngle) * this.speed * 0.3;
                    const moveY = Math.sin(randomAngle) * this.speed * 0.3;
                    this.setVelocity(moveX, moveY);
                    this.stateTimer = 0;
                }
            }
            
            attackTarget() {
                this.attackCooldown = 1200;
                
                if (this.target) {
                    const distance = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
                    if (distance < this.attackRange) {
                        this.target.takeDamage(this.attack);
                        this.scene.createImpactEffect(this.target.x, this.target.y, 0xff4444);
                    }
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                this.setTint(0xff0000);
                
                this.scene.time.delayedCall(200, () => {
                    this.clearTint();
                });
                
                this.updateHealthBar();
                this.scene.showFloatingText(this.x, this.y - 20, `-${amount}`, '#ff4444');
                
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            updateHealthBar() {
                this.healthBar.clear();
                
                // Background
                this.healthBar.fillStyle(0x000000);
                this.healthBar.fillRect(0, 0, 32, 4);
                
                // Health
                const healthPercent = this.health / this.maxHealth;
                const color = healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000;
                this.healthBar.fillStyle(color);
                this.healthBar.fillRect(1, 1, 30 * healthPercent, 2);
            }
            
            die() {
                // Drop loot and give XP
                this.scene.dropLoot(this.x, this.y, this.level);
                
                const xpReward = Math.floor(15 * (1 + this.level * 0.4));
                this.scene.hero.addExperience(xpReward);
                
                // Death effect
                this.scene.createMagicEffect(this.x, this.y, 'death');
                this.scene.cameras.main.shake(80, 0.01);
                
                // Remove from scene
                this.healthBar.destroy();
                this.destroy();
            }
        }
        
        // Wang Tileset Manager for Professional Tilesets
        class WangTilesetManager {
            constructor(scene) {
                this.scene = scene;
                this.currentTileset = null;
                this.tileSize = 16;
            }
            
            async loadTileset(tilesetName) {
                try {
                    const response = await fetch(`${ASSET_PATHS.tilesets}${tilesetName}.json`);
                    if (!response.ok) {
                        throw new Error(`Failed to load tileset: ${tilesetName}`);
                    }
                    
                    this.currentTileset = await response.json();
                    console.log(`üè∞ Loaded Wang tileset: ${tilesetName}`, this.currentTileset);
                    
                    // Create textures from base64 data
                    await this.createTileTextures();
                    
                    return true;
                } catch (error) {
                    console.error(`‚ùå Failed to load tileset ${tilesetName}:`, error);
                    return false;
                }
            }
            
            async createTileTextures() {
                if (!this.currentTileset || !this.currentTileset.tileset_data) {
                    return;
                }
                
                const tiles = this.currentTileset.tileset_data.tiles;
                const loadPromises = [];
                
                for (const tile of tiles) {
                    const textureKey = `tile_${tile.id}`;
                    
                    if (!this.scene.textures.exists(textureKey)) {
                        const promise = new Promise((resolve, reject) => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            const image = new Image();
                            
                            image.onload = () => {
                                try {
                                    canvas.width = image.width;
                                    canvas.height = image.height;
                                    ctx.drawImage(image, 0, 0);
                                    
                                    this.scene.textures.addCanvas(textureKey, canvas);
                                    console.log(`‚úÖ Created texture: ${textureKey}`);
                                    resolve();
                                } catch (error) {
                                    console.error(`‚ùå Failed to create texture ${textureKey}:`, error);
                                    reject(error);
                                }
                            };
                            
                            image.onerror = () => reject(new Error(`Failed to load image for ${textureKey}`));
                            image.src = `data:image/png;base64,${tile.image.base64}`;
                        });
                        
                        loadPromises.push(promise);
                    }
                }
                
                await Promise.all(loadPromises);
                console.log(`üé® Created ${loadPromises.length} Wang tile textures`);
            }
            
            generateDungeon(width, height) {
                if (!this.currentTileset) {
                    console.error('‚ùå No tileset loaded for dungeon generation');
                    return null;
                }
                
                // Create terrain map
                const terrainMap = [];
                for (let x = 0; x < width; x++) {
                    terrainMap[x] = [];
                    for (let y = 0; y < height; y++) {
                        // Create walls on edges, floors inside
                        if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                            terrainMap[x][y] = 'upper'; // Mossy stone walls
                        } else {
                            terrainMap[x][y] = 'lower'; // Stone floor
                        }
                    }
                }
                
                // Add some interior walls
                for (let i = 0; i < 15; i++) {
                    const x = Phaser.Math.Between(2, width - 3);
                    const y = Phaser.Math.Between(2, height - 3);
                    terrainMap[x][y] = 'upper';
                }
                
                return this.renderWangTileset(terrainMap, width, height);
            }
            
            renderWangTileset(terrainMap, width, height) {
                const tiles = this.currentTileset.tileset_data.tiles;
                const dungeonGroup = this.scene.physics.add.staticGroup();
                
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        const tileX = x * this.tileSize + this.tileSize / 2;
                        const tileY = y * this.tileSize + this.tileSize / 2;
                        
                        // Find appropriate Wang tile based on neighbors
                        const tileData = this.selectWangTile(terrainMap, x, y, tiles);
                        
                        if (tileData) {
                            const textureKey = `tile_${tileData.id}`;
                            if (this.scene.textures.exists(textureKey)) {
                                this.createTileSprite(tileX, tileY, textureKey, terrainMap[x][y] === 'upper', dungeonGroup);
                            }
                        }
                    }
                }
                
                console.log(`üèóÔ∏è Generated professional dungeon with Wang tilesets: ${width}x${height}`);
                return dungeonGroup;
            }
            
            selectWangTile(terrainMap, x, y, tiles) {
                // Determine corner states for Wang tile selection
                const corners = {
                    NW: this.getTerrainAt(terrainMap, x - 1, y - 1),
                    NE: this.getTerrainAt(terrainMap, x, y - 1),
                    SW: this.getTerrainAt(terrainMap, x - 1, y),
                    SE: this.getTerrainAt(terrainMap, x, y)
                };
                
                // Find matching tile
                for (const tile of tiles) {
                    if (this.cornersMatch(corners, tile.corners)) {
                        return tile;
                    }
                }
                
                // Fallback to first tile
                return tiles[0];
            }
            
            getTerrainAt(terrainMap, x, y) {
                if (x < 0 || x >= terrainMap.length || y < 0 || y >= terrainMap[0].length) {
                    return 'upper'; // Walls outside bounds
                }
                return terrainMap[x][y];
            }
            
            cornersMatch(corners, tileCorners) {
                return corners.NW === tileCorners.NW &&
                       corners.NE === tileCorners.NE &&
                       corners.SW === tileCorners.SW &&
                       corners.SE === tileCorners.SE;
            }
            
            createTileSprite(x, y, textureKey, isWall, dungeonGroup) {
                const tile = this.scene.add.sprite(x, y, textureKey);
                tile.setScale(1);
                
                if (isWall) {
                    // Add physics body for walls
                    this.scene.physics.add.existing(tile, true); // Static body
                    dungeonGroup.add(tile);
                }
            }
        }
        
        // Professional Game Scene using ALL assets
        class ProfessionalGameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'ProfessionalGameScene' });
                
                // Game state
                this.hero = null;
                this.enemies = null;
                this.cursors = null;
                this.wasdKeys = null;
                
                // UI elements
                this.healthBar = null;
                this.manaBar = null;
                this.statsText = null;
                this.floorText = null;
                this.messageText = null;
                
                // Game data
                this.currentFloor = 1;
                this.score = 0;
                this.gold = 0;
                this.gameTime = 0;
                
                // Professional systems
                this.wangTilesetManager = null;
                this.dungeonGroup = null;
                this.dungeonWidth = 50;
                this.dungeonHeight = 40;
                
                // Audio system
                this.currentMusic = null;
                this.musicTracks = [];
                
                // Visual effects
                this.particles = null;
            }
            
            preload() {
                console.log('üé® Loading ALL professional PixelLab assets...');
                
                // Load all 8-directional hero sprites
                Object.values(HERO_DIRECTIONS).forEach(direction => {
                    const path = `${ASSET_PATHS.sprites.hero}${direction}.png`;
                    console.log(`Loading hero sprite: hero_${direction} from ${path}`);
                    this.load.image(`hero_${direction}`, path);
                });
                
                // Load all 4-directional enemy sprites
                Object.values(ENEMY_DIRECTIONS).forEach(direction => {
                    this.load.image(`enemy_${direction}`, `${ASSET_PATHS.sprites.enemies}${direction}.png`);
                });
                
                // Load all 4-directional effect sprites
                Object.values(ENEMY_DIRECTIONS).forEach(direction => {
                    this.load.image(`effect_${direction}`, `${ASSET_PATHS.sprites.effects}${direction}.png`);
                });
                
                // Load all 4-directional item sprites
                Object.values(ENEMY_DIRECTIONS).forEach(direction => {
                    this.load.image(`item_${direction}`, `${ASSET_PATHS.sprites.items}${direction}.png`);
                });
                
                // Load all 4-directional UI sprites
                Object.values(ENEMY_DIRECTIONS).forEach(direction => {
                    this.load.image(`ui_${direction}`, `${ASSET_PATHS.sprites.ui}${direction}.png`);
                });
                
                // Load ALL 28 professional music tracks
                for (let i = 1; i <= 28; i++) {
                    this.load.audio(`music_${i}`, `${ASSET_PATHS.music}${i}.mp3`);
                }
                
                // Load professional SFX
                this.load.audio('sword_hit', `${ASSET_PATHS.sfx}sword_hit.ogg`);
                this.load.audio('level_up', `${ASSET_PATHS.sfx}level_up.ogg`);
                this.load.audio('achievement_unlock', `${ASSET_PATHS.sfx}achievement_unlock.ogg`);
                this.load.audio('click', `${ASSET_PATHS.sfx}click.ogg`);
                
                // Update loading progress
                this.load.on('progress', (progress) => {
                    if (window.loadingManager) {
                        window.loadingManager.updateProgress(progress * 90, `Loading professional assets... ${Math.floor(progress * 100)}%`);
                    }
                });
                
                // Handle load errors gracefully
                this.load.on('loaderror', (file) => {
                    console.warn(`‚ö†Ô∏è Failed to load: ${file.key} from ${file.url}`);
                });
            }
            
            async create() {
                console.log('üéÆ Creating Professional game scene with ALL assets...');
                
                // Initialize Wang tileset manager
                this.wangTilesetManager = new WangTilesetManager(this);
                
                // Load professional tileset
                const tilesetLoaded = await this.wangTilesetManager.loadTileset('stone_mossy');
                if (tilesetLoaded) {
                    console.log('üè∞ Professional Wang tileset loaded successfully');
                    
                    // Generate professional dungeon
                    this.dungeonGroup = this.wangTilesetManager.generateDungeon(this.dungeonWidth, this.dungeonHeight);
                } else {
                    console.warn('‚ö†Ô∏è Tileset loading failed, creating fallback dungeon');
                    this.createFallbackDungeon();
                }
                
                // Set world bounds
                this.physics.world.setBounds(0, 0, this.dungeonWidth * 16, this.dungeonHeight * 16);
                
                // Initialize visual effects
                this.setupVisualEffects();
                
                // Create professional hero with 8-directional sprites
                this.hero = new ProfessionalHero(this, 200, 200);
                
                // Create enemies group
                this.enemies = this.physics.add.group();
                this.spawnProfessionalEnemies();
                
                // Set up physics collisions
                this.time.delayedCall(100, () => {
                    if (this.hero && this.enemies && this.hero.body && this.dungeonGroup) {
                        try {
                            this.physics.add.overlap(this.hero, this.enemies, this.heroEnemyCollision, null, this);
                            this.physics.add.collider(this.hero, this.dungeonGroup);
                            this.physics.add.collider(this.enemies, this.dungeonGroup);
                            console.log('‚úÖ Professional physics collisions set up successfully');
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Physics collision setup failed:', error);
                        }
                    }
                });
                
                // Set up controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasdKeys = this.input.keyboard.addKeys('W,S,A,D,SPACE,E,Q');
                
                // Camera follows hero
                this.cameras.main.startFollow(this.hero);
                this.cameras.main.setZoom(2.5); // Zoom in for pixel art
                
                // Create professional UI
                this.createProfessionalUI();
                
                // Start professional background music
                this.startProfessionalMusic();
                
                // Welcome message
                this.showMessage('üê¢ Welcome to the Professional PixelLab Edition!');
                
                console.log('‚úÖ Professional game scene created with ALL assets!');
            }
            
            createFallbackDungeon() {
                // Simple fallback if tileset loading fails
                this.dungeonGroup = this.physics.add.staticGroup();
                
                for (let x = 0; x < this.dungeonWidth; x++) {
                    for (let y = 0; y < this.dungeonHeight; y++) {
                        const tileX = x * 16 + 8;
                        const tileY = y * 16 + 8;
                        
                        if (x === 0 || x === this.dungeonWidth - 1 || y === 0 || y === this.dungeonHeight - 1) {
                            // Create wall
                            const wall = this.add.rectangle(tileX, tileY, 16, 16, 0x555555);
                            this.physics.add.existing(wall, true);
                            this.dungeonGroup.add(wall);
                        } else {
                            // Create floor
                            this.add.rectangle(tileX, tileY, 16, 16, 0x8B4513);
                        }
                    }
                }
                
                console.log('üèóÔ∏è Created fallback dungeon');
            }
            
            spawnProfessionalEnemies() {
                const enemyCount = Math.min(4 + this.currentFloor, 12);
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    let attempts = 0;
                    
                    // Find valid spawn position
                    do {
                        x = Phaser.Math.Between(50, (this.dungeonWidth - 2) * 16);
                        y = Phaser.Math.Between(50, (this.dungeonHeight - 2) * 16);
                        attempts++;
                    } while (Phaser.Math.Distance.Between(x, y, this.hero.x, this.hero.y) < 100 && attempts < 50);
                    
                    if (attempts < 50) {
                        const enemy = new ProfessionalEnemy(this, x, y, 'skeleton', this.currentFloor);
                        this.enemies.add(enemy);
                    }
                }
                
                console.log(`üëπ Spawned ${this.enemies.children.entries.length} professional enemies`);
            }
            
            setupVisualEffects() {
                // Professional particle system
                this.particles = this.add.particles();
            }
            
            createProfessionalUI() {
                // Professional UI background
                const uiHeight = 60;
                const uiBg = this.add.rectangle(640, 30, 1280, uiHeight, 0x000000, 0.8);
                uiBg.setScrollFactor(0);
                
                // Professional health bar
                const healthBarBg = this.add.rectangle(150, 25, 200, 16, 0x660000);
                healthBarBg.setScrollFactor(0);
                this.healthBar = this.add.rectangle(150, 25, 200, 16, 0x00ff00);
                this.healthBar.setScrollFactor(0);
                
                // Professional mana bar
                const manaBarBg = this.add.rectangle(150, 45, 200, 12, 0x000066);
                manaBarBg.setScrollFactor(0);
                this.manaBar = this.add.rectangle(150, 45, 200, 12, 0x0066ff);
                this.manaBar.setScrollFactor(0);
                
                // Professional stats text
                this.statsText = this.add.text(20, 10, '', {
                    fontSize: '14px',
                    color: '#ffffff',
                    fontFamily: 'Courier New'
                });
                this.statsText.setScrollFactor(0);
                
                // Professional floor and score
                this.floorText = this.add.text(1000, 10, '', {
                    fontSize: '14px',
                    color: '#00ff88',
                    fontFamily: 'Courier New'
                });
                this.floorText.setScrollFactor(0);
                
                // Professional message text
                this.messageText = this.add.text(640, 120, '', {
                    fontSize: '20px',
                    color: '#ffff00',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 3
                });
                this.messageText.setOrigin(0.5);
                this.messageText.setScrollFactor(0);
            }
            
            startProfessionalMusic() {
                // Start with a random professional music track
                const trackNumber = Phaser.Math.Between(1, 28);
                this.playProfessionalMusic(`music_${trackNumber}`);
            }
            
            playProfessionalMusic(trackKey) {
                if (this.currentMusic) {
                    this.currentMusic.stop();
                }
                
                try {
                    if (this.sound.get(trackKey)) {
                        this.currentMusic = this.sound.play(trackKey, { 
                            loop: true, 
                            volume: 0.3 
                        });
                        console.log(`üéµ Playing professional music: ${trackKey}`);
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Failed to play music: ${trackKey}`, error);
                }
            }
            
            playSound(soundKey) {
                try {
                    if (this.sound.get(soundKey)) {
                        this.sound.play(soundKey, { volume: 0.5 });
                    }
                } catch (error) {
                    // Fail silently if sound doesn't work
                }
            }
            
            update(time, delta) {
                if (!this.hero || !this.hero.active) return;
                
                this.gameTime += delta;
                
                // Update professional hero
                this.hero.update(time, delta);
                
                // Handle professional input
                this.handleProfessionalInput();
                
                // Update professional enemies
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        enemy.update(time, delta);
                    }
                });
                
                // Update professional UI
                this.updateProfessionalUI();
                
                // Check for floor completion
                if (this.enemies.children.entries.length === 0 || this.enemies.children.entries.every(e => !e.active)) {
                    this.nextProfessionalFloor();
                }
            }
            
            handleProfessionalInput() {
                const speed = this.hero.speed;
                this.hero.setVelocity(0);
                
                // Professional 8-directional movement
                let moveX = 0;
                let moveY = 0;
                
                if (this.cursors.left.isDown || this.wasdKeys.A.isDown) {
                    moveX = -1;
                } else if (this.cursors.right.isDown || this.wasdKeys.D.isDown) {
                    moveX = 1;
                }
                
                if (this.cursors.up.isDown || this.wasdKeys.W.isDown) {
                    moveY = -1;
                } else if (this.cursors.down.isDown || this.wasdKeys.S.isDown) {
                    moveY = 1;
                }
                
                // Apply professional movement with proper 8-directional normalization
                if (moveX !== 0 || moveY !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length;
                    moveY /= length;
                    
                    this.hero.setVelocity(moveX * speed, moveY * speed);
                }
                
                // Professional attack
                if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.SPACE)) {
                    this.hero.attack();
                }
            }
            
            updateProfessionalUI() {
                if (!this.hero) return;
                
                // Professional health bar
                const healthPercent = this.hero.health / this.hero.maxHealth;
                this.healthBar.scaleX = healthPercent;
                this.healthBar.fillColor = healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000;
                
                // Professional mana bar
                const manaPercent = this.hero.mana / this.hero.maxMana;
                this.manaBar.scaleX = manaPercent;
                
                // Professional stats text
                this.statsText.setText([
                    `‚ù§Ô∏è ${Math.ceil(this.hero.health)}/${this.hero.maxHealth}`,
                    `üíô ${Math.ceil(this.hero.mana)}/${this.hero.maxMana}`,
                    `‚≠ê Lv.${this.hero.level} (${this.hero.experience}/${this.hero.experienceToNext})`,
                    `üí∞ ${this.gold}G  ‚öîÔ∏è ${this.hero.attack}  üõ°Ô∏è ${this.hero.defense}`
                ].join('  '));
                
                // Professional floor and score
                this.floorText.setText([
                    `üè∞ Professional Floor ${this.currentFloor}`,
                    `üéØ Score: ${this.score}`,
                    `üëπ Enemies: ${this.enemies.children.entries.filter(e => e.active).length}`
                ].join('  '));
            }
            
            heroEnemyCollision(hero, enemy) {
                // Professional collision handling
                if (!hero || !enemy || !hero.body || !enemy.body) {
                    return;
                }
                
                try {
                    if (enemy.attackTarget && typeof enemy.attackTarget === 'function') {
                        enemy.attackTarget();
                    }
                } catch (error) {
                    console.warn('Professional collision error:', error);
                }
            }
            
            createAttackEffect(x, y, damage, direction) {
                // Professional directional attack effect
                const attackRadius = 50;
                const attackArea = this.add.circle(x, y, attackRadius, 0xffffff, 0.4);
                
                // Damage enemies in range
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        const distance = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
                        if (distance < attackRadius) {
                            enemy.takeDamage(damage);
                        }
                    }
                });
                
                // Professional attack effect removal
                this.tweens.add({
                    targets: attackArea,
                    alpha: 0,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 200,
                    onComplete: () => attackArea.destroy()
                });
            }
            
            createMagicEffect(x, y, type) {
                // Professional particle effect using professional effect sprites
                const colors = {
                    level_up: 0xffd700,
                    death: 0xff4444,
                    magic: 0x00ff88
                };
                
                const color = colors[type] || colors.magic;
                
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 30, max: 80 },
                    scale: { start: 0.6, end: 0 },
                    tint: color,
                    lifespan: 1000,
                    quantity: 12,
                    blendMode: 'ADD'
                });
                
                this.time.delayedCall(100, () => emitter.stop());
            }
            
            createImpactEffect(x, y, color) {
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 60, max: 120 },
                    scale: { start: 0.3, end: 0 },
                    tint: color,
                    lifespan: 300,
                    quantity: 8
                });
                
                this.time.delayedCall(50, () => emitter.stop());
            }
            
            showFloatingText(x, y, text, color = '#ffffff', size = '16px') {
                const floatingText = this.add.text(x, y, text, {
                    fontSize: size,
                    color: color,
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 2
                });
                floatingText.setOrigin(0.5);
                
                this.tweens.add({
                    targets: floatingText,
                    y: y - 40,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Power2',
                    onComplete: () => floatingText.destroy()
                });
            }
            
            showMessage(text, duration = 3000) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);
                
                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    duration: duration,
                    ease: 'Power2'
                });
            }
            
            dropLoot(x, y, level) {
                // Professional loot drop
                const goldAmount = Phaser.Math.Between(8, 20) * level;
                this.gold += goldAmount;
                this.showFloatingText(x + 15, y, `+${goldAmount}G`, '#ffd700');
            }
            
            nextProfessionalFloor() {
                this.currentFloor++;
                
                // Professional floor progression
                this.hero.health = Math.min(this.hero.maxHealth, this.hero.health + Math.floor(this.hero.maxHealth * 0.25));
                this.hero.mana = Math.min(this.hero.maxMana, this.hero.mana + Math.floor(this.hero.maxMana * 0.5));
                
                // Clear enemies
                this.enemies.clear(true, true);
                
                // Generate new professional dungeon
                if (this.wangTilesetManager && this.wangTilesetManager.currentTileset) {
                    this.dungeonGroup = this.wangTilesetManager.generateDungeon(this.dungeonWidth, this.dungeonHeight);
                }
                
                // Spawn new professional enemies
                this.spawnProfessionalEnemies();
                
                // Move hero to start position
                this.hero.setPosition(200, 200);
                
                // Update score
                this.score += 1500 * this.currentFloor;
                
                // Change professional music every few floors
                if (this.currentFloor % 3 === 0) {
                    const trackNumber = Phaser.Math.Between(1, 28);
                    this.playProfessionalMusic(`music_${trackNumber}`);
                }
                
                // Professional floor completion message
                this.showMessage(`üè∞ Professional Floor ${this.currentFloor} - PixelLab Depths Await!`);
                
                // Professional screen flash
                this.cameras.main.flash(400, 0, 150, 255, 0.3);
                
                console.log(`üè∞ Advanced to Professional floor ${this.currentFloor}`);
            }
            
            gameOver() {
                // Professional game over sequence
                if (this.currentMusic) {
                    this.currentMusic.stop();
                }
                
                // Epic professional screen shake
                this.cameras.main.shake(800, 0.03);
                
                // Professional dark overlay
                this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.9).setScrollFactor(0);
                
                // Professional game over text
                const gameOverText = this.add.text(640, 280, 'üíÄ PROFESSIONAL GAME OVER', {
                    fontSize: '64px',
                    color: '#ff0000',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Professional animated text
                this.tweens.add({
                    targets: gameOverText,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Professional final stats
                const statsText = this.add.text(640, 380, [
                    `Final Score: ${this.score}`,
                    `Professional Floor Reached: ${this.currentFloor}`,
                    `Level: ${this.hero.level}`,
                    `Time Survived: ${Math.floor(this.gameTime / 60000)}:${Math.floor((this.gameTime % 60000) / 1000).toString().padStart(2, '0')}`,
                    `Gold Collected: ${this.gold}G`,
                    '',
                    'üé® Powered by Professional PixelLab Assets'
                ].join('\n'), {
                    fontSize: '20px',
                    color: '#ffffff',
                    fontFamily: 'Courier New',
                    align: 'center'
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Professional restart instructions
                const restartText = this.add.text(640, 520, 'Press R to Restart Professional Game', {
                    fontSize: '18px',
                    color: '#00ff88',
                    fontFamily: 'Courier New'
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Professional input handlers
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
                
                console.log('üíÄ Professional Game Over');
            }
        }
        
        // Professional game configuration
        const professionalGameConfig = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            parent: 'game-container',
            backgroundColor: '#1a1a1a',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                min: { width: 640, height: 360 },
                max: { width: 1920, height: 1080 }
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { x: 0, y: 0 },
                    debug: false,
                    fps: 60
                }
            },
            render: {
                antialias: false,
                pixelArt: true,
                roundPixels: true
            },
            audio: {
                disableWebAudio: false
            },
            scene: [ProfessionalGameScene]
        };
        
        // Initialize professional game with all assets
        window.addEventListener('load', function() {
            window.loadingManager = new LoadingManager();
            
            window.loadingManager.updateProgress(5, 'Initializing Professional PixelLab engine...');
            
            setTimeout(() => {
                window.loadingManager.updateProgress(15, 'Loading professional assets...');
                
                setTimeout(() => {
                    // Start the professional game
                    gameInstance = new Phaser.Game(professionalGameConfig);
                    
                    // Hide loading screen after assets load
                    gameInstance.events.once('ready', () => {
                        setTimeout(() => {
                            window.loadingManager.updateProgress(100, 'Professional PixelLab adventure ready!');
                            setTimeout(() => {
                                window.loadingManager.hide();
                                console.log('üê¢ Professional PixelLab Ultimate Edition - READY TO PLAY!');
                            }, 500);
                        }, 1000);
                    });
                    
                    // Global access for debugging
                    window.game = gameInstance;
                }, 300);
            }, 300);
        });
    </script>
</body>
</html>
