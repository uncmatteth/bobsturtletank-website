<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🐢 Bob The Turtle: Hero Of Turtle Dungeon Depths - Complete Roguelike</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            border: 2px solid #34495e;
        }
        
        /* Game UI */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #game-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            border: 2px solid #34495e;
            pointer-events: auto;
            min-width: 200px;
        }
        
        #inventory-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            border: 2px solid #34495e;
            pointer-events: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #message-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 120px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            border: 2px solid #34495e;
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .stat-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            display: inline-block;
            margin-left: 5px;
        }
        
        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .health-fill { background: #e74c3c; }
        .mana-fill { background: #3498db; }
        .exp-fill { background: #f39c12; }
        .oxygen-fill { background: #1abc9c; }
        
        .item-slot {
            background: rgba(52, 73, 94, 0.5);
            border: 1px solid #34495e;
            border-radius: 4px;
            padding: 4px;
            margin: 2px 0;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .item-slot:hover {
            background: rgba(52, 152, 219, 0.3);
        }
        
        .item-identified { color: #2ecc71; }
        .item-unidentified { color: #f39c12; }
        .item-cursed { color: #e74c3c; }
        
        .ability-button {
            background: rgba(52, 73, 94, 0.8);
            border: 2px solid #3498db;
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
            margin: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .ability-button:hover {
            background: rgba(52, 152, 219, 0.6);
            transform: translateY(-1px);
        }
        
        .ability-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Main Menu Animations */
        @keyframes glow {
            from { text-shadow: 4px 4px 8px rgba(0,0,0,0.8), 0 0 10px #3498db; }
            to { text-shadow: 4px 4px 8px rgba(0,0,0,0.8), 0 0 20px #3498db, 0 0 30px #3498db; }
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.6) !important;
        }
        
        @media (max-width: 768px) {
            #game-stats, #inventory-panel {
                font-size: 11px;
                padding: 10px;
                width: auto;
                max-width: 180px;
            }
            #message-log {
                height: 80px;
                font-size: 10px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>
<body>
    <!-- Game UI Overlay -->
    <div id="ui-overlay">
        <div id="game-stats">
            <div><strong>🐢 Bob The Turtle</strong></div>
            <div>❤️ Health: <span id="health-text">100/100</span><div class="stat-bar"><div class="stat-fill health-fill" id="health-bar"></div></div></div>
            <div>💙 Mana: <span id="mana-text">50/50</span><div class="stat-bar"><div class="stat-fill mana-fill" id="mana-bar"></div></div></div>
            <div>🫧 Oxygen: <span id="oxygen-text">100/100</span><div class="stat-bar"><div class="stat-fill oxygen-fill" id="oxygen-bar"></div></div></div>
            <div>⭐ Level: <span id="level-text">1</span></div>
            <div>🏆 EXP: <span id="exp-text">0/100</span><div class="stat-bar"><div class="stat-fill exp-fill" id="exp-bar"></div></div></div>
            <div>🏰 Depth: <span id="depth-text">1</span></div>
            <div>🎯 Turn: <span id="turn-text">1</span></div>
            <div>💰 Gold: <span id="gold-text">0</span></div>
            
            <div style="margin-top: 10px;"><strong>🗺️ Minimap:</strong></div>
            <canvas id="minimap" width="200" height="144" style="border: 2px solid #34495e; background: #2c3e50;"></canvas>
            
            <div style="margin-top: 10px;"><strong>🐢 Turtle Abilities:</strong></div>
            <button class="ability-button" id="shell-retreat-btn">🛡️ Shell Retreat</button>
            <button class="ability-button" id="swim-boost-btn">🏊 Swim Boost</button>
            
            <div style="margin-top: 10px;"><strong>📦 Inventory:</strong></div>
            <button class="ability-button" id="inventory-btn" style="background: #8b4513;">🎒 Backpack</button>
            <button class="ability-button" id="identify-btn">🔍 Identify</button>
        </div>
        
        <div id="inventory-panel" style="display: none;">
            <div><strong>🎒 Inventory (</strong><span id="inventory-count">0</span><strong>/20)</strong></div>
            <div id="equipped-items">
                <div>⚔️ Weapon: <span id="weapon-text">Shell Claw (+3)</span></div>
                <div>🛡️ Armor: <span id="armor-text">Turtle Shell (+5)</span></div>
                <div>💍 Ring: <span id="ring-text">None</span></div>
            </div>
            <div style="margin-top: 10px;"><strong>📦 Items:</strong></div>
            <div id="inventory-items">
                <!-- Items will be populated by JavaScript -->
            </div>
            <div style="margin-top: 10px; padding: 5px; background: rgba(0,0,0,0.6); border-radius: 3px; font-size: 11px;">
                <strong>🎮 Controls:</strong><br/>
                <span style="color: #3498db;">I</span> = Toggle Inventory<br/>
                <span style="color: #f39c12;">E</span> = Equipment View<br/>
                <span style="color: #e74c3c;">R</span> = Identify Item<br/>
                <span style="color: #2ecc71;">U</span> = Use Random Item<br/>
                <span style="color: #95a5a6;">Click items to use them</span>
            </div>
        </div>
        
        <div id="message-log">
            <div id="messages">
                <div style="color: #3498db;">🐢 Welcome to the Turtle Dungeon Depths!</div>
                <div style="color: #2ecc71;">Move with arrow keys or click. Use turtle abilities wisely!</div>
                <div style="color: #f39c12;">Find items, fight enemies, and descend deeper!</div>
            </div>
        </div>
        
        <!-- Audio Controls -->
        <div id="audio-controls" style="position: absolute; top: 10px; right: 10px; pointer-events: auto;">
            <button id="music-toggle-btn" style="padding: 5px 8px; margin: 2px; font-size: 11px; background: rgba(0,0,0,0.7); color: white; border: 1px solid #444; border-radius: 3px; cursor: pointer;">🎵 Music: ON</button>
            <button id="volume-down-btn" style="padding: 5px 8px; margin: 2px; font-size: 11px; background: rgba(0,0,0,0.7); color: white; border: 1px solid #444; border-radius: 3px; cursor: pointer;">🔉</button>
            <button id="volume-up-btn" style="padding: 5px 8px; margin: 2px; font-size: 11px; background: rgba(0,0,0,0.7); color: white; border: 1px solid #444; border-radius: 3px; cursor: pointer;">🔊</button>
        </div>
        
        <!-- Pause Menu Overlay -->
        <div id="pause-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; pointer-events: auto;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c3e50; padding: 40px; border-radius: 15px; border: 3px solid #34495e; text-align: center; min-width: 400px;">
                <h2 style="color: #3498db; margin-top: 0; font-family: Arial Black;">⏸️ GAME PAUSED</h2>
                <div style="margin: 30px 0;">
                    <button id="resume-btn" style="display: block; width: 200px; margin: 10px auto; padding: 12px; font-size: 16px; background: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black;">▶️ Resume Game</button>
                    <button id="restart-btn" style="display: block; width: 200px; margin: 10px auto; padding: 12px; font-size: 16px; background: #e74c3c; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black;">🔄 Restart Level</button>
                    <button id="main-menu-btn" style="display: block; width: 200px; margin: 10px auto; padding: 12px; font-size: 16px; background: #95a5a6; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black;">🏠 Main Menu</button>
                </div>
                <div style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                    <h4 style="color: #f39c12; margin: 0 0 10px 0;">⚙️ Settings</h4>
                                            <div style="margin: 8px 0; display: flex; align-items: center; gap: 10px;">
                            <label style="color: white; margin-right: 10px;">🎵 Music:</label>
                            <button id="music-mute-btn" style="padding: 5px 10px; font-size: 14px; background: #2ecc71; color: white; border: none; border-radius: 3px; cursor: pointer; min-width: 60px;">🔊</button>
                            <input type="range" id="music-volume-slider" min="0" max="100" value="30" style="width: 120px;">
                            <span id="music-volume-text" style="color: #3498db; min-width: 40px;">30%</span>
                        </div>
                        <div style="margin: 8px 0; display: flex; align-items: center; gap: 10px;">
                            <label style="color: white; margin-right: 10px;">🔊 SFX:</label>
                            <button id="sfx-mute-btn" style="padding: 5px 10px; font-size: 14px; background: #2ecc71; color: white; border: none; border-radius: 3px; cursor: pointer; min-width: 60px;">🔊</button>
                            <input type="range" id="sfx-volume-slider" min="0" max="100" value="70" style="width: 120px;">
                            <span id="sfx-volume-text" style="color: #3498db; min-width: 40px;">70%</span>
                        </div>
                </div>
                <p style="color: #95a5a6; font-size: 12px; margin-bottom: 0;">Press ESC to toggle pause menu</p>
            </div>
        </div>
        
        <!-- Item Tooltip -->
        <div id="item-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.95); color: white; padding: 12px; border-radius: 8px; border: 2px solid #34495e; font-size: 12px; z-index: 2000; pointer-events: none; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.8);">
            <div id="tooltip-content"></div>
        </div>
        
        <!-- Tutorial Overlay -->
        <div id="tutorial-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 3000; pointer-events: auto;">
            <div id="tutorial-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c3e50; padding: 30px; border-radius: 15px; border: 3px solid #3498db; text-align: center; max-width: 600px; color: white;">
                <h2 id="tutorial-title" style="color: #3498db; margin-top: 0;">🐢 Welcome to Turtle Dungeon Depths!</h2>
                <div id="tutorial-text" style="margin: 20px 0; line-height: 1.6;"></div>
                <div style="margin: 20px 0;">
                    <button id="tutorial-prev" style="padding: 10px 20px; margin: 5px; font-size: 14px; background: #95a5a6; color: white; border: none; border-radius: 5px; cursor: pointer;">⬅️ Previous</button>
                    <button id="tutorial-next" style="padding: 10px 20px; margin: 5px; font-size: 14px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">Next ➡️</button>
                    <button id="tutorial-skip" style="padding: 10px 20px; margin: 5px; font-size: 14px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">Skip Tutorial</button>
                </div>
                <div id="tutorial-progress" style="font-size: 12px; color: #bdc3c7;">Step <span id="tutorial-step">1</span> of <span id="tutorial-total">5</span></div>
            </div>
        </div>
        
        <!-- Boss Introduction Overlay -->
        <div id="boss-intro-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 2500; pointer-events: auto;">
            <div id="boss-intro-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; max-width: 800px;">
                <div id="boss-warning" style="font-size: 24px; color: #e74c3c; font-family: Arial Black; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">⚠️ BOSS ENCOUNTER ⚠️</div>
                <div id="boss-name" style="font-size: 48px; color: #ff6b35; font-family: Arial Black; margin: 20px 0; text-shadow: 3px 3px 6px rgba(0,0,0,0.8);"></div>
                <div id="boss-description" style="font-size: 18px; color: #bdc3c7; margin: 30px 0; line-height: 1.6;"></div>
                <div id="boss-stats" style="font-size: 16px; color: #f39c12; margin: 20px 0;"></div>
                <div style="margin: 30px 0;">
                    <button id="boss-ready-btn" style="padding: 15px 30px; font-size: 18px; background: #e74c3c; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black; box-shadow: 0 4px 8px rgba(0,0,0,0.4);">⚔️ FIGHT!</button>
                </div>
            </div>
        </div>
        
        <!-- Main Menu / Title Screen -->
        <div id="main-menu-overlay" style="display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 50%, #34495e 100%); z-index: 5000; pointer-events: auto;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; max-width: 800px;">
                <!-- Animated Title -->
                <div style="margin-bottom: 40px;">
                    <h1 style="font-size: 64px; color: #3498db; font-family: Arial Black; margin: 0; text-shadow: 4px 4px 8px rgba(0,0,0,0.8); animation: glow 2s ease-in-out infinite alternate;">
                        🐢 BOB THE TURTLE
                    </h1>
                    <h2 style="font-size: 32px; color: #f39c12; font-family: Arial Black; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                        HERO OF TURTLE DUNGEON DEPTHS
                    </h2>
                    <div style="font-size: 18px; color: #2ecc71; margin: 20px 0; font-style: italic;">
                        A Legendary Roguelike Adventure
                    </div>
                </div>
                
                <!-- Menu Buttons -->
                <div style="margin: 40px 0;">
                    <button id="new-game-btn" style="display: block; width: 300px; margin: 15px auto; padding: 15px; font-size: 20px; background: #27ae60; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transition: all 0.3s;">
                        🎮 NEW GAME
                    </button>
                    <button id="continue-game-btn" style="display: block; width: 300px; margin: 15px auto; padding: 15px; font-size: 20px; background: #3498db; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transition: all 0.3s;" disabled>
                        📂 CONTINUE
                    </button>
                    <button id="settings-btn" style="display: block; width: 300px; margin: 15px auto; padding: 15px; font-size: 20px; background: #95a5a6; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transition: all 0.3s;">
                        ⚙️ SETTINGS
                    </button>
                    <button id="credits-btn" style="display: block; width: 300px; margin: 15px auto; padding: 15px; font-size: 20px; background: #e67e22; color: white; border: none; border-radius: 8px; cursor: pointer; font-family: Arial Black; box-shadow: 0 4px 8px rgba(0,0,0,0.4); transition: all 0.3s;">
                        🏆 CREDITS
                    </button>
                </div>
                
                <!-- Game Info -->
                <div style="margin-top: 30px; font-size: 14px; color: #bdc3c7;">
                    <div>🎯 Survive the depths • ⚔️ Battle sea monsters • 🏆 Become legend</div>
                    <div style="margin-top: 10px; font-size: 12px; color: #95a5a6;">
                        Powered by PixelLab AI Assets • Professional Roguelike Experience
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Settings Panel -->
        <div id="settings-panel" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5100; pointer-events: auto;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c3e50; padding: 40px; border-radius: 15px; border: 3px solid #3498db; text-align: center; max-width: 600px; color: white;">
                <h2 style="color: #3498db; margin-top: 0;">⚙️ GAME SETTINGS</h2>
                
                <div style="margin: 30px 0; text-align: left;">
                    <div style="margin: 20px 0;">
                        <label style="color: white; display: block; margin-bottom: 8px;">🎵 Music Volume:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="settings-music-mute-btn" style="padding: 5px 10px; font-size: 14px; background: #2ecc71; color: white; border: none; border-radius: 3px; cursor: pointer; min-width: 60px;">🔊</button>
                            <input type="range" id="settings-music-volume" min="0" max="100" value="30" style="flex: 1;">
                            <span id="settings-music-text" style="color: #3498db; min-width: 40px;">30%</span>
                        </div>
                    </div>
                    <div style="margin: 20px 0;">
                        <label style="color: white; display: block; margin-bottom: 8px;">🔊 Sound Effects:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button id="settings-sfx-mute-btn" style="padding: 5px 10px; font-size: 14px; background: #2ecc71; color: white; border: none; border-radius: 3px; cursor: pointer; min-width: 60px;">🔊</button>
                            <input type="range" id="settings-sfx-volume" min="0" max="100" value="70" style="flex: 1;">
                            <span id="settings-sfx-text" style="color: #3498db; min-width: 40px;">70%</span>
                        </div>
                    </div>
                    <div style="margin: 20px 0;">
                        <label style="color: white; display: block; margin-bottom: 8px;">🎮 Controls:</label>
                        <div style="color: #bdc3c7; font-size: 14px; line-height: 1.6;">
                            • Arrow Keys / WASD - Move<br/>
                            • Mouse Click - Move to location<br/>
                            • ESC - Pause Menu<br/>
                            • I - Inventory<br/>
                            • Q - Shell Retreat<br/>
                            • W - Swim Boost
                        </div>
                    </div>
                </div>
                
                <div style="margin: 20px 0;">
                    <button id="settings-back-btn" style="padding: 12px 30px; font-size: 16px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: Arial Bold;">⬅️ Back to Menu</button>
                </div>
            </div>
        </div>
        
        <!-- Credits Panel -->
        <div id="credits-panel" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 5100; pointer-events: auto;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c3e50; padding: 40px; border-radius: 15px; border: 3px solid #f39c12; text-align: center; max-width: 600px; color: white;">
                <h2 style="color: #f39c12; margin-top: 0;">🏆 CREDITS</h2>
                
                <div style="margin: 30px 0; line-height: 1.8; font-size: 16px;">
                    <div style="margin: 15px 0;">
                        <strong style="color: #3498db;">🎮 Game Design & Development</strong><br/>
                        <span style="color: #2ecc71;">AI Assistant with Cursor</span>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong style="color: #e74c3c;">🎨 Professional Assets</strong><br/>
                        <span style="color: #2ecc71;">PixelLab AI Character Generator</span>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong style="color: #9b59b6;">🎵 Audio System</strong><br/>
                        <span style="color: #2ecc71;">Web Audio API + Procedural Sounds</span>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong style="color: #e67e22;">🔧 Game Engine</strong><br/>
                        <span style="color: #2ecc71;">Phaser 3.90.0 + ROT.js</span>
                    </div>
                    <div style="margin: 25px 0; font-style: italic; color: #bdc3c7;">
                        "Built with passion for epic roguelike adventures!"
                    </div>
                </div>
                
                <div style="margin: 20px 0;">
                    <button id="credits-back-btn" style="padding: 12px 30px; font-size: 16px; background: #f39c12; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: Arial Bold;">⬅️ Back to Menu</button>
                </div>
            </div>
        </div>
        
        <!-- Uncle Matt NPC Overlay -->
        <div id="uncle-matt-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2500; pointer-events: auto;">
            <div id="uncle-matt-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; max-width: 700px; background: #2c3e50; padding: 40px; border-radius: 15px; border: 3px solid #27ae60;">
                <div style="font-size: 32px; color: #f39c12; font-family: Arial Black; margin-bottom: 15px;">🎩 UNCLE MATT'S EXPLORER DEPOT! 🎩</div>
                <div style="font-size: 18px; color: #bdc3c7; margin: 20px 0; line-height: 1.6;">
                    "Well, well! Look who stumbled into my jungle camp! I'm Uncle Matt, legendary explorer of these underwater ruins. 
                    I've got some special gear that might help a brave turtle like you survive these depths!"
                </div>
                <div style="font-size: 16px; color: #e67e22; margin: 15px 0; font-weight: bold;">🎁 Choose ONE Explorer's Bonus:</div>
                <div id="matt-bonus-options" style="margin: 25px 0;">
                    <!-- Bonus options will be populated by JavaScript -->
                </div>
                <div style="font-size: 12px; color: #95a5a6; margin-top: 20px; font-style: italic;">
                    "Choose wisely, young turtle! Uncle Matt's gear is legendary in these parts!"
                </div>
            </div>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <script type="module">
        // PRODUCTION ROGUELIKE IMPLEMENTATION
        // Professional quality with PixelLab assets and industry standard patterns
        
        // Main Menu System
        class MainMenuManager {
            constructor() {
                this.gameStarted = false;
                this.setupMainMenu();
            }
            
            setupMainMenu() {
                // Check for existing save
                this.updateContinueButton();
                
                // Setup menu button handlers
                const newGameBtn = document.getElementById('new-game-btn');
                const continueBtn = document.getElementById('continue-game-btn');
                const settingsBtn = document.getElementById('settings-btn');
                
                console.log('🔧 Setting up menu buttons...', {
                    newGameBtn: !!newGameBtn,
                    continueBtn: !!continueBtn,
                    settingsBtn: !!settingsBtn
                });
                
                if (newGameBtn) {
                    newGameBtn.addEventListener('click', () => {
                        console.log('🎮 New Game clicked!');
                        this.startNewGame();
                    });
                }
                
                if (continueBtn) {
                    continueBtn.addEventListener('click', () => {
                        console.log('📂 Continue Game clicked!');
                        this.continueGame();
                    });
                }
                
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', () => {
                        console.log('⚙️ Settings clicked!');
                        this.showSettings();
                    });
                }
                
                const creditsBtn = document.getElementById('credits-btn');
                console.log('🔧 Credits button found:', !!creditsBtn);
                
                if (creditsBtn) {
                    creditsBtn.addEventListener('click', () => {
                        console.log('🎬 Credits clicked!');
                        this.showCredits();
                    });
                }
                
                // Settings panel handlers
                document.getElementById('settings-back-btn').addEventListener('click', () => {
                    this.hideSettings();
                });
                
                document.getElementById('credits-back-btn').addEventListener('click', () => {
                    this.hideCredits();
                });
                
                // Settings volume handlers
                const musicSlider = document.getElementById('settings-music-volume');
                const sfxSlider = document.getElementById('settings-sfx-volume');
                
                musicSlider.addEventListener('input', (e) => {
                    document.getElementById('settings-music-text').textContent = e.target.value + '%';
                    document.getElementById('music-volume-text').textContent = e.target.value + '%';
                    document.getElementById('music-volume-slider').value = e.target.value;
                    localStorage.setItem('bobTurtle_musicVolume', e.target.value);
                    this.updateGameAudio();
                });
                
                sfxSlider.addEventListener('input', (e) => {
                    document.getElementById('settings-sfx-text').textContent = e.target.value + '%';
                    document.getElementById('sfx-volume-text').textContent = e.target.value + '%';
                    document.getElementById('sfx-volume-slider').value = e.target.value;
                    localStorage.setItem('bobTurtle_sfxVolume', e.target.value);
                    this.updateGameAudio();
                });
                
                // Pause menu volume handlers (sync with settings)
                document.getElementById('music-volume-slider').addEventListener('input', (e) => {
                    document.getElementById('music-volume-text').textContent = e.target.value + '%';
                    document.getElementById('settings-music-text').textContent = e.target.value + '%';
                    document.getElementById('settings-music-volume').value = e.target.value;
                    localStorage.setItem('bobTurtle_musicVolume', e.target.value);
                    this.updateGameAudio();
                });
                
                document.getElementById('sfx-volume-slider').addEventListener('input', (e) => {
                    document.getElementById('sfx-volume-text').textContent = e.target.value + '%';
                    document.getElementById('settings-sfx-text').textContent = e.target.value + '%';
                    document.getElementById('settings-sfx-volume').value = e.target.value;
                    localStorage.setItem('bobTurtle_sfxVolume', e.target.value);
                    this.updateGameAudio();
                });
                
                // Mute button handlers
                document.getElementById('music-mute-btn').addEventListener('click', () => this.toggleMusicMute());
                document.getElementById('sfx-mute-btn').addEventListener('click', () => this.toggleSfxMute());
                document.getElementById('settings-music-mute-btn').addEventListener('click', () => this.toggleMusicMute());
                document.getElementById('settings-sfx-mute-btn').addEventListener('click', () => this.toggleSfxMute());
                
                // Load saved settings
                this.loadSettings();
            }
            
            updateContinueButton() {
                const hasSave = localStorage.getItem('bobTurtleRoguelike_save');
                const continueBtn = document.getElementById('continue-game-btn');
                
                if (hasSave) {
                    continueBtn.disabled = false;
                    continueBtn.style.background = '#3498db';
                    continueBtn.style.opacity = '1';
                } else {
                    continueBtn.disabled = true;
                    continueBtn.style.background = '#7f8c8d';
                    continueBtn.style.opacity = '0.5';
                }
            }
            
            startNewGame() {
                // Clear any existing save for new game
                localStorage.removeItem('bobTurtleRoguelike_save');
                localStorage.removeItem('bobTurtle_tutorialShown');
                this.hideMainMenu();
                this.initializeGame();
            }
            
            continueGame() {
                if (localStorage.getItem('bobTurtleRoguelike_save')) {
                    this.hideMainMenu();
                    this.initializeGame();
                }
            }
            
            showSettings() {
                document.getElementById('settings-panel').style.display = 'block';
            }
            
            hideSettings() {
                document.getElementById('settings-panel').style.display = 'none';
            }
            
            showCredits() {
                document.getElementById('credits-panel').style.display = 'block';
            }
            
            hideCredits() {
                document.getElementById('credits-panel').style.display = 'none';
            }
            
            loadSettings() {
                const musicVolume = localStorage.getItem('bobTurtle_musicVolume') || '30';
                const sfxVolume = localStorage.getItem('bobTurtle_sfxVolume') || '70';
                const musicMuted = localStorage.getItem('bobTurtle_musicMuted') === 'true';
                const sfxMuted = localStorage.getItem('bobTurtle_sfxMuted') === 'true';
                
                // Update volume sliders and text
                document.getElementById('settings-music-volume').value = musicVolume;
                document.getElementById('settings-music-text').textContent = musicVolume + '%';
                document.getElementById('settings-sfx-volume').value = sfxVolume;
                document.getElementById('settings-sfx-text').textContent = sfxVolume + '%';
                
                document.getElementById('music-volume-slider').value = musicVolume;
                document.getElementById('music-volume-text').textContent = musicVolume + '%';
                document.getElementById('sfx-volume-slider').value = sfxVolume;
                document.getElementById('sfx-volume-text').textContent = sfxVolume + '%';
                
                // Update mute button states
                this.updateMuteButtonState('music', musicMuted);
                this.updateMuteButtonState('sfx', sfxMuted);
            }
            
            toggleMusicMute() {
                const currentlyMuted = localStorage.getItem('bobTurtle_musicMuted') === 'true';
                const newMutedState = !currentlyMuted;
                localStorage.setItem('bobTurtle_musicMuted', newMutedState.toString());
                this.updateMuteButtonState('music', newMutedState);
                this.updateGameAudio();
            }
            
            toggleSfxMute() {
                const currentlyMuted = localStorage.getItem('bobTurtle_sfxMuted') === 'true';
                const newMutedState = !currentlyMuted;
                localStorage.setItem('bobTurtle_sfxMuted', newMutedState.toString());
                this.updateMuteButtonState('sfx', newMutedState);
                this.updateGameAudio();
            }
            
            updateMuteButtonState(type, isMuted) {
                const muteButtons = [
                    document.getElementById(`${type}-mute-btn`),
                    document.getElementById(`settings-${type}-mute-btn`)
                ];
                
                muteButtons.forEach(btn => {
                    if (btn) {
                        btn.textContent = isMuted ? '🔇' : '🔊';
                        btn.style.background = isMuted ? '#e74c3c' : '#2ecc71';
                        btn.title = isMuted ? `Unmute ${type}` : `Mute ${type}`;
                    }
                });
            }
            
            updateGameAudio() {
                // Update game audio if game is running
                if (window.gameInstance && window.gameInstance.scene && window.gameInstance.scene.keys.CompleteRoguelikeScene) {
                    const scene = window.gameInstance.scene.keys.CompleteRoguelikeScene;
                    if (scene && scene.setMusicVolume && scene.setSfxVolume) {
                        const musicVolume = localStorage.getItem('bobTurtle_musicVolume') || '30';
                        const sfxVolume = localStorage.getItem('bobTurtle_sfxVolume') || '70';
                        const musicMuted = localStorage.getItem('bobTurtle_musicMuted') === 'true';
                        const sfxMuted = localStorage.getItem('bobTurtle_sfxMuted') === 'true';
                        
                        const effectiveMusicVolume = musicMuted ? 0 : (musicVolume / 100);
                        const effectiveSfxVolume = sfxMuted ? 0 : (sfxVolume / 100);
                        
                        scene.setMusicVolume(effectiveMusicVolume);
                        scene.setSfxVolume(effectiveSfxVolume);
                    }
                }
            }
            
            hideMainMenu() {
                document.getElementById('main-menu-overlay').style.display = 'none';
                this.gameStarted = true;
            }
            
            showMainMenu() {
                document.getElementById('main-menu-overlay').style.display = 'block';
                this.updateContinueButton();
                this.gameStarted = false;
            }
            
            initializeGame() {
                // Initialize the Phaser game
                if (window.game) {
                    window.game.destroy(true);
                }
                initializePhaserGame();
            }
        }
        
        // Initialize main menu when DOM is ready
        let mainMenu = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎮 DOM loaded, initializing main menu...');
            console.log('🔍 Testing console output...');
            
            // Test if all main menu buttons exist
            const buttons = {
                'new-game-btn': document.getElementById('new-game-btn'),
                'continue-game-btn': document.getElementById('continue-game-btn'),
                'settings-btn': document.getElementById('settings-btn'),
                'credits-btn': document.getElementById('credits-btn')
            };
            
            console.log('🔧 Button existence check:', buttons);
            
            mainMenu = new MainMenuManager();
            console.log('✅ Main menu initialized');
        });
        
        let gameInstance = null;
        
        // Initialize the Phaser game (called from main menu)
        function initializePhaserGame() {
            // Embedded Database Manager (fixes CORS issue with file:// protocol)
            class DatabaseManager {
                constructor() {
                    this.baseURL = window.location.hostname === 'localhost' 
                        ? 'http://localhost:5173' 
                        : 'https://bob-turtle-roguelike.vercel.app';
                    
                    // Check if we're in development mode (including file:// protocol)
                    this.isDevelopment = window.location.hostname === 'localhost' || window.location.protocol === 'file:';
                    
                    // Generate or get player ID
                    this.playerId = this.getOrCreatePlayerId();
                    this.playerName = localStorage.getItem('bobturtle_playername') || 'Anonymous Turtle';
                    
                    if (this.isDevelopment) {
                        console.log('🔧 Development mode: Using localStorage for saves');
                    }
                }
                
                getOrCreatePlayerId() {
                    let playerId = localStorage.getItem('bobturtle_playerid');
                    if (!playerId) {
                        playerId = 'turtle_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('bobturtle_playerid', playerId);
                    }
                    return playerId;
                }
                
                async saveGame(gameData) {
                    if (this.isDevelopment) {
                        try {
                            localStorage.setItem('bobTurtleRoguelike_save', JSON.stringify({
                                ...gameData,
                                playerName: this.playerName,
                                timestamp: Date.now()
                            }));
                            console.log('💾 Game saved locally (dev mode)');
                            return { success: true };
                        } catch (error) {
                            console.error('Local save error:', error);
                            return { success: false, error: error.message };
                        }
                    }
                    return { success: true }; // Simplified for now
                }
                
                async loadGame() {
                    if (this.isDevelopment) {
                        try {
                            const saved = localStorage.getItem('bobTurtleRoguelike_save');
                            if (saved) {
                                console.log('📁 Loading local save (dev mode)');
                                return { saveData: JSON.parse(saved) };
                            }
                            return null;
                        } catch (error) {
                            console.error('Local load error:', error);
                            return null;
                        }
                    }
                    return null;
                }
                
                async unlockAchievement(achievementId) {
                    if (this.isDevelopment) {
                        console.log(`🏆 Achievement unlocked (dev): ${achievementId}`);
                        return { success: true, achievement: { name: "Achievement", icon: "🏆" }, alreadyUnlocked: false };
                    }
                    return { success: true };
                }
                
                async getLeaderboard() {
                    return { leaderboard: [] };
                }
                
                async submitScore(score, depth, level, time) {
                    if (this.isDevelopment) {
                        console.log(`🏆 Dev mode score: ${score} (depth: ${depth}, level: ${level})`);
                    }
                    return { success: true, rank: 1 };
                }
            }
            
            const dbManager = new DatabaseManager();
            console.log('✅ Database manager loaded (embedded)');
            
            // Initialize the game with embedded database manager
        
        // Game constants
        const GAME_CONFIG = {
            TILE_SIZE: 48,  // Bigger tiles for better visibility
            MAP_WIDTH: 25,
            MAP_HEIGHT: 18,
            VIEWPORT_WIDTH: 20,
            VIEWPORT_HEIGHT: 12,
            ROOM_MIN_SIZE: 3,
            ROOM_MAX_SIZE: 6,
            MAX_ROOMS: 6
        };
        
        // Tile types - Underwater dungeon system
        const TILES = {
            VOID: -1,
            FLOOR: 0,          // Sandy underwater floor
            WALL: 1,           // Stone walls with barnacles
            DOOR: 2,           // Broken doorways
            STAIRS_DOWN: 3,    // Stairs to deeper depths
            WATER: 4,          // Shallow flooded areas
            DEEP_WATER: 5,     // Deep water zones
            AIR_POCKET: 6,     // Air bubbles for oxygen
            TREASURE_FLOOR: 7, // Treasure chamber floor
            CORAL_WALL: 8      // Living coral barriers
        };
        
        // Entity types
        const ENTITY_TYPES = {
            PLAYER: 'player',
            ENEMY: 'enemy',
            ITEM: 'item',
            STAIRS: 'stairs',
            MERCHANT: 'merchant'
        };
        
        // Complete item system with identification mechanics
        const ITEM_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            RING: 'ring',
            POTION: 'potion',
            SCROLL: 'scroll',
            FOOD: 'food',
            TREASURE: 'treasure'
        };
        
        // Item database with mystery effects
        const ITEM_DATABASE = {
            weapons: [
                { name: 'Shell Claw', bonus: 3, description: 'Sharp turtle claw' },
                { name: 'Coral Blade', bonus: 6, description: 'Razor-sharp coral sword' },
                { name: 'Trident of Depths', bonus: 10, description: 'Ancient underwater weapon' },
                { name: 'Seaweed Whip', bonus: 4, description: 'Flexible underwater weapon' },
                { name: 'Crab Pincer', bonus: 8, description: 'Powerful crushing weapon' }
            ],
            armor: [
                { name: 'Turtle Shell', bonus: 5, description: 'Natural protective shell' },
                { name: 'Scale Mail', bonus: 8, description: 'Armor made from fish scales' },
                { name: 'Coral Plate', bonus: 12, description: 'Heavy coral armor' },
                { name: 'Seaweed Cloak', bonus: 3, description: 'Light underwater protection' },
                { name: 'Pearl Vest', bonus: 15, description: 'Lustrous pearl armor' }
            ],
            rings: [
                { name: 'Ring of Swimming', bonus: 'swim_speed', description: 'Enhances swimming ability' },
                { name: 'Ring of Regeneration', bonus: 'regen', description: 'Slowly heals wounds' },
                { name: 'Ring of Mana', bonus: 'mana_boost', description: 'Increases magical energy' },
                { name: 'Ring of Protection', bonus: 'defense', description: 'Deflects attacks' },
                { name: 'Ring of Treasure Finding', bonus: 'treasure', description: 'Reveals hidden treasure' }
            ],
            potions: [
                { name: 'Red Potion', effect: 'heal', power: 50, color: '#e74c3c' },
                { name: 'Blue Potion', effect: 'mana', power: 30, color: '#3498db' },
                { name: 'Green Potion', effect: 'poison_cure', power: 100, color: '#2ecc71' },
                { name: 'Purple Potion', effect: 'strength', power: 10, color: '#9b59b6' },
                { name: 'Yellow Potion', effect: 'speed', power: 5, color: '#f1c40f' },
                { name: 'Cyan Potion', effect: 'oxygen', power: 50, color: '#1abc9c' }
            ],
            scrolls: [
                { name: 'Scroll of Identify', effect: 'identify', description: 'Reveals item properties' },
                { name: 'Scroll of Teleport', effect: 'teleport', description: 'Random movement' },
                { name: 'Scroll of Magic Mapping', effect: 'map', description: 'Reveals dungeon layout' },
                { name: 'Scroll of Confusion', effect: 'confuse', description: 'Confuses enemies' },
                { name: 'Scroll of Lightning', effect: 'lightning', description: 'Strikes nearby enemies' }
            ]
        };
        
        // Underwater enemy types with scaling
        const ENEMY_TYPES = {
            fish: { name: 'Angry Fish', health: 20, attack: 5, defense: 2, exp: 25, color: 0x3498db, description: 'A territorial fish guards its territory' },
            crab: { name: 'Dungeon Crab', health: 35, attack: 8, defense: 6, exp: 40, color: 0xe74c3c, description: 'Massive claws can crush shells' },
            octopus: { name: 'Shadow Octopus', health: 45, attack: 10, defense: 4, exp: 60, color: 0x9b59b6, description: 'Tentacles strike from the darkness' },
            shark: { name: 'Cave Shark', health: 70, attack: 15, defense: 8, exp: 100, color: 0x34495e, description: 'Apex predator of flooded caves' },
            kraken: { name: 'Deep Kraken', health: 150, attack: 25, defense: 12, exp: 300, color: 0x2c3e50, description: 'Ancient beast of the depths' },
            seamonster: { name: 'Sea Monster', health: 100, attack: 20, defense: 10, exp: 200, color: 0x1abc9c, description: 'Tentacled horror from the abyss' }
        };
        
        // Complete game state with all systems
        class GameState {
            constructor() {
                this.currentDepth = 1;
                this.turnCount = 1;
                this.gameMap = null;
                this.rooms = [];
                this.player = null;
                this.entities = [];
                this.messageLog = [];
                this.inventory = [];
                this.equipment = {
                    weapon: this.createStartingWeapon(),
                    armor: this.createStartingArmor(),
                    ring: null
                };
                this.gold = 0;
                this.identifiedItems = new Set();
                this.gameStartTime = Date.now();
                this.levelStartTime = Date.now(); // Track level completion time
                this.achievements = new Set();
                this.stats = {
                    enemiesKilled: 0,
                    bossesKilled: 0,
                    itemsFound: 0,
                    treasureRoomsFound: 0,
                    deepestDepth: 1,
                    totalScore: 0
                };
                this.loadAchievements();
                this.loadHighScores();
                this.gameStartTime = Date.now();
                this.permadeath = true;
            }
            
            createStartingWeapon() {
                return {
                    name: 'Shell Claw',
                    type: ITEM_TYPES.WEAPON,
                    bonus: 3,
                    identified: true,
                    description: 'Your natural turtle claw'
                };
            }
            
            createStartingArmor() {
                return {
                    name: 'Turtle Shell',
                    type: ITEM_TYPES.ARMOR,
                    bonus: 5,
                    identified: true,
                    description: 'Your protective shell'
                };
            }
            
            addMessage(text, color = '#ffffff') {
                this.messageLog.push({ text, color, turn: this.turnCount });
                this.updateMessageDisplay();
                
                if (this.messageLog.length > 100) {
                    this.messageLog = this.messageLog.slice(-100);
                }
            }
            
            updateMessageDisplay() {
                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = this.messageLog.slice(-15).map(msg => 
                    `<div style="color: ${msg.color};">[${msg.turn}] ${msg.text}</div>`
                ).join('');
                
                // Scroll the message log container to show newest messages
                const messageLogDiv = document.getElementById('message-log');
                if (messageLogDiv) {
                    messageLogDiv.scrollTop = messageLogDiv.scrollHeight;
                }
                
                // Also scroll the inner messages div as backup
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            nextTurn() {
                this.turnCount++;
                document.getElementById('turn-text').textContent = this.turnCount;
            }
            
            addToInventory(item) {
                if (this.inventory.length < 20) {
                    this.inventory.push(item);
                    this.updateInventoryDisplay();
                    return true;
                }
                return false;
            }
            
            removeFromInventory(item) {
                const index = this.inventory.indexOf(item);
                if (index > -1) {
                    this.inventory.splice(index, 1);
                    this.updateInventoryDisplay();
                    return true;
                }
                return false;
            }
            
            updateInventoryDisplay() {
                const inventoryDiv = document.getElementById('inventory-items');
                const countSpan = document.getElementById('inventory-count');
                
                countSpan.textContent = this.inventory.length;
                
                inventoryDiv.innerHTML = this.inventory.map((item, index) => {
                    const identified = item.identified || this.identifiedItems.has(item.name);
                    const displayName = identified ? item.name : `Unknown ${item.type}`;
                    const cssClass = identified ? 'item-identified' : 'item-unidentified';
                    const bonusText = identified && item.bonus ? ` (+${item.bonus})` : '';
                    
                    return `<div class="item-slot ${cssClass}" 
                                data-item-index="${index}"
                                data-item-data='${JSON.stringify(item).replace(/'/g, '&apos;')}'
                                data-identified="${identified}"
                                style="cursor: pointer;">
                                🔹 ${displayName}${bonusText}
                                ${identified ? '' : ' ❓'}
                            </div>`;
                }).join('');
                
                // Add helpful text if inventory is empty
                if (this.inventory.length === 0) {
                    inventoryDiv.innerHTML = '<div style="color: #95a5a6; font-style: italic; padding: 10px;">No items in inventory<br/>Kill enemies and open chests to find loot!</div>';
                }
                
                // Refresh click handlers after updating inventory
                if (window.gameInstance && window.gameInstance.scene && window.gameInstance.scene.scenes[0]) {
                    window.gameInstance.scene.scenes[0].setupInventoryClickHandlers();
                }
            }
            
            // Save/Load System
            saveGame() {
                try {
                    const saveData = {
                        depth: this.currentDepth,
                        gold: this.gold,
                        stats: this.stats,
                        achievements: Array.from(this.achievements),
                        equipment: this.equipment,
                        inventory: this.inventory,
                        identifiedItems: Array.from(this.identifiedItems),
                        playerLevel: this.player ? this.player.getComponent('level').level : 1,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('bobTurtleRoguelike_save', JSON.stringify(saveData));
                    // Game saved successfully
                    return true;
                } catch (error) {
                    console.error('Failed to save game:', error);
                    return false;
                }
            }
            
            loadGame() {
                try {
                    const saveData = localStorage.getItem('bobTurtleRoguelike_save');
                    if (!saveData) return false;
                    
                    const data = JSON.parse(saveData);
                    this.currentDepth = data.depth || 1;
                    this.gold = data.gold || 0;
                    this.stats = { ...this.stats, ...data.stats };
                    this.achievements = new Set(data.achievements || []);
                    this.equipment = { ...this.equipment, ...data.equipment };
                    this.inventory = data.inventory || [];
                    this.identifiedItems = new Set(data.identifiedItems || []);
                    
                    // Game loaded successfully
                    return true;
                } catch (error) {
                    console.error('Failed to load game:', error);
                    return false;
                }
            }
            
            // Achievement System
            loadAchievements() {
                try {
                    const saved = localStorage.getItem('bobTurtleRoguelike_achievements');
                    if (saved) {
                        this.achievements = new Set(JSON.parse(saved));
                    }
                } catch (error) {
                    console.error('Failed to load achievements:', error);
                }
            }
            
            saveAchievements() {
                try {
                    localStorage.setItem('bobTurtleRoguelike_achievements', JSON.stringify(Array.from(this.achievements)));
                } catch (error) {
                    console.error('Failed to save achievements:', error);
                }
            }
            
            unlockAchievement(id, name, description) {
                if (!this.achievements.has(id)) {
                    this.achievements.add(id);
                    this.saveAchievements();
                    return { id, name, description, unlocked: true };
                }
                return null;
            }
            
            // High Score System
            loadHighScores() {
                try {
                    const saved = localStorage.getItem('bobTurtleRoguelike_highscores');
                    this.highScores = saved ? JSON.parse(saved) : [];
                } catch (error) {
                    console.error('Failed to load high scores:', error);
                    this.highScores = [];
                }
            }
            
            saveHighScore(score, depth, level) {
                try {
                    const entry = {
                        score,
                        depth,
                        level,
                        date: new Date().toLocaleDateString(),
                        time: Math.floor((Date.now() - this.gameStartTime) / 1000)
                    };
                    
                    this.highScores.push(entry);
                    this.highScores.sort((a, b) => b.score - a.score);
                    this.highScores = this.highScores.slice(0, 10); // Keep top 10
                    
                    localStorage.setItem('bobTurtleRoguelike_highscores', JSON.stringify(this.highScores));
                    return this.highScores.indexOf(entry) + 1; // Return rank
                } catch (error) {
                    console.error('Failed to save high score:', error);
                    return -1;
                }
            }
        }
        
        // Entity component system with all components
        class Entity {
            constructor(x, y, type, sprite = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.sprite = sprite;
                this.components = {};
            }
            
            addComponent(name, component) {
                this.components[name] = component;
                return this;
            }
            
            getComponent(name) {
                return this.components[name];
            }
            
            hasComponent(name) {
                return name in this.components;
            }
        }
        
        // All required components
        class HealthComponent {
            constructor(maxHealth, currentHealth = null) {
                this.maxHealth = maxHealth;
                this.currentHealth = currentHealth || maxHealth;
            }
        }
        
        class ManaComponent {
            constructor(maxMana, currentMana = null) {
                this.maxMana = maxMana;
                this.currentMana = currentMana || maxMana;
            }
        }
        
        class OxygenComponent {
            constructor(maxOxygen = 100, currentOxygen = null) {
                this.maxOxygen = maxOxygen;
                this.currentOxygen = currentOxygen || maxOxygen;
                this.drowning = false;
            }
        }
        
        class CombatComponent {
            constructor(attackPower, defense) {
                this.attackPower = attackPower;
                this.defense = defense;
            }
        }
        
        class LevelComponent {
            constructor(level = 1, experience = 0) {
                this.level = level;
                this.experience = experience;
                this.experienceToNext = this.calculateExpToNext();
            }
            
            calculateExpToNext() {
                return Math.floor(100 * Math.pow(1.2, this.level - 1));
            }
        }
        
        class TurtleAbilitiesComponent {
            constructor() {
                this.shellRetreatCooldown = 0;
                this.swimBoostCooldown = 0;
                this.inShell = false;
                this.swimBoosted = false;
            }
        }
        
        class AIComponent {
            constructor(type = 'hostile') {
                this.type = type;
                this.target = null;
                this.lastKnownPlayerPos = null;
                this.confused = 0;
            }
        }
        
        // Complete room-based dungeon generator
        class RoomBasedGenerator {
            static generateMap(width, height, depth) {
                // Generating map for current depth
                
                const map = new Array(width);
                for (let i = 0; i < width; i++) {
                    map[i] = new Array(height).fill(TILES.VOID);
                }
                
                const rooms = [];
                // Starting room generation
                
                // Generate rooms
                for (let attempt = 0; attempt < GAME_CONFIG.MAX_ROOMS * 3; attempt++) {
                    const roomWidth = Math.floor(Math.random() * (GAME_CONFIG.ROOM_MAX_SIZE - GAME_CONFIG.ROOM_MIN_SIZE)) + GAME_CONFIG.ROOM_MIN_SIZE;
                    const roomHeight = Math.floor(Math.random() * (GAME_CONFIG.ROOM_MAX_SIZE - GAME_CONFIG.ROOM_MIN_SIZE)) + GAME_CONFIG.ROOM_MIN_SIZE;
                    const roomX = Math.floor(Math.random() * (width - roomWidth - 2)) + 1;
                    const roomY = Math.floor(Math.random() * (height - roomHeight - 2)) + 1;
                    
                    const newRoom = {
                        x: roomX,
                        y: roomY,
                        width: roomWidth,
                        height: roomHeight,
                        centerX: roomX + Math.floor(roomWidth / 2),
                        centerY: roomY + Math.floor(roomHeight / 2)
                    };
                    
                    // Check for overlap
                    let overlaps = false;
                    for (const room of rooms) {
                        if (this.roomsOverlap(newRoom, room)) {
                            overlaps = true;
                            break;
                        }
                    }
                    
                    if (!overlaps && rooms.length < GAME_CONFIG.MAX_ROOMS) {
                        this.carveRoom(map, newRoom);
                        rooms.push(newRoom);
                        
                        // Connect to previous room
                        if (rooms.length > 1) {
                            this.connectRooms(map, rooms[rooms.length - 2], newRoom);
                        }
                    }
                }
                
                // Add walls around floors
                this.addWalls(map, width, height);
                
                // Add water features based on depth
                this.addWaterFeatures(map, rooms, depth);
                
                // Add treasure rooms on deeper levels
                if (depth >= 3) {
                    this.addTreasureRooms(map, rooms);
                }
                
                // Add merchant rooms occasionally
                if (depth >= 2 && Math.random() < 0.3) {
                    this.addMerchantRoom(map, rooms);
                }
                
                // Generated rooms for current depth
                return { map, rooms };
            }
            
            static roomsOverlap(room1, room2) {
                return !(room1.x + room1.width + 1 < room2.x || 
                        room2.x + room2.width + 1 < room1.x || 
                        room1.y + room1.height + 1 < room2.y || 
                        room2.y + room2.height + 1 < room1.y);
            }
            
            static carveRoom(map, room) {
                for (let x = room.x; x < room.x + room.width; x++) {
                    for (let y = room.y; y < room.y + room.height; y++) {
                        map[x][y] = TILES.FLOOR;
                    }
                }
            }
            
            static connectRooms(map, room1, room2) {
                let x = room1.centerX;
                let y = room1.centerY;
                
                // Carve L-shaped corridor
                while (x !== room2.centerX) {
                    map[x][y] = TILES.FLOOR;
                    x += x < room2.centerX ? 1 : -1;
                }
                
                while (y !== room2.centerY) {
                    map[x][y] = TILES.FLOOR;
                    y += y < room2.centerY ? 1 : -1;
                }
            }
            
            static addWalls(map, width, height) {
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        if (map[x][y] === TILES.VOID) {
                            // Check if adjacent to floor
                            let adjacentToFloor = false;
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        if (map[nx][ny] === TILES.FLOOR) {
                                            adjacentToFloor = true;
                                            break;
                                        }
                                    }
                                }
                                if (adjacentToFloor) break;
                            }
                            
                            if (adjacentToFloor) {
                                map[x][y] = TILES.WALL;
                            }
                        }
                    }
                }
            }
            
            static addWaterFeatures(map, rooms, depth) {
                // Most rooms are flooded - this is an underwater dungeon!
                const floodedRooms = Math.floor(rooms.length * 0.7); // 70% of rooms flooded
                const airPocketRooms = Math.min(2, Math.floor(rooms.length * 0.3)); // 30% have air pockets
                
                // Flood most rooms
                for (let i = 0; i < floodedRooms; i++) {
                    const room = rooms[i];
                    
                    // Flood entire room with varying depths
                    for (let x = room.x; x < room.x + room.width; x++) {
                        for (let y = room.y; y < room.y + room.height; y++) {
                            if (map[x][y] === TILES.FLOOR) {
                                // Random mix of water depths
                                map[x][y] = Math.random() < 0.3 ? TILES.DEEP_WATER : TILES.WATER;
                            }
                        }
                    }
                }
                
                // Add air pockets in some rooms (safe zones)
                for (let i = floodedRooms; i < floodedRooms + airPocketRooms; i++) {
                    const room = rooms[i] || rooms[Math.floor(Math.random() * rooms.length)];
                    
                    // Add air pocket in center of room
                    const centerX = room.centerX;
                    const centerY = room.centerY;
                    
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= room.x && x < room.x + room.width && 
                                y >= room.y && y < room.y + room.height) {
                                if (map[x][y] === TILES.FLOOR) {
                                    map[x][y] = TILES.AIR_POCKET;
                                }
                            }
                        }
                    }
                }
            }
            
            static addTreasureRooms(map, rooms) {
                if (rooms.length < 3) return;
                
                // Don't use the first room (where player spawns) for treasure
                const eligibleRooms = rooms.slice(1);
                if (eligibleRooms.length === 0) return;
                
                const treasureRoom = eligibleRooms[Math.floor(Math.random() * eligibleRooms.length)];
                
                // Make it a special treasure room
                for (let x = treasureRoom.x; x < treasureRoom.x + treasureRoom.width; x++) {
                    for (let y = treasureRoom.y; y < treasureRoom.y + treasureRoom.height; y++) {
                        if (map[x][y] === TILES.FLOOR) {
                            map[x][y] = TILES.TREASURE_FLOOR;
                        }
                    }
                }
                
                // Mark the room as a treasure room for later reference
                treasureRoom.isTreasureRoom = true;
            }
            
            static addMerchantRoom(map, rooms) {
                if (rooms.length < 2) return;
                
                // Don't use the first room (where player spawns) or treasure rooms
                const eligibleRooms = rooms.slice(1).filter(room => !room.isTreasureRoom);
                if (eligibleRooms.length === 0) return;
                
                const merchantRoom = eligibleRooms[Math.floor(Math.random() * eligibleRooms.length)];
                
                // Mark the room as a merchant room for later reference
                merchantRoom.isMerchantRoom = true;
                
                // Place merchant in center of room
                const centerX = Math.floor(merchantRoom.x + merchantRoom.width / 2);
                const centerY = Math.floor(merchantRoom.y + merchantRoom.height / 2);
                merchantRoom.merchantX = centerX;
                merchantRoom.merchantY = centerY;
            }
            
            static placeStairs(map, rooms) {
                if (rooms.length === 0) return null;
                
                const stairRoom = rooms[rooms.length - 1]; // Last room
                const stairX = stairRoom.centerX;
                const stairY = stairRoom.centerY;
                
                map[stairX][stairY] = TILES.STAIRS_DOWN;
                return { x: stairX, y: stairY };
            }
        }
        
        // Main game scene with all systems implemented
        class CompleteRoguelikeScene extends Phaser.Scene {
            constructor() {
                super({ key: 'CompleteRoguelikeScene' });
                this.gameState = new GameState();
                this.cameraOffsetX = 0;
                this.cameraOffsetY = 0;
                this.tileSprites = [];
                this.entitySprites = [];
                this.playerTurn = true;
                this.gameOverShown = false;
            }
            
            preload() {
                // Loading complete roguelike assets
                
                // Load background music from the 28 MP3 files
                this.loadBackgroundMusic();
                
                // Create all tile textures
                this.createAllTileTextures();
                
                // Create item textures
                this.createItemTextures();
                
                // Professional PixelLab entities loaded above - no placeholders needed!
                
                // Load Professional PixelLab Characters
                
                // Red-Eared Slider Turtle Hero (8-directional) - REAL TURTLE SPECIES!
                // Using PixelLab URLs for now (sprites are downloaded locally as backup)
                this.load.image('bob_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/south.png');
                this.load.image('bob_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/north.png');
                this.load.image('bob_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/east.png');
                this.load.image('bob_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/west.png');
                this.load.image('bob_south_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/south-east.png');
                this.load.image('bob_north_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/north-east.png');
                this.load.image('bob_south_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/south-west.png');
                this.load.image('bob_north_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/eab5d9c7-0ba0-4517-974a-cd5035819b11/rotations/north-west.png');
                
                // Sea Monster Enemy
                this.load.image('seamonster_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/fc398414-8bb5-4bc8-b4ee-dbc1ea1cecc9/rotations/south.png');
                this.load.image('seamonster_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/fc398414-8bb5-4bc8-b4ee-dbc1ea1cecc9/rotations/north.png');
                this.load.image('seamonster_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/fc398414-8bb5-4bc8-b4ee-dbc1ea1cecc9/rotations/east.png');
                this.load.image('seamonster_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/fc398414-8bb5-4bc8-b4ee-dbc1ea1cecc9/rotations/west.png');
                
                // Dungeon Crab
                this.load.image('crab_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/48933e0a-2bfd-488f-a6c0-525e1b69bce3/rotations/south.png');
                this.load.image('crab_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/48933e0a-2bfd-488f-a6c0-525e1b69bce3/rotations/north.png');
                this.load.image('crab_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/48933e0a-2bfd-488f-a6c0-525e1b69bce3/rotations/east.png');
                this.load.image('crab_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/48933e0a-2bfd-488f-a6c0-525e1b69bce3/rotations/west.png');
                
                // Angry Fish
                this.load.image('fish_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/1d48c1b9-55ff-413c-8a95-c3dd0c22f338/rotations/south.png');
                this.load.image('fish_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/1d48c1b9-55ff-413c-8a95-c3dd0c22f338/rotations/north.png');
                this.load.image('fish_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/1d48c1b9-55ff-413c-8a95-c3dd0c22f338/rotations/east.png');
                this.load.image('fish_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/1d48c1b9-55ff-413c-8a95-c3dd0c22f338/rotations/west.png');
                
                // Shadow Octopus
                this.load.image('octopus_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/e95c80c9-e0d0-486a-8247-9f9782e5f05f/rotations/south.png');
                this.load.image('octopus_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/e95c80c9-e0d0-486a-8247-9f9782e5f05f/rotations/north.png');
                this.load.image('octopus_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/e95c80c9-e0d0-486a-8247-9f9782e5f05f/rotations/east.png');
                this.load.image('octopus_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/e95c80c9-e0d0-486a-8247-9f9782e5f05f/rotations/west.png');
                
                // Professional Item Sprites (NO MORE GARBO!)
                // Load Uncle Matt NPC sprites
                this.load.image('uncle_matt_south', 'https://api.pixellab.ai/mcp/characters/bfea3c3d-2c3d-435d-b13e-712dc974f14d/rotations/south.png');
                this.load.image('uncle_matt_north', 'https://api.pixellab.ai/mcp/characters/bfea3c3d-2c3d-435d-b13e-712dc974f14d/rotations/north.png');
                this.load.image('uncle_matt_east', 'https://api.pixellab.ai/mcp/characters/bfea3c3d-2c3d-435d-b13e-712dc974f14d/rotations/east.png');
                this.load.image('uncle_matt_west', 'https://api.pixellab.ai/mcp/characters/bfea3c3d-2c3d-435d-b13e-712dc974f14d/rotations/west.png');
                
                this.load.image('treasure_chest_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/41358bd6-d42a-4090-8d0f-8215f7643869/rotations/south.png');
                this.load.image('iron_sword_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/3d72adaf-d5f7-4acf-889c-12d1cec6e26b/rotations/south.png');
                this.load.image('iron_ring_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/948896f6-8b79-4039-8fd1-df919a2d2fd9/rotations/south.png');
                this.load.image('rusty_sword_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/70c08b87-6547-41b8-99e1-2854e781b87c/rotations/south.png');
                this.load.image('pearl_necklace_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/0a646d5b-f069-4fae-8bcd-6f64b3226136/rotations/south.png');
                
                // Fallback treasure chest from URL if local fails
                this.load.on('filecomplete-image-treasure_chest_south', () => {
                    // Treasure chest loaded successfully
                }, this);
                
                this.load.on('loaderror', (file) => {
                    if (file.key === 'treasure_chest_south') {
                        // Load from PixelLab URL as fallback
                        this.load.image('treasure_chest_fallback', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/41358bd6-d42a-4090-8d0f-8215f7643869/rotations/south.png');
                    }
                }, this);
                
                // Cave Shark (Boss Enemy)
                this.load.image('shark_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/a7a05e48-4005-418d-a005-8852f3b4d426/rotations/south.png');
                this.load.image('shark_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/a7a05e48-4005-418d-a005-8852f3b4d426/rotations/north.png');
                this.load.image('shark_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/a7a05e48-4005-418d-a005-8852f3b4d426/rotations/east.png');
                this.load.image('shark_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/a7a05e48-4005-418d-a005-8852f3b4d426/rotations/west.png');
                
                // Deep Kraken Boss (Ultimate Boss)
                this.load.image('kraken_south', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/4c251bd2-e6cf-4e51-898d-05b3d8eaee79/rotations/south.png');
                this.load.image('kraken_north', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/4c251bd2-e6cf-4e51-898d-05b3d8eaee79/rotations/north.png');
                this.load.image('kraken_east', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/4c251bd2-e6cf-4e51-898d-05b3d8eaee79/rotations/east.png');
                this.load.image('kraken_west', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/4c251bd2-e6cf-4e51-898d-05b3d8eaee79/rotations/west.png');
                
                // Health Potion
                this.load.image('health_potion', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/4cfe7219-5f46-48ca-9240-ff2dee50a05b/rotations/south.png');
                
                // Mana Potion
                this.load.image('mana_potion', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/025e2b8a-ea4b-4ba7-ad47-9182958c044b/rotations/south.png');
                
                // Treasure Chest
                this.load.image('treasure_chest', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/176559bb-2fa3-4a77-8523-8c790fac28d3/rotations/south.png');
                
                // Magic Effect
                this.load.image('magic_effect', 'https://supabase.pixellab.ai/storage/v1/object/public/pixellab-characters/ca0719e3-402a-4aec-aa72-0f6c4de2a02b/9cf52c91-3cc4-4cc1-b341-90fe770277df/rotations/south.png');
                
                // Professional underwater tiles
                this.load.image('pixellab_floor', 'https://api.pixellab.ai/mcp/isometric-tile/f6fa9889-83ea-4d70-8fe3-24a4b93aee5c/download');
                this.load.image('pixellab_wall', 'https://api.pixellab.ai/mcp/isometric-tile/137251f6-17aa-46fb-92a7-c25f7a7f53c4/download');
                
                // Load music
                for (let i = 1; i <= 28; i++) {
                    this.load.audio(`music_${i}`, `assets/music/${i}.mp3`);
                }
                
                // Create simple procedural sound effects
                this.createSimpleSounds();
                
                this.load.on('loaderror', (file) => {
                    console.warn(`Failed to load: ${file.key}`);
                });
            }
            
            createAllTileTextures() {
                const graphics = this.add.graphics();
                const size = GAME_CONFIG.TILE_SIZE;
                
                // Void (deep ocean black)
                graphics.fillStyle(0x000000);
                graphics.fillRect(0, 0, size, size);
                graphics.generateTexture('tile_void', size, size);
                
                // Floor (sandy underwater floor with details)
                graphics.clear();
                graphics.fillStyle(0xD2B48C);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0xF4E4BC);
                for (let i = 0; i < 12; i++) {
                    graphics.fillCircle(Math.random() * size, Math.random() * size, 3);
                }
                // Add some coral bits
                graphics.fillStyle(0xFF6B6B);
                for (let i = 0; i < 4; i++) {
                    graphics.fillCircle(Math.random() * size, Math.random() * size, 2);
                }
                graphics.generateTexture('tile_floor', size, size);
                
                // Wall (barnacle-covered stone)
                graphics.clear();
                graphics.fillStyle(0x2C3E50);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0x34495E);
                graphics.fillRect(4, 4, size-8, size-8);
                // Add barnacles
                graphics.fillStyle(0x95A5A6);
                for (let i = 0; i < 8; i++) {
                    graphics.fillCircle(Math.random() * size, Math.random() * size, 2);
                }
                graphics.generateTexture('tile_wall', size, size);
                
                // Water (shallow flooded area)
                graphics.clear();
                graphics.fillStyle(0x3498DB);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0x5DADE2);
                graphics.fillCircle(size/2, size/2, size/2.5);
                graphics.fillStyle(0x85C1E9);
                for (let i = 0; i < 6; i++) {
                    graphics.fillCircle(Math.random() * size, Math.random() * size, 4);
                }
                graphics.generateTexture('tile_water', size, size);
                
                // Deep water (dangerous depths)
                graphics.clear();
                graphics.fillStyle(0x1A4C8E);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0x0E2849);
                graphics.fillCircle(size/2, size/2, size/3);
                graphics.generateTexture('tile_deep_water', size, size);
                
                // Air pocket (breathable space)
                graphics.clear();
                graphics.fillStyle(0x85C1E9);  // Light blue background
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0xE8F6F3);  // Air bubble
                graphics.fillCircle(size/2, size/2, size/2.5);
                graphics.fillStyle(0xFFFFFF);  // Highlight
                graphics.fillCircle(size/2 - 4, size/2 - 4, size/6);
                graphics.generateTexture('tile_air_pocket', size, size);
                
                // Stairs (deep descent)
                graphics.clear();
                graphics.fillStyle(0xD2B48C);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0x8B7355);
                graphics.fillRect(8, 8, size-16, size-16);
                graphics.fillStyle(0x5D4E37);
                graphics.fillRect(12, 12, size-24, size-24);
                graphics.generateTexture('tile_stairs', size, size);
                
                // Treasure floor (golden chamber)
                graphics.clear();
                graphics.fillStyle(0xF1C40F);
                graphics.fillRect(0, 0, size, size);
                graphics.fillStyle(0xF39C12);
                for (let i = 0; i < 15; i++) {
                    graphics.fillCircle(Math.random() * size, Math.random() * size, 2);
                }
                graphics.generateTexture('tile_treasure_floor', size, size);
                
                graphics.destroy();
            }
            
            createItemTextures() {
                const graphics = this.add.graphics();
                const size = 24;
                
                // Weapon
                graphics.fillStyle(0xE74C3C);
                graphics.fillRect(8, 4, 8, 16);
                graphics.fillStyle(0x8B4513);
                graphics.fillRect(10, 16, 4, 8);
                graphics.generateTexture('item_weapon', size, size);
                
                // Armor
                graphics.clear();
                graphics.fillStyle(0x95A5A6);
                graphics.fillCircle(12, 12, 8);
                graphics.fillStyle(0x7F8C8D);
                graphics.fillCircle(12, 12, 6);
                graphics.generateTexture('item_armor', size, size);
                
                // Ring
                graphics.clear();
                graphics.fillStyle(0xF1C40F);
                graphics.fillCircle(12, 12, 6);
                graphics.fillStyle(0x000000);
                graphics.fillCircle(12, 12, 3);
                graphics.generateTexture('item_ring', size, size);
                
                // Potion
                graphics.clear();
                graphics.fillStyle(0x8E44AD);
                graphics.fillRoundedRect(6, 4, 12, 16, 2);
                graphics.fillStyle(0xE74C3C);
                graphics.fillRect(8, 6, 8, 8);
                graphics.generateTexture('item_potion', size, size);
                
                // Scroll
                graphics.clear();
                graphics.fillStyle(0xF7DC6F);
                graphics.fillRect(4, 6, 16, 12);
                graphics.fillStyle(0x34495E);
                for (let i = 0; i < 3; i++) {
                    graphics.fillRect(6, 8 + i * 3, 12, 1);
                }
                graphics.generateTexture('item_scroll', size, size);
                
                // Gold
                graphics.clear();
                graphics.fillStyle(0xF1C40F);
                graphics.fillCircle(12, 12, 4);
                graphics.generateTexture('item_gold', size, size);
                
                graphics.destroy();
            }
            
            // Entity textures now loaded from Professional PixelLab assets
            // No fallback creation needed - we have professional sprites for everything!
            
            loadBackgroundMusic() {
                // Load all 28 background music tracks
                const musicTracks = [
                    { key: 'music1', path: 'public/assets/music/1.mp3' },
                    { key: 'music2', path: 'public/assets/music/2.mp3' },
                    { key: 'music3', path: 'public/assets/music/3.mp3' },
                    { key: 'music4', path: 'public/assets/music/4.mp3' },
                    { key: 'music5', path: 'public/assets/music/5.mp3' },
                    { key: 'music6', path: 'public/assets/music/6.mp3' },
                    { key: 'music7', path: 'public/assets/music/7.mp3' },
                    { key: 'music8', path: 'public/assets/music/8.mp3' },
                    { key: 'music9', path: 'public/assets/music/9.mp3' },
                    { key: 'music10', path: 'public/assets/music/10.mp3' },
                    { key: 'music11', path: 'public/assets/music/11.mp3' },
                    { key: 'music12', path: 'public/assets/music/12.mp3' },
                    { key: 'music13', path: 'public/assets/music/13.mp3' },
                    { key: 'music14', path: 'public/assets/music/14.mp3' },
                    { key: 'music15', path: 'public/assets/music/15.mp3' },
                    { key: 'music16', path: 'public/assets/music/16.mp3' },
                    { key: 'music17', path: 'public/assets/music/17.mp3' },
                    { key: 'music18', path: 'public/assets/music/18.mp3' },
                    { key: 'music19', path: 'public/assets/music/19.mp3' },
                    { key: 'music20', path: 'public/assets/music/20.mp3' },
                    { key: 'music21', path: 'public/assets/music/21.mp3' },
                    { key: 'music22', path: 'public/assets/music/22.mp3' },
                    { key: 'music23', path: 'public/assets/music/23.mp3' },
                    { key: 'music24', path: 'public/assets/music/24.mp3' },
                    { key: 'music25', path: 'public/assets/music/25.mp3' },
                    { key: 'music26', path: 'public/assets/music/26.mp3' },
                    { key: 'music27', path: 'public/assets/music/27.mp3' },
                    { key: 'music28', path: 'public/assets/music/28.mp3' }
                ];
                
                // Load each music track
                musicTracks.forEach(track => {
                    this.load.audio(track.key, track.path);
                });
                
                // Loading background music tracks
            }
            
            startBackgroundMusic() {
                try {
                    // Pick a random music track from the 28 available
                    const randomTrack = Math.floor(Math.random() * 28) + 1;
                    const musicKey = `music${randomTrack}`;
                    
                    // Create the background music instance
                    this.backgroundMusic = this.sound.add(musicKey, {
                        loop: true,
                        volume: 0.3 // Start at moderate volume
                    });
                    
                    // Play the music
                    this.backgroundMusic.play();
                    
                    // Set up music track switching every 3-5 minutes
                    this.musicTimer = this.time.addEvent({
                        delay: Phaser.Math.Between(180000, 300000), // 3-5 minutes
                        callback: this.switchBackgroundMusic,
                        callbackScope: this,
                        loop: true
                    });
                    
                    // Playing background music
                } catch (e) {
                    // Could not start background music
                }
            }
            
            switchBackgroundMusic() {
                try {
                    // Stop current music
                    if (this.backgroundMusic) {
                        this.backgroundMusic.stop();
                    }
                    
                    // Pick a new random track
                    const randomTrack = Math.floor(Math.random() * 28) + 1;
                    const musicKey = `music${randomTrack}`;
                    
                    // Start new track
                    this.backgroundMusic = this.sound.add(musicKey, {
                        loop: true,
                        volume: 0.3
                    });
                    
                    this.backgroundMusic.play();
                    // Switched background music track
                } catch (e) {
                    // Could not switch background music
                }
            }
            
            toggleMusic() {
                this.musicEnabled = !this.musicEnabled;
                const btn = document.getElementById('music-toggle-btn');
                
                if (this.musicEnabled) {
                    if (this.backgroundMusic && !this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.play();
                    }
                    btn.textContent = '🎵 Music: ON';
                } else {
                    if (this.backgroundMusic) {
                        this.backgroundMusic.pause();
                    }
                    btn.textContent = '🎵 Music: OFF';
                }
            }
            
            adjustVolume(delta) {
                this.musicVolume = Math.max(0, Math.min(1, this.musicVolume + delta));
                
                if (this.backgroundMusic) {
                    this.backgroundMusic.setVolume(this.musicVolume);
                }
                
                // Visual feedback
                const percentage = Math.round(this.musicVolume * 100);
                const btn = document.getElementById('music-toggle-btn');
                if (btn) {
                    const status = this.musicEnabled ? 'ON' : 'OFF';
                    btn.textContent = `🎵 Music: ${status} (${percentage}%)`;
                }
            }
            
            setupPauseSystem() {
                // Setup ESC key listener for pause toggle
                this.input.keyboard.on('keydown-ESC', () => {
                    this.togglePause();
                });
                
                // Setup pause menu event handlers
                const resumeBtn = document.getElementById('resume-btn');
                if (resumeBtn) {
                    resumeBtn.addEventListener('click', () => {
                        this.togglePause();
                    });
                }
                
                const restartBtn = document.getElementById('restart-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        this.restartLevel();
                    });
                }
                
                const mainMenuBtn = document.getElementById('main-menu-btn');
                if (mainMenuBtn) {
                    mainMenuBtn.addEventListener('click', () => {
                        this.goToMainMenu();
                    });
                }
                
                // Setup volume sliders
                const musicSlider = document.getElementById('music-volume-slider');
                if (musicSlider) {
                    musicSlider.addEventListener('input', (e) => {
                        this.setMusicVolume(e.target.value / 100);
                        document.getElementById('music-volume-text').textContent = e.target.value + '%';
                    });
                }
                
                const sfxSlider = document.getElementById('sfx-volume-slider');
                if (sfxSlider) {
                    sfxSlider.addEventListener('input', (e) => {
                        this.setSfxVolume(e.target.value / 100);
                        document.getElementById('sfx-volume-text').textContent = e.target.value + '%';
                    });
                }
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseOverlay = document.getElementById('pause-overlay');
                
                if (this.isPaused) {
                    // Pause the game
                    this.scene.pause();
                    if (pauseOverlay) pauseOverlay.style.display = 'block';
                    
                    // Pause background music
                    if (this.backgroundMusic && this.backgroundMusic.isPlaying) {
                        this.backgroundMusic.pause();
                    }
                } else {
                    // Resume the game
                    this.scene.resume();
                    if (pauseOverlay) pauseOverlay.style.display = 'none';
                    
                    // Resume background music
                    if (this.backgroundMusic && this.musicEnabled) {
                        this.backgroundMusic.resume();
                    }
                }
            }
            
            restartLevel() {
                // Hide pause menu
                const pauseOverlay = document.getElementById('pause-overlay');
                if (pauseOverlay) pauseOverlay.style.display = 'none';
                
                // Reset game state
                this.isPaused = false;
                this.scene.resume();
                
                // Regenerate level
                this.gameState = new GameState();
                this.generateLevel();
                this.updateUI();
                
                // Restart music
                this.startBackgroundMusic();
                
                this.gameState.addMessage('🔄 Level restarted! Good luck, Bob!', '#e74c3c');
            }
            
            goToMainMenu() {
                // Hide pause menu
                const pauseOverlay = document.getElementById('pause-overlay');
                if (pauseOverlay) pauseOverlay.style.display = 'none';
                
                // Stop game and return to main menu
                this.isPaused = false;
                this.scene.resume();
                
                // Destroy the current game and show main menu
                if (window.game) {
                    window.game.destroy(true);
                    window.game = null;
                }
                
                // Show main menu
                if (window.mainMenu) {
                    window.mainMenu.showMainMenu();
                }
            }
            
            setMusicVolume(volume) {
                this.musicVolume = Math.max(0, Math.min(1, volume));
                if (this.backgroundMusic) {
                    this.backgroundMusic.setVolume(this.musicVolume);
                }
            }
            
            setSfxVolume(volume) {
                this.sfxVolume = Math.max(0, Math.min(1, volume));
                // Update all procedural sounds volume
                // Update all procedural sound effects volume
                if (this.simpleSounds) {
                    Object.keys(this.simpleSounds).forEach(soundKey => {
                        const sound = this.simpleSounds[soundKey];
                        if (sound && sound.setVolume) {
                            sound.setVolume(this.sfxVolume);
                        }
                    });
                }
            }
            
            // Load audio settings on game start
            loadAudioSettings() {
                const musicVolume = localStorage.getItem('bobTurtle_musicVolume') || '30';
                const sfxVolume = localStorage.getItem('bobTurtle_sfxVolume') || '70';
                const musicMuted = localStorage.getItem('bobTurtle_musicMuted') === 'true';
                const sfxMuted = localStorage.getItem('bobTurtle_sfxMuted') === 'true';
                
                const effectiveMusicVolume = musicMuted ? 0 : (musicVolume / 100);
                const effectiveSfxVolume = sfxMuted ? 0 : (sfxVolume / 100);
                
                this.setMusicVolume(effectiveMusicVolume);
                this.setSfxVolume(effectiveSfxVolume);
            }
            
            setupTutorialSystem() {
                // Check if this is a new player (no previous save or first time flag)
                const hasShownTutorial = localStorage.getItem('bobTurtle_tutorialShown');
                const hasExistingSave = localStorage.getItem('bobTurtleRoguelike_save');
                
                if (!hasShownTutorial && !hasExistingSave) {
                    // Show tutorial for new players
                    this.time.delayedCall(2000, () => {
                        this.startTutorial();
                    });
                }
                
                // Setup tutorial navigation
                const prevBtn = document.getElementById('tutorial-prev');
                const nextBtn = document.getElementById('tutorial-next');
                const skipBtn = document.getElementById('tutorial-skip');
                
                if (prevBtn) prevBtn.addEventListener('click', () => this.previousTutorialStep());
                if (nextBtn) nextBtn.addEventListener('click', () => this.nextTutorialStep());
                if (skipBtn) skipBtn.addEventListener('click', () => this.skipTutorial());
            }
            
            startTutorial() {
                this.tutorialStep = 0;
                this.tutorialSteps = [
                    {
                        title: "🐢 Meet Bob the Red-Eared Slider!",
                        text: `Welcome to the underwater ruins! You are Bob, a brave turtle exploring dangerous depths.<br/><br/>
                               <strong>🎯 Your Goal:</strong> Descend as deep as possible, collect treasures, and survive!<br/>
                               <strong>💀 Warning:</strong> This is a roguelike - death is permanent!`
                    },
                    {
                        title: "🎮 Movement & Basic Controls",
                        text: `<strong>Movement:</strong><br/>
                               • Use <span style="color: #3498db;">Arrow Keys</span> or <span style="color: #3498db;">WASD</span> to move<br/>
                               • Or <span style="color: #3498db;">Click</span> where you want to move<br/><br/>
                               <strong>Essential Keys:</strong><br/>
                               • <span style="color: #e74c3c;">ESC</span> - Pause Menu<br/>
                               • <span style="color: #f39c12;">I</span> - Open Inventory<br/>
                               • <span style="color: #2ecc71;">R</span> - Identify Items`
                    },
                    {
                        title: "🐢 Turtle Special Abilities",
                        text: `As a Red-Eared Slider, you have unique abilities:<br/><br/>
                               <strong>🛡️ Shell Retreat:</strong> Press <span style="color: #e67e22;">Q</span> to hide in your shell for defense<br/>
                               <strong>🏊 Swim Boost:</strong> Press <span style="color: #3498db;">W</span> to swim faster underwater<br/>
                               <strong>💨 Oxygen System:</strong> You need air! Find air pockets or surface regularly`
                    },
                    {
                        title: "⚔️ Combat & Items",
                        text: `<strong>Combat:</strong><br/>
                               • Walk into enemies to attack them<br/>
                               • Use weapons and armor to get stronger<br/>
                               • Watch your health - green bar in top-left<br/><br/>
                               <strong>Items:</strong><br/>
                               • Walk over items to automatically pick them up<br/>
                               • Hover over inventory items to see detailed tooltips<br/>
                               • Rare magical items need Scholar NPCs to identify for gold!`
                    },
                    {
                        title: "🏆 Pro Tips for Success",
                        text: `<strong>Strategy Tips:</strong><br/>
                               • Explore thoroughly - check every room for loot<br/>
                               • Manage your oxygen carefully underwater<br/>
                               • Level up by defeating enemies<br/>
                               • Equipment auto-upgrades if it's better<br/>
                               • Save often - your progress is automatically saved!<br/><br/>
                               <strong>Good luck, brave turtle! 🐢✨</strong>`
                    }
                ];
                
                this.showTutorialStep();
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) overlay.style.display = 'block';
                
                // Pause the game during tutorial
                this.scene.pause();
            }
            
            showTutorialStep() {
                const step = this.tutorialSteps[this.tutorialStep];
                if (!step) return;
                
                const titleEl = document.getElementById('tutorial-title');
                const textEl = document.getElementById('tutorial-text');
                const stepEl = document.getElementById('tutorial-step');
                const totalEl = document.getElementById('tutorial-total');
                const prevBtn = document.getElementById('tutorial-prev');
                const nextBtn = document.getElementById('tutorial-next');
                
                if (titleEl) titleEl.innerHTML = step.title;
                if (textEl) textEl.innerHTML = step.text;
                if (stepEl) stepEl.textContent = this.tutorialStep + 1;
                if (totalEl) totalEl.textContent = this.tutorialSteps.length;
                
                // Update button states
                if (prevBtn) prevBtn.disabled = this.tutorialStep === 0;
                if (nextBtn) {
                    if (this.tutorialStep === this.tutorialSteps.length - 1) {
                        nextBtn.textContent = 'Start Playing! 🎮';
                        nextBtn.style.background = '#2ecc71';
                    } else {
                        nextBtn.textContent = 'Next ➡️';
                        nextBtn.style.background = '#3498db';
                    }
                }
            }
            
            nextTutorialStep() {
                if (this.tutorialStep < this.tutorialSteps.length - 1) {
                    this.tutorialStep++;
                    this.showTutorialStep();
                } else {
                    this.completeTutorial();
                }
            }
            
            previousTutorialStep() {
                if (this.tutorialStep > 0) {
                    this.tutorialStep--;
                    this.showTutorialStep();
                }
            }
            
            skipTutorial() {
                this.completeTutorial();
            }
            
            completeTutorial() {
                // Hide tutorial overlay
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) overlay.style.display = 'none';
                
                // Resume the game
                this.scene.resume();
                
                // Mark tutorial as shown
                localStorage.setItem('bobTurtle_tutorialShown', 'true');
                
                // Welcome message
                this.gameState.addMessage('🎓 Tutorial completed! You\'re ready to explore the depths!', '#2ecc71');
                this.gameState.addMessage('💡 Press ESC anytime to access the pause menu for help!', '#3498db');
            }
            
            createSimpleSounds() {
                // Create enhanced spatial audio system using latest Web Audio API
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.simpleSounds = {};
                
                // Set up spatial audio based on Web Audio API docs
                this.setupSpatialAudio();
                
                // Create sword hit sound (short metallic ping)
                this.simpleSounds.sword_hit = () => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
                
                // Create level up sound (ascending tones)
                this.simpleSounds.level_up = () => {
                    const frequencies = [262, 330, 392, 523]; // C, E, G, C
                    frequencies.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime + index * 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.2);
                        
                        oscillator.start(this.audioContext.currentTime + index * 0.1);
                        oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.2);
                    });
                };
                
                // Create achievement sound (fanfare-like)
                this.simpleSounds.achievement_unlock = () => {
                    const frequencies = [523, 659, 784, 1047]; // C, E, G, C (higher octave)
                    frequencies.forEach((freq, index) => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime + index * 0.05);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.05 + 0.3);
                        
                        oscillator.start(this.audioContext.currentTime + index * 0.05);
                        oscillator.stop(this.audioContext.currentTime + index * 0.05 + 0.3);
                    });
                };
                
                                    // Simple procedural sound effects created
            }
            
            setupSpatialAudio() {
                try {
                    // Set up AudioListener for spatial positioning based on Web Audio API docs
                    const listener = this.audioContext.listener;
                    
                    // Use modern parameter setters if available (from Web Audio API docs)
                    if (listener.positionX) {
                        // Modern API with AudioParam objects
                        listener.positionX.setValueAtTime(0, this.audioContext.currentTime);
                        listener.positionY.setValueAtTime(0, this.audioContext.currentTime);
                        listener.positionZ.setValueAtTime(0, this.audioContext.currentTime);
                        
                        listener.forwardX.setValueAtTime(0, this.audioContext.currentTime);
                        listener.forwardY.setValueAtTime(0, this.audioContext.currentTime);
                        listener.forwardZ.setValueAtTime(-1, this.audioContext.currentTime);
                        
                        listener.upX.setValueAtTime(0, this.audioContext.currentTime);
                        listener.upY.setValueAtTime(1, this.audioContext.currentTime);
                        listener.upZ.setValueAtTime(0, this.audioContext.currentTime);
                    } else if (listener.setOrientation) {
                        // Fallback for older API
                        listener.setPosition(0, 0, 0);
                        listener.setOrientation(0, 0, -1, 0, 1, 0);
                    }
                    
                    // Spatial audio system initialized
                } catch (e) {
                    // Spatial audio not available, using regular audio
                }
            }
            
            addCombatFX(target) {
                // Add modern Phaser PostFX based on documentation
                if (target.sprite && target.sprite.postFX && typeof target.sprite.postFX.addGlow === 'function') {
                    try {
                        // Add brief glow effect on hit
                        const glowFX = target.sprite.postFX.addGlow(0xff4444, 4, 0, false, 0.1, 32);
                        
                        // Auto-remove the effect after a short time
                        this.time.delayedCall(200, () => {
                            if (target.sprite && target.sprite.postFX && glowFX) {
                                target.sprite.postFX.remove(glowFX);
                            }
                        });
                    } catch (e) {
                        // PostFX not available, using fallback
                        this.addLegacyTintEffect(target);
                    }
                } else {
                    // Use fallback effect
                    this.addLegacyTintEffect(target);
                }
            }
            
            addLegacyTintEffect(target) {
                // Fallback tint effect for older browsers
                if (target.sprite) {
                    target.sprite.setTint(0xff4444);
                    this.time.delayedCall(100, () => {
                        if (target.sprite) {
                            target.sprite.clearTint();
                        }
                    });
                }
            }
            
            addMagicFX(target, color = 0x44aaff) {
                // Add magical effects for spells and abilities  
                if (target.sprite && target.sprite.postFX && typeof target.sprite.postFX.addGlow === 'function') {
                    try {
                        // Just use glow for compatibility, skip shine if not available
                        const glowFX = target.sprite.postFX.addGlow(color, 2, 0, false, 0.1, 16);
                        
                        this.time.delayedCall(1000, () => {
                            if (target.sprite && target.sprite.postFX && glowFX) {
                                target.sprite.postFX.remove(glowFX);
                            }
                        });
                    } catch (e) {
                        // Magic FX not available, using fallback
                        this.addLegacyTintEffect(target);
                    }
                } else {
                    // Use fallback effect
                    this.addLegacyTintEffect(target);
                }
            }
            
            updateListenerPosition() {
                // Update audio listener position based on player position
                if (this.audioContext && this.gameState.player) {
                    try {
                        const listener = this.audioContext.listener;
                        const playerX = this.gameState.player.x * GAME_CONFIG.TILE_SIZE;
                        const playerY = this.gameState.player.y * GAME_CONFIG.TILE_SIZE;
                        
                        if (listener.positionX) {
                            // Modern API
                            listener.positionX.setValueAtTime(playerX, this.audioContext.currentTime);
                            listener.positionY.setValueAtTime(playerY, this.audioContext.currentTime);
                        } else if (listener.setPosition) {
                            // Legacy API
                            listener.setPosition(playerX, playerY, 0);
                        }
                    } catch (e) {
                        // Silently handle if spatial audio not supported
                    }
                }
            }
            
            playSimpleSound(soundName) {
                try {
                    if (this.simpleSounds && this.simpleSounds[soundName]) {
                        this.simpleSounds[soundName]();
                    }
                } catch (e) {
                    // Could not play sound
                }
            }
            
            create() {
                // Creating complete roguelike game
                
                try {
                    // Generate first level
                    this.generateLevel();
                    
                    // Set up input
                    this.setupInput();
                    
                    // Load audio settings (includes mute state)
                    this.loadAudioSettings();
                    
                    // Start music
                    this.startMusic();
                    
                    // Initial UI update
                    this.updateUI();
                    
                                    this.gameState.addMessage('🐢 Bob the Red-Eared Slider awakens in the flooded ruins!', '#3498db');
                this.gameState.addMessage('🌊 As a semi-aquatic turtle, you can swim well but still need air!', '#1abc9c');
                this.gameState.addMessage('🫧 Find air pockets to breathe and stairs to descend deeper!', '#f39c12');
                this.gameState.addMessage('📦 Press I for inventory, E for equipment! Find NPCs to identify rare items!', '#9b59b6');
                
                // Try to load existing save
                this.loadExistingSave();
                
                // Start background music
                this.startBackgroundMusic();
                
                // Setup pause system
                this.setupPauseSystem();
                
                // Setup tutorial system for new players
                this.setupTutorialSystem();
                
                // Setup UI button handlers
                this.setupUIButtons();
                
                // Initialize minimap
                this.initializeMinimap();
                
                // Force multiple minimap updates to ensure it shows up
                this.updateMinimap();
                
                // Additional delayed update to ensure it renders properly
                this.time.delayedCall(100, () => {
                    this.updateMinimap();
                });
                
                // Add FPS monitoring display (disabled for cleaner UI)
                // this.setupPerformanceMonitoring();
                    
                    // Game scene created successfully
                } catch (error) {
                    console.error('❌ Error creating game scene:', error);
                    
                    // Create a simple fallback
                    const errorText = this.add.text(400, 300, 'Game Loading...', {
                        fontSize: '32px',
                        color: '#ffffff',
                        fontFamily: 'Arial'
                    });
                    errorText.setOrigin(0.5);
                }
            }
            
            generateLevel() {
                // Generate room-based map
                const result = RoomBasedGenerator.generateMap(
                    GAME_CONFIG.MAP_WIDTH, 
                    GAME_CONFIG.MAP_HEIGHT, 
                    this.gameState.currentDepth
                );
                
                this.gameState.gameMap = result.map;
                this.gameState.rooms = result.rooms;
                
                // Place stairs
                const stairsPos = RoomBasedGenerator.placeStairs(
                    this.gameState.gameMap, 
                    this.gameState.rooms
                );
                
                // Find player spawn position (first room)
                const playerPos = this.findPlayerSpawnPosition();
                
                // Create player entity
                this.createPlayer(playerPos.x, playerPos.y);
                
                // Generate special rooms
                this.generateSpecialRooms();
                
                // Generate merchants
                this.generateMerchants();
                
                // Generate treasure chests
                this.generateTreasureChests();
                
                // Spawn enemies
                this.spawnEnemies();
                
                // Spawn items
                this.spawnItems();
                
                // Create visual representation
                this.renderMap();
                
                // Generated level with rooms
            }
            
            findPlayerSpawnPosition() {
                if (this.gameState.rooms.length > 0) {
                    const firstRoom = this.gameState.rooms[0];
                    return { x: firstRoom.centerX, y: firstRoom.centerY };
                }
                
                // Fallback
                for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
                    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
                        if (this.gameState.gameMap[x][y] === TILES.FLOOR) {
                            return {x, y};
                        }
                    }
                }
                
                return {x: 10, y: 10};
            }
            
            createPlayer(x, y) {
                // Use Professional PixelLab Red-Eared Slider Turtle (PRODUCTION QUALITY!)
                let textureKey = 'bob_south';
                if (!this.textures.exists('bob_south')) {
                    // Emergency fallback to any available professional turtle sprite
                    if (this.textures.exists('turtle_south')) textureKey = 'turtle_south';
                    else if (this.textures.exists('player_south')) textureKey = 'player_south';
                    else textureKey = 'item_gold'; // Last resort visible sprite
                }
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(1.4); // Bigger for better visibility
                sprite.setDepth(100);
                
                // Store current direction for sprite updates
                sprite.currentDirection = 'south';
                
                this.gameState.player = new Entity(x, y, ENTITY_TYPES.PLAYER, sprite)
                    .addComponent('health', new HealthComponent(100))
                    .addComponent('mana', new ManaComponent(50))
                    .addComponent('oxygen', new OxygenComponent(100))
                    .addComponent('combat', new CombatComponent(15, 10))
                    .addComponent('level', new LevelComponent())
                    .addComponent('abilities', new TurtleAbilitiesComponent());
                
                this.gameState.entities.push(this.gameState.player);
                
                // Center camera on player
                this.updateCamera();
            }
            
            spawnEnemies() {
                const enemyCount = Math.min(2 + this.gameState.currentDepth, 12);
                
                // Spawn boss on deeper levels
                if (this.gameState.currentDepth >= 5 && Math.random() < 0.4) {
                    this.spawnBossEnemy();
                }
                
                for (let i = 0; i < enemyCount; i++) {
                    const room = this.gameState.rooms[Math.floor(Math.random() * this.gameState.rooms.length)];
                    if (!room) continue;
                    
                    let x, y, attempts = 0;
                    do {
                        x = room.x + Math.floor(Math.random() * room.width);
                        y = room.y + Math.floor(Math.random() * room.height);
                        attempts++;
                    } while ((this.gameState.gameMap[x][y] !== TILES.FLOOR || 
                             this.getEntityAt(x, y) || 
                             Math.abs(x - this.gameState.player.x) + Math.abs(y - this.gameState.player.y) < 8) && 
                             attempts < 50);
                    
                    if (attempts < 50) {
                        // Choose enemy type based on depth progression
                        let enemyTypeKey;
                        
                        if (this.gameState.currentDepth <= 2) {
                            enemyTypeKey = Math.random() < 0.7 ? 'fish' : 'crab';
                        } else if (this.gameState.currentDepth <= 5) {
                            enemyTypeKey = ['fish', 'crab', 'octopus'][Math.floor(Math.random() * 3)];
                        } else if (this.gameState.currentDepth <= 8) {
                            enemyTypeKey = ['crab', 'octopus', 'shark', 'seamonster'][Math.floor(Math.random() * 4)];
                        } else {
                            const enemyTypeKeys = Object.keys(ENEMY_TYPES);
                            enemyTypeKey = enemyTypeKeys[Math.floor(Math.random() * enemyTypeKeys.length)];
                        }
                        
                        this.createEnemy(x, y, enemyTypeKey);
                    }
                }
            }
            
            spawnBossEnemy() {
                // Find largest room for boss
                let bossRoom = this.gameState.rooms[0];
                for (const room of this.gameState.rooms) {
                    if (room.width * room.height > bossRoom.width * bossRoom.height) {
                        bossRoom = room;
                    }
                }
                
                const centerX = bossRoom.centerX;
                const centerY = bossRoom.centerY;
                
                // Clear area around boss
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = centerX + dx;
                        const y = centerY + dy;
                        if (x >= 0 && x < GAME_CONFIG.MAP_WIDTH && y >= 0 && y < GAME_CONFIG.MAP_HEIGHT) {
                            this.gameState.gameMap[x][y] = TILES.FLOOR;
                        }
                    }
                }
                
                // Choose boss type based on depth
                let bossType;
                if (this.gameState.currentDepth >= 10) {
                    bossType = 'kraken'; // Ultimate boss
                } else if (this.gameState.currentDepth >= 7) {
                    bossType = 'shark'; // Mid-level boss
                } else {
                    bossType = 'seamonster'; // Early boss
                }
                
                // Create dramatic boss introduction before spawning
                this.createBossIntroduction(bossType, centerX, centerY);
                
                // Play special sound if available
                this.playSimpleSound('achievement_unlock');
            }
            
            createEnemy(x, y, enemyType) {
                const enemyData = ENEMY_TYPES[enemyType];
                
                // Use ONLY Professional PixelLab sprites (NO FALLBACKS!)
                let textureKey = 'fish_south'; // Default professional sprite
                let scale = 1.0;
                
                switch (enemyType) {
                    case 'fish':
                        textureKey = this.textures.exists('fish_south') ? 'fish_south' : 'item_gold';
                        scale = 1.0;
                        break;
                    case 'crab':
                        textureKey = this.textures.exists('crab_south') ? 'crab_south' : 'fish_south';
                        scale = 1.0;
                        break;
                    case 'octopus':
                        textureKey = this.textures.exists('octopus_south') ? 'octopus_south' : 'fish_south';
                        scale = 1.2;
                        break;
                    case 'shark':
                        textureKey = this.textures.exists('shark_south') ? 'shark_south' : 'fish_south';
                        scale = 1.5;
                        break;
                    case 'seamonster':
                        textureKey = this.textures.exists('seamonster_south') ? 'seamonster_south' : 'fish_south';
                        scale = 1.3;
                        break;
                    case 'kraken':
                        textureKey = this.textures.exists('kraken_south') ? 'kraken_south' : 'fish_south';
                        scale = 2.0; // MASSIVE boss
                        break;
                    default:
                        textureKey = this.textures.exists('fish_south') ? 'fish_south' : 'item_gold';
                        scale = 1.0;
                }
                
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(scale);
                sprite.setDepth(90);
                // Only tint if using fallback textures
                if (!textureKey.includes('_south')) {
                    sprite.setTint(enemyData.color);
                }
                
                // Store current direction for sprite updates
                sprite.currentDirection = 'south';
                
                // Balanced scaling - less harsh difficulty curve
                const levelMultiplier = 1 + (this.gameState.currentDepth - 1) * 0.2;
                
                const enemy = new Entity(x, y, ENTITY_TYPES.ENEMY, sprite)
                    .addComponent('health', new HealthComponent(Math.floor(enemyData.health * levelMultiplier)))
                    .addComponent('combat', new CombatComponent(
                        Math.floor(enemyData.attack * levelMultiplier), 
                        Math.floor(enemyData.defense * levelMultiplier)
                    ))
                    .addComponent('ai', new AIComponent('hostile'));
                
                enemy.enemyType = enemyType;
                enemy.expReward = Math.floor(enemyData.exp * levelMultiplier);
                
                this.gameState.entities.push(enemy);
            }
            
            generateSpecialRooms() {
                if (this.gameState.rooms.length < 3) return;
                
                // 30% chance for a special room on each level
                if (Math.random() < 0.3) {
                    const roomTypes = ['altar', 'shrine', 'library'];
                    const roomType = roomTypes[Math.floor(Math.random() * roomTypes.length)];
                    const room = this.gameState.rooms[Math.floor(Math.random() * this.gameState.rooms.length)];
                    
                    this.createSpecialRoom(room, roomType);
                }
            }
            
            createSpecialRoom(room, type) {
                const centerX = room.centerX;
                const centerY = room.centerY;
                
                switch (type) {
                    case 'altar':
                        // Healing altar - restores health and mana
                        this.gameState.gameMap[centerX][centerY] = TILES.TREASURE_FLOOR;
                        
                        const altarSprite = this.add.circle(
                            centerX * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            centerY * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            12, 0x2ecc71
                        );
                        altarSprite.setDepth(85);
                        
                        // Add altar entity
                        const altar = new Entity(centerX, centerY, 'altar', altarSprite);
                        altar.addComponent('special', {
                            type: 'healing_altar',
                            used: false,
                            effect: () => {
                                if (!altar.getComponent('special').used) {
                                    const health = this.gameState.player.getComponent('health');
                                    const mana = this.gameState.player.getComponent('mana');
                                    health.currentHealth = health.maxHealth;
                                    mana.currentMana = mana.maxMana;
                                    altar.getComponent('special').used = true;
                                    
                                    this.createMagicEffect(centerX, centerY, 'heal');
                                    this.gameState.addMessage('✨ The ancient altar restores your vitality!', '#2ecc71');
                                    
                                    // Change altar appearance
                                    altarSprite.setTint(0x95a5a6);
                                }
                            }
                        });
                        
                        this.gameState.entities.push(altar);
                        this.gameState.addMessage('🏛️ You sense a powerful aura from this room...', '#f39c12');
                        break;
                        
                    case 'shrine':
                        // Experience shrine
                        this.gameState.gameMap[centerX][centerY] = TILES.TREASURE_FLOOR;
                        
                        const shrineSprite = this.add.circle(
                            centerX * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            centerY * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            12, 0x9b59b6
                        );
                        shrineSprite.setDepth(85);
                        
                        const shrine = new Entity(centerX, centerY, 'shrine', shrineSprite);
                        shrine.addComponent('special', {
                            type: 'exp_shrine',
                            used: false,
                            effect: () => {
                                if (!shrine.getComponent('special').used) {
                                    const level = this.gameState.player.getComponent('level');
                                    level.experience += 100;
                                    shrine.getComponent('special').used = true;
                                    
                                    this.createMagicEffect(centerX, centerY, 'mana');
                                    this.gameState.addMessage('⭐ The shrine grants you ancient knowledge! +100 XP', '#9b59b6');
                                    
                                    shrineSprite.setTint(0x95a5a6);
                                    this.checkLevelUp();
                                }
                            }
                        });
                        
                        this.gameState.entities.push(shrine);
                        break;
                }
            }
            
            generateTreasureChests() {
                // 1-2 treasure chests per level
                const chestsPerLevel = Math.random() < 0.7 ? 1 : 2;
                
                for (let i = 0; i < chestsPerLevel; i++) {
                    const room = this.gameState.rooms[Math.floor(Math.random() * this.gameState.rooms.length)];
                    let attempts = 0;
                    let placed = false;
                    
                    while (!placed && attempts < 20) {
                        const x = room.x + Math.floor(Math.random() * room.width);
                        const y = room.y + Math.floor(Math.random() * room.height);
                        
                        if (this.gameState.gameMap[x][y] === TILES.FLOOR && !this.getEntityAt(x, y)) {
                            this.createTreasureChest(x, y);
                            placed = true;
                        }
                        attempts++;
                    }
                }
            }
            
            createTreasureChest(x, y) {
                // Use Professional PixelLab Treasure Chest Sprite with robust fallbacks
                let textureKey = 'item_gold'; // Safe fallback first
                
                // Try multiple texture keys in order of preference
                if (this.textures.exists('treasure_chest_south')) {
                    textureKey = 'treasure_chest_south';
                } else if (this.textures.exists('treasure_chest_fallback')) {
                    textureKey = 'treasure_chest_fallback';
                } else if (this.textures.exists('treasure_chest')) {
                    textureKey = 'treasure_chest';
                } else if (this.textures.exists('item_gold')) {
                    textureKey = 'item_gold';
                } else {
                    // Create a simple chest graphic if nothing else works
                    this.createFallbackChestTexture();
                    textureKey = 'fallback_chest';
                }
                
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(1.2);
                sprite.setDepth(90);
                
                // Generate treasure chest contents
                const loot = this.generateChestLoot();
                
                const chest = new Entity(x, y, 'treasure_chest', sprite);
                chest.addComponent('loot', {
                    items: loot,
                    opened: false,
                    gold: Math.floor(50 + Math.random() * 100 * this.gameState.currentDepth)
                });
                
                this.gameState.chests = this.gameState.chests || [];
                this.gameState.chests.push(chest);
                
                return chest;
            }
            
            generateChestLoot() {
                const loot = [];
                const chestLevel = this.gameState.currentDepth;
                
                // Always has 1-3 items
                const itemCount = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < itemCount; i++) {
                    const roll = Math.random();
                    
                    if (roll < 0.3) {
                        // Health potion
                        loot.push({
                            type: 'consumable',
                            name: 'Health Potion',
                            effect: 'heal',
                            amount: 30 + Math.floor(Math.random() * 20),
                            description: 'Restores health'
                        });
                    } else if (roll < 0.5) {
                        // Mana potion
                        loot.push({
                            type: 'consumable',
                            name: 'Mana Potion',
                            effect: 'mana',
                            amount: 20 + Math.floor(Math.random() * 15),
                            description: 'Restores mana'
                        });
                    } else if (roll < 0.7) {
                        // Equipment
                        loot.push(this.generateRandomEquipment(chestLevel));
                    } else {
                        // Scroll/special item
                        const scrolls = ['Scroll of Healing', 'Scroll of Lightning', 'Scroll of Confusion'];
                        loot.push({
                            type: 'scroll',
                            name: scrolls[Math.floor(Math.random() * scrolls.length)],
                            description: 'Magical scroll with ancient power'
                        });
                    }
                }
                
                return loot;
            }
            
            generateRandomEquipment(level) {
                const equipTypes = ['weapon', 'armor', 'ring'];
                const type = equipTypes[Math.floor(Math.random() * equipTypes.length)];
                
                const basePower = 5 + level * 2;
                const variance = Math.floor(Math.random() * 6) - 3; // -3 to +3
                
                switch (type) {
                    case 'weapon':
                        return {
                            type: 'weapon',
                            name: `Enchanted Sword +${Math.max(1, level)}`,
                            attack: basePower + variance,
                            description: 'A magical underwater blade'
                        };
                    case 'armor':
                        return {
                            type: 'armor',
                            name: `Shell Armor +${Math.max(1, level)}`,
                            defense: basePower + variance,
                            description: 'Protective turtle shell armor'
                        };
                    case 'ring':
                        return {
                            type: 'ring',
                            name: `Pearl Ring +${Math.max(1, level)}`,
                            special: 'swim_boost',
                            description: 'Reduces oxygen consumption'
                        };
                }
            }
            
            spawnItems() {
                const itemCount = Math.floor(Math.random() * 5) + 3 + this.gameState.currentDepth;
                
                for (let i = 0; i < itemCount; i++) {
                    const room = this.gameState.rooms[Math.floor(Math.random() * this.gameState.rooms.length)];
                    if (!room) continue;
                    
                    let x, y, attempts = 0;
                    do {
                        x = room.x + Math.floor(Math.random() * room.width);
                        y = room.y + Math.floor(Math.random() * room.height);
                        attempts++;
                    } while ((this.gameState.gameMap[x][y] !== TILES.FLOOR || this.getEntityAt(x, y)) && attempts < 50);
                    
                    if (attempts < 50) {
                        this.createItem(x, y);
                    }
                }
                
                // Add gold
                for (let i = 0; i < 8; i++) {
                    const room = this.gameState.rooms[Math.floor(Math.random() * this.gameState.rooms.length)];
                    if (!room) continue;
                    
                    let x, y, attempts = 0;
                    do {
                        x = room.x + Math.floor(Math.random() * room.width);
                        y = room.y + Math.floor(Math.random() * room.height);
                        attempts++;
                    } while ((this.gameState.gameMap[x][y] !== TILES.FLOOR || this.getEntityAt(x, y)) && attempts < 50);
                    
                    if (attempts < 50) {
                        this.createGold(x, y, Math.floor(Math.random() * 20) + 5);
                    }
                }
            }
            
            createItem(x, y) {
                const itemTypes = Object.keys(ITEM_DATABASE);
                const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                const itemData = ITEM_DATABASE[itemType][Math.floor(Math.random() * ITEM_DATABASE[itemType].length)];
                
                // Use ONLY Professional PixelLab Sprites (PRODUCTION QUALITY!)
                let textureKey = 'item_gold'; // Safe visible fallback
                
                if (itemType === 'potions' && itemData.effect === 'heal') {
                    textureKey = this.textures.exists('health_potion_south') ? 'health_potion_south' : 
                               this.textures.exists('health_potion') ? 'health_potion' : 'item_gold';
                } else if (itemType === 'potions' && itemData.effect === 'mana') {
                    textureKey = this.textures.exists('mana_potion_south') ? 'mana_potion_south' :
                               this.textures.exists('mana_potion') ? 'mana_potion' : 'item_gold';
                } else if (itemType === 'potions' && itemData.effect === 'oxygen') {
                    textureKey = this.textures.exists('oxygen_potion_south') ? 'oxygen_potion_south' : 'item_gold';
                } else if (itemType === 'weapons') {
                    // Multiple weapon tiers (professional variety)
                    const rand = Math.random();
                    if (rand < 0.2 && this.textures.exists('steel_trident_south')) {
                        textureKey = 'steel_trident_south';
                    } else if (rand < 0.5 && this.textures.exists('iron_sword_south')) {
                        textureKey = 'iron_sword_south';
                    } else if (this.textures.exists('rusty_sword_south')) {
                        textureKey = 'rusty_sword_south';
                    } else {
                        textureKey = 'item_gold';
                    }
                } else if (itemType === 'rings') {
                    // Multiple ring types (professional variety)
                    if (Math.random() < 0.3 && this.textures.exists('pearl_necklace_south')) {
                        textureKey = 'pearl_necklace_south';
                    } else if (this.textures.exists('iron_ring_south')) {
                        textureKey = 'iron_ring_south';
                    } else {
                        textureKey = 'item_gold';
                    }
                } else if (itemType === 'scrolls') {
                    textureKey = this.textures.exists('magic_scroll_south') ? 'magic_scroll_south' : 'item_gold';
                } else if (itemType === 'armor') {
                    const rand = Math.random();
                    if (rand < 0.3 && this.textures.exists('iron_chestplate_south')) {
                        textureKey = 'iron_chestplate_south';
                    } else if (rand < 0.6 && this.textures.exists('leather_armor_south')) {
                        textureKey = 'leather_armor_south';
                    } else if (this.textures.exists('iron_helmet_south')) {
                        textureKey = 'iron_helmet_south';
                    } else {
                        textureKey = 'item_gold';
                    }
                }
                
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(1.0); // Bigger for visibility
                sprite.setDepth(80);
                
                const item = new Entity(x, y, ENTITY_TYPES.ITEM, sprite);
                
                // Determine rarity and identification status
                const rarity = this.determineItemRarity(itemData, this.gameState.currentDepth);
                const autoIdentified = !this.requiresIdentification({rarity});
                
                item.itemData = {
                    ...itemData,
                    type: itemType.slice(0, -1),
                    rarity: rarity,
                    identified: autoIdentified, // Common/uncommon auto-identified
                    cursed: Math.random() < 0.1 // 10% chance of curse
                };
                
                this.gameState.entities.push(item);
            }
            
            createItem(x, y, itemData) {
                // Overloaded version for creating specific items (like treasure room items)
                if (typeof itemData === 'object' && itemData.name) {
                    let textureKey = 'item_gold'; // Safe fallback
                    
                    // Try to find appropriate texture based on item
                    if (itemData.type === 'potion') {
                        if (itemData.effect === 'heal') {
                            textureKey = this.textures.exists('health_potion_south') ? 'health_potion_south' : 'item_gold';
                        } else if (itemData.effect === 'mana') {
                            textureKey = this.textures.exists('mana_potion_south') ? 'mana_potion_south' : 'item_gold';
                        } else if (itemData.effect === 'oxygen') {
                            textureKey = this.textures.exists('oxygen_potion_south') ? 'oxygen_potion_south' : 'item_gold';
                        }
                    } else if (itemData.type === 'weapon') {
                        textureKey = this.textures.exists('steel_trident_south') ? 'steel_trident_south' : 'item_gold';
                    } else if (itemData.type === 'armor') {
                        textureKey = this.textures.exists('iron_chestplate_south') ? 'iron_chestplate_south' : 'item_gold';
                    }
                    
                    const sprite = this.add.sprite(
                        x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                        y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                        textureKey
                    );
                    sprite.setScale(1.0);
                    sprite.setDepth(80);
                    
                    const item = new Entity(x, y, ENTITY_TYPES.ITEM, sprite);
                    
                    // Use provided rarity or determine automatically
                    const rarity = itemData.rarity || this.determineItemRarity(itemData, this.gameState.currentDepth);
                    const autoIdentified = !this.requiresIdentification({rarity});
                    
                    item.itemData = {
                        ...itemData,
                        rarity: rarity,
                        identified: autoIdentified,
                        cursed: Math.random() < 0.1
                    };
                    
                    this.gameState.entities.push(item);
                    return; // Exit early for specific item creation
                }
                
                // If no itemData provided, fall through to original random item creation
                // (This preserves the original function behavior)
            }
            
            createGold(x, y, amount) {
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    'item_gold'
                );
                sprite.setScale(0.6);
                sprite.setDepth(80);
                
                const gold = new Entity(x, y, ENTITY_TYPES.ITEM, sprite);
                gold.itemData = {
                    type: 'gold',
                    amount: amount,
                    identified: true
                };
                
                this.gameState.entities.push(gold);
            }
            
            renderMap() {
                // Clear existing tiles
                this.tileSprites.forEach(sprite => sprite.destroy());
                this.tileSprites = [];
                
                // Render visible portion of map
                for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
                    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
                        const tileType = this.gameState.gameMap[x][y];
                        let textureKey = 'tile_void';
                        
                        switch (tileType) {
                            case TILES.FLOOR:
                                textureKey = 'tile_floor';
                                break;
                            case TILES.WALL:
                                textureKey = 'tile_wall';
                                break;
                            case TILES.WATER:
                                textureKey = 'tile_water';
                                break;
                            case TILES.DEEP_WATER:
                                textureKey = 'tile_deep_water';
                                break;
                            case TILES.AIR_POCKET:
                                textureKey = 'tile_air_pocket';
                                break;
                            case TILES.STAIRS_DOWN:
                                textureKey = 'tile_stairs';
                                break;
                            case TILES.TREASURE_FLOOR:
                                textureKey = 'tile_treasure_floor';
                                break;
                        }
                        
                        const sprite = this.add.sprite(
                            x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            textureKey
                        );
                        sprite.setDepth(1);
                        
                        // Special styling for stairs to make them more visible
                        if (tileType === TILES.STAIRS_DOWN) {
                            sprite.setTint(0xffff00).setScale(1.1);
                        }
                        
                        this.tileSprites.push(sprite);
                    }
                }
            }
            
            setupInput() {
                // Keyboard input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasdKeys = this.input.keyboard.addKeys('W,S,A,D,SPACE,I,U,E,R');
                
                // Mouse/touch input - only allow adjacent moves (no teleporting!)
                this.input.on('pointerdown', (pointer) => {
                    if (!this.playerTurn) return;
                    
                    const worldX = pointer.worldX;
                    const worldY = pointer.worldY;
                    const tileX = Math.floor(worldX / GAME_CONFIG.TILE_SIZE);
                    const tileY = Math.floor(worldY / GAME_CONFIG.TILE_SIZE);
                    
                    const dx = tileX - this.gameState.player.x;
                    const dy = tileY - this.gameState.player.y;
                    
                    // Only allow movement to adjacent tiles (no cheating!)
                    if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx !== 0 || dy !== 0)) {
                        this.handleMovement(dx, dy);
                    } else if (dx === 0 && dy === 0) {
                        // Clicked on self - wait/skip turn
                        this.handleWait();
                    } else {
                        // Clicked too far away - show message
                        this.gameState.addMessage('🐢 Bob can only move to adjacent tiles!', '#e74c3c');
                    }
                });
            }
            
            update() {
                if (!this.playerTurn || this.gameOverShown || !this.cursors || !this.wasdKeys) return;
                
                // Performance monitoring disabled for cleaner UI
                // if (this.performanceData && this.performanceData.frameCount % 30 === 0) {
                //     this.updatePerformanceDisplay();
                // }
                // if (this.performanceData) this.performanceData.frameCount++;
                
                // Handle keyboard input
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.W)) {
                    this.handleMovement(0, -1);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.S)) {
                    this.handleMovement(0, 1);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.A)) {
                    this.handleMovement(-1, 0);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.D)) {
                    this.handleMovement(1, 0);
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.SPACE)) {
                    this.handleWait();
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.I)) {
                    this.toggleInventoryPanel();
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.U)) {
                    this.useRandomItem();
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.E)) {
                    this.toggleEquipmentPanel();
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.R)) {
                    this.identifyRandomItem();
                }
            }
            
            handleMovement(dx, dy) {
                const newX = this.gameState.player.x + dx;
                const newY = this.gameState.player.y + dy;
                
                // Check bounds
                if (newX < 0 || newX >= GAME_CONFIG.MAP_WIDTH || newY < 0 || newY >= GAME_CONFIG.MAP_HEIGHT) {
                    return;
                }
                
                // Check if position is passable
                const tileType = this.gameState.gameMap[newX][newY];
                if (tileType === TILES.WALL || tileType === TILES.VOID) {
                    this.gameState.addMessage('🚫 You cannot move there.', '#e74c3c');
                    return;
                }
                
                // Check for enemies
                const enemy = this.getEntityAt(newX, newY, ENTITY_TYPES.ENEMY);
                if (enemy) {
                    // Player attacks enemy
                    this.combat(this.gameState.player, enemy);
                    this.endPlayerTurn();
                    return;
                }
                
                // Check for items
                const item = this.getEntityAt(newX, newY, ENTITY_TYPES.ITEM);
                if (item) {
                    this.pickupItem(item);
                }
                
                // Update player direction for sprite animation
                this.updatePlayerDirection(dx, dy);
                
                // Move player
                this.moveEntity(this.gameState.player, newX, newY);
                
                // Update spatial audio listener position
                this.updateListenerPosition();
                
                // Handle tile effects
                this.handleTileEffects(tileType);
                
                // Check for stairs
                if (tileType === TILES.STAIRS_DOWN) {
                    this.descendStairs();
                    return;
                }
                
                this.endPlayerTurn();
            }
            
            handleTileEffects(tileType) {
                const oxygen = this.gameState.player.getComponent('oxygen');
                const abilities = this.gameState.player.getComponent('abilities');
                
                switch (tileType) {
                    case TILES.FLOOR:
                        this.gameState.addMessage('🏖️ You stand on the sandy floor.', '#d2b48c');
                        // Slight oxygen recovery on dry floor
                        oxygen.currentOxygen = Math.min(100, oxygen.currentOxygen + 2);
                        if (oxygen.drowning && oxygen.currentOxygen > 20) {
                            oxygen.drowning = false;
                            this.gameState.addMessage('😌 You can breathe in this dry area!', '#2ecc71');
                        }
                        break;
                    case TILES.AIR_POCKET:
                        this.gameState.addMessage('🫧 You breathe deeply in the air pocket!', '#85c1e9');
                        oxygen.currentOxygen = 100; // Full restoration in air pockets
                        if (oxygen.drowning) {
                            oxygen.drowning = false;
                            this.gameState.addMessage('💨 Fresh air fills your lungs!', '#2ecc71');
                        }
                        break;
                    case TILES.WATER:
                        this.gameState.addMessage('💧 You wade through flooded ruins.', '#3498db');
                        if (!abilities.swimBoosted) {
                            oxygen.currentOxygen = Math.max(0, oxygen.currentOxygen - 3);
                        }
                        break;
                    case TILES.DEEP_WATER:
                        this.gameState.addMessage('🌊 You swim through the deep depths!', '#2980b9');
                        if (!abilities.swimBoosted) {
                            oxygen.currentOxygen = Math.max(0, oxygen.currentOxygen - 8);
                        }
                        if (oxygen.currentOxygen <= 0 && !oxygen.drowning) {
                            oxygen.drowning = true;
                            this.gameState.addMessage('😵 You are drowning! Find air pockets!', '#e74c3c');
                        }
                        break;
                    case TILES.TREASURE_FLOOR:
                        this.handleTreasureFloor(newX, newY);
                        break;
                }
                
                // Drowning damage
                if (oxygen.drowning && oxygen.currentOxygen <= 0) {
                    const health = this.gameState.player.getComponent('health');
                    health.currentHealth -= 8;
                    this.gameState.addMessage('💀 You lose health from drowning!', '#e74c3c');
                    if (health.currentHealth <= 0) {
                        this.gameOver('You drowned in the underwater ruins!');
                    }
                }
            }
            
            pickupItem(item) {
                if (item.itemData.type === 'gold') {
                    this.gameState.gold += item.itemData.amount;
                    this.gameState.addMessage(`💰 You pick up ${item.itemData.amount} gold!`, '#f1c40f');
                } else {
                    if (this.gameState.addToInventory(item.itemData)) {
                        const displayName = item.itemData.identified ? item.itemData.name : `Unknown ${item.itemData.type}`;
                        
                        // Track items found for achievements
                        this.gameState.stats.itemsFound++;
                        
                        if (item.itemData.type === 'potion') {
                            this.gameState.addMessage(`🧪 You pick up ${displayName}!`, '#e74c3c');
                        } else if (item.itemData.type === 'equipment') {
                            this.gameState.addMessage(`⚔️ You pick up ${displayName}!`, '#f39c12');
                            
                            // Check for legendary item achievement
                            if (item.itemData.rarity === 'legendary') {
                                this.checkAndUnlockAchievement('legendary_finder');
                            }
                            
                            // Auto-equip if better than current equipment (identified items only)
                            if (item.itemData.identified) {
                                this.autoEquipIfBetter(item.itemData);
                            }
                        } else {
                            this.gameState.addMessage(`📦 You pick up ${displayName}.`, '#2ecc71');
                        }
                        
                        // Check treasure hunter achievement
                        if (this.gameState.stats.itemsFound >= 50) {
                            this.checkAndUnlockAchievement('treasure_hunter');
                        }
                    } else {
                        this.gameState.addMessage('🎒 Your inventory is full!', '#e74c3c');
                        return;
                    }
                }
                
                // Remove item from world properly
                this.removeEntity(item);
            }
            
            removeEntity(entity) {
                // Remove from entities array
                const index = this.gameState.entities.indexOf(entity);
                if (index > -1) {
                    this.gameState.entities.splice(index, 1);
                }
                
                // Destroy sprite
                if (entity.sprite) {
                    entity.sprite.destroy();
                }
            }
            
            useItem(index) {
                if (index < 0 || index >= this.gameState.inventory.length) return;
                
                const item = this.gameState.inventory[index];
                const identified = item.identified || this.gameState.identifiedItems.has(item.name);
                
                if (!identified) {
                    this.gameState.addMessage('❓ You need to identify this item first!', '#f39c12');
                    return;
                }
                
                let used = false;
                
                switch (item.type) {
                    case ITEM_TYPES.POTION:
                        used = this.usePotionEffect(item);
                        break;
                    case ITEM_TYPES.SCROLL:
                        used = this.useScrollEffect(item);
                        break;
                    case ITEM_TYPES.WEAPON:
                        used = this.equipWeapon(item);
                        break;
                    case ITEM_TYPES.ARMOR:
                        used = this.equipArmor(item);
                        break;
                    case ITEM_TYPES.RING:
                        used = this.equipRing(item);
                        break;
                }
                
                if (used && (item.type === ITEM_TYPES.POTION || item.type === ITEM_TYPES.SCROLL)) {
                    this.gameState.removeFromInventory(item);
                    this.endPlayerTurn();
                }
            }
            
            usePotionEffect(potion) {
                const player = this.gameState.player;
                
                switch (potion.effect) {
                    case 'heal':
                        const health = player.getComponent('health');
                        const healAmount = Math.min(potion.power, health.maxHealth - health.currentHealth);
                        health.currentHealth += healAmount;
                        this.gameState.addMessage(`❤️ You heal ${healAmount} health!`, '#e74c3c');
                        break;
                    case 'mana':
                        const mana = player.getComponent('mana');
                        const manaAmount = Math.min(potion.power, mana.maxMana - mana.currentMana);
                        mana.currentMana += manaAmount;
                        this.gameState.addMessage(`💙 You restore ${manaAmount} mana!`, '#3498db');
                        break;
                    case 'oxygen':
                        const oxygen = player.getComponent('oxygen');
                        oxygen.currentOxygen = Math.min(100, oxygen.currentOxygen + potion.power);
                        oxygen.drowning = false;
                        this.gameState.addMessage(`🫧 You can breathe underwater longer!`, '#1abc9c');
                        break;
                    default:
                        this.gameState.addMessage(`✨ You feel ${potion.effect}!`, '#9b59b6');
                        break;
                }
                
                return true;
            }
            
            useScrollEffect(scroll) {
                switch (scroll.effect) {
                    case 'identify':
                        this.identifyAllItems();
                        break;
                    case 'teleport':
                        this.teleportPlayer();
                        break;
                    case 'map':
                        this.revealMap();
                        break;
                    case 'confuse':
                        this.confuseEnemies();
                        break;
                    case 'lightning':
                        this.lightningAttack();
                        break;
                }
                
                return true;
            }
            
            equipWeapon(weapon) {
                const oldWeapon = this.gameState.equipment.weapon;
                this.gameState.equipment.weapon = weapon;
                this.gameState.removeFromInventory(weapon);
                
                if (oldWeapon && oldWeapon.name !== 'Shell Claw') {
                    this.gameState.addToInventory(oldWeapon);
                }
                
                this.gameState.addMessage(`⚔️ You equip ${weapon.name}!`, '#e74c3c');
                this.updateUI();
                return true;
            }
            
            equipArmor(armor) {
                const oldArmor = this.gameState.equipment.armor;
                this.gameState.equipment.armor = armor;
                this.gameState.removeFromInventory(armor);
                
                if (oldArmor && oldArmor.name !== 'Turtle Shell') {
                    this.gameState.addToInventory(oldArmor);
                }
                
                this.gameState.addMessage(`🛡️ You equip ${armor.name}!`, '#95a5a6');
                this.updateUI();
                return true;
            }
            
            equipRing(ring) {
                const oldRing = this.gameState.equipment.ring;
                this.gameState.equipment.ring = ring;
                this.gameState.removeFromInventory(ring);
                
                if (oldRing) {
                    this.gameState.addToInventory(oldRing);
                }
                
                this.gameState.addMessage(`💍 You equip ${ring.name}!`, '#f1c40f');
                this.updateUI();
                return true;
            }
            
            identifyRandomItem() {
                // Only magical items need paid identification
                const unidentified = this.gameState.inventory.filter(item => 
                    !item.identified && 
                    !this.gameState.identifiedItems.has(item.name) &&
                    this.requiresIdentification(item)
                );
                
                if (unidentified.length === 0) {
                    this.gameState.addMessage('🔍 No magical items need identification. Find a Scholar for rare item services!', '#95a5a6');
                    return;
                }
                
                // Calculate identification cost based on item rarity
                const item = unidentified[Math.floor(Math.random() * unidentified.length)];
                const goldCost = this.getIdentificationCost(item);
                
                if (this.gameState.gold < goldCost) {
                    this.gameState.addMessage(`🔍 You need ${goldCost} gold to identify this item. Find a Scholar who can help!`, '#e74c3c');
                    return;
                }
                
                this.gameState.addMessage('🔍 This looks like a job for a Scholar... Try finding one in the dungeon!', '#f39c12');
                this.gameState.addMessage('💰 They usually charge gold for identification services.', '#f39c12');
            }
            
            requiresIdentification(item) {
                // Only rare and above items need identification
                // Common and uncommon items are auto-identified
                if (!item.rarity) return false;
                return ['rare', 'epic', 'legendary'].includes(item.rarity);
            }
            
            getIdentificationCost(item) {
                const costs = {
                    'rare': 50,
                    'epic': 100,
                    'legendary': 200
                };
                return costs[item.rarity] || 25;
            }
            
            determineItemRarity(itemData, depth) {
                // Base rarity chances (higher depth = better items)
                const rarityRoll = Math.random() + (depth * 0.03); // Depth bonus
                
                if (rarityRoll < 0.6) return 'common';      // 60% base
                if (rarityRoll < 0.85) return 'uncommon';   // 25% base
                if (rarityRoll < 0.95) return 'rare';       // 10% base
                if (rarityRoll < 0.99) return 'epic';       // 4% base
                return 'legendary';                          // 1% base
            }
            
            identifyAllItems() {
                this.gameState.inventory.forEach(item => {
                    this.gameState.identifiedItems.add(item.name);
                });
                this.gameState.addMessage('🔍 All items are identified!', '#2ecc71');
                this.gameState.updateInventoryDisplay();
            }
            
            useRandomItem() {
                if (this.gameState.inventory.length === 0) {
                    this.gameState.addMessage('📦 No items to use.', '#95a5a6');
                    return;
                }
                
                const index = Math.floor(Math.random() * this.gameState.inventory.length);
                this.useItem(index);
            }
            
            toggleInventoryPanel() {
                const panel = document.getElementById('inventory-panel');
                const button = document.getElementById('inventory-btn');
                
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    button.style.background = '#2c3e50';
                    button.innerHTML = '🎒 Close';
                    this.gameState.addMessage('📦 Inventory opened (I to close)', '#95a5a6');
                } else {
                    panel.style.display = 'none';
                    button.style.background = '#8b4513';
                    button.innerHTML = '🎒 Backpack';
                    this.gameState.addMessage('📦 Inventory closed', '#95a5a6');
                }
            }
            
            toggleEquipmentPanel() {
                const panel = document.getElementById('inventory-panel');
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    this.gameState.addMessage('⚔️ Equipment view (E to close)', '#f39c12');
                } else {
                    panel.style.display = 'none';
                    this.gameState.addMessage('⚔️ Equipment closed', '#95a5a6');
                }
                // Focus on equipment section
                const equipSection = document.getElementById('equipped-items');
                if (equipSection) {
                    equipSection.style.backgroundColor = '#2c3e50';
                    setTimeout(() => {
                        equipSection.style.backgroundColor = 'rgba(44, 62, 80, 0.95)';
                    }, 1000);
                }
            }
            
            // Cloud save/load integration
            async loadExistingSave() {
                try {
                    // Checking for existing save
                    const result = await dbManager.loadGame();
                    
                    if (result && result.saveData) {
                        const data = result.saveData;
                        this.gameState.addMessage('💾 Cloud save found! Loading...', '#3498db');
                        
                        // Apply save data
                        this.gameState.currentDepth = data.depth || 1;
                        this.gameState.gold = data.gold || 0;
                        this.gameState.stats = { ...this.gameState.stats, ...data.stats };
                        this.gameState.achievements = new Set(data.achievements || []);
                        
                        if (data.equipment) {
                            this.gameState.equipment = { ...this.gameState.equipment, ...data.equipment };
                        }
                        
                        if (data.inventory) {
                            this.gameState.inventory = data.inventory;
                        }
                        
                        if (data.identifiedItems) {
                            this.gameState.identifiedItems = new Set(data.identifiedItems);
                        }
                        
                        // Update player level if needed
                        if (data.playerLevel && this.gameState.player) {
                            const levelComp = this.gameState.player.getComponent('level');
                            if (levelComp && data.playerLevel > levelComp.level) {
                                levelComp.level = data.playerLevel;
                                levelComp.experience = levelComp.calculateExpToNext() * (data.playerLevel - 1);
                            }
                        }
                        
                        this.gameState.addMessage('✅ Save loaded successfully!', '#2ecc71');
                        this.updateUI();
                    } else {
                        // No existing save found, starting fresh
                    }
                } catch (error) {
                    console.error('Save load error:', error);
                    this.gameState.addMessage('⚠️ Using local progress (cloud save unavailable)', '#f39c12');
                }
            }
            
            async saveGameProgress() {
                try {
                    if (!this.gameState.player) return;
                    
                    const levelComp = this.gameState.player.getComponent('level');
                    const saveData = {
                        depth: this.gameState.currentDepth,
                        gold: this.gameState.gold,
                        stats: this.gameState.stats,
                        achievements: Array.from(this.gameState.achievements),
                        equipment: this.gameState.equipment,
                        inventory: this.gameState.inventory,
                        identifiedItems: Array.from(this.gameState.identifiedItems),
                        playerLevel: levelComp ? levelComp.level : 1
                    };
                    
                    const result = await dbManager.saveGame(saveData);
                    
                    if (result.success) {
                        // Game saved to cloud
                    } else {
                        // Game saved locally
                    }
                } catch (error) {
                    console.error('Save error:', error);
                }
            }
            
            // Achievement system integration
            async checkAndUnlockAchievement(achievementId) {
                try {
                    if (this.gameState.achievements.has(achievementId)) return;
                    
                    const result = await dbManager.unlockAchievement(achievementId);
                    
                    if (result && result.success && !result.alreadyUnlocked) {
                        this.gameState.achievements.add(achievementId);
                        this.gameState.addMessage(`🏆 ACHIEVEMENT UNLOCKED: ${result.achievement.name}!`, '#f1c40f');
                        this.gameState.addMessage(`${result.achievement.icon} ${result.achievement.description}`, '#f39c12');
                        
                        // Show big visual achievement notification
                        this.showAchievementNotification(result.achievement);
                        
                                        // Visual celebration with modern FX
                this.createMagicEffect(this.gameState.player.x, this.gameState.player.y, 'achievement');
                this.addMagicFX(this.gameState.player, 0xffd700); // Golden glow for achievement
                
                this.playSimpleSound('achievement_unlock');
                    }
                } catch (error) {
                    console.error('Achievement unlock error:', error);
                }
            }
            
            setupUIButtons() {
                // Setup button event listeners
                const shellRetreatBtn = document.getElementById('shell-retreat-btn');
                const swimBoostBtn = document.getElementById('swim-boost-btn');
                const inventoryBtn = document.getElementById('inventory-btn');
                const identifyBtn = document.getElementById('identify-btn');
                
                if (shellRetreatBtn) {
                    shellRetreatBtn.addEventListener('click', () => {
                        this.useShellRetreat();
                    });
                }
                
                if (swimBoostBtn) {
                    swimBoostBtn.addEventListener('click', () => {
                        this.useSwimBoost();
                    });
                }
                
                if (inventoryBtn) {
                    inventoryBtn.addEventListener('click', () => {
                        this.toggleInventoryPanel();
                    });
                }
                
                if (identifyBtn) {
                    identifyBtn.addEventListener('click', () => {
                        this.identifyRandomItem();
                    });
                }
                
                // Audio Controls
                this.musicEnabled = true;
                this.musicVolume = 0.3;
                
                // Pause system
                this.isPaused = false;
                this.sfxVolume = 0.7;
                
                const musicToggleBtn = document.getElementById('music-toggle-btn');
                if (musicToggleBtn) {
                    musicToggleBtn.addEventListener('click', () => {
                        this.toggleMusic();
                    });
                }
                
                const volumeDownBtn = document.getElementById('volume-down-btn');
                if (volumeDownBtn) {
                    volumeDownBtn.addEventListener('click', () => {
                        this.adjustVolume(-0.1);
                    });
                }
                
                const volumeUpBtn = document.getElementById('volume-up-btn');
                if (volumeUpBtn) {
                    volumeUpBtn.addEventListener('click', () => {
                        this.adjustVolume(0.1);
                    });
                }
                
                // Setup inventory item click handlers
                this.setupInventoryClickHandlers();
            }
            
            setupInventoryClickHandlers() {
                // Add event delegation for inventory items
                const inventoryDiv = document.getElementById('inventory-items');
                if (inventoryDiv) {
                    // Remove existing listeners to prevent duplicates
                    inventoryDiv.removeEventListener('click', this.inventoryClickHandler);
                    inventoryDiv.removeEventListener('mouseover', this.inventoryHoverHandler);
                    inventoryDiv.removeEventListener('mouseout', this.inventoryLeaveHandler);
                    inventoryDiv.removeEventListener('mousemove', this.inventoryMoveHandler);
                    
                    // Add click listener
                    this.inventoryClickHandler = (event) => {
                        if (event.target.classList.contains('item-slot')) {
                            const index = parseInt(event.target.getAttribute('data-item-index'));
                            if (!isNaN(index)) {
                                this.useItem(index);
                            }
                        }
                    };
                    
                    // Add tooltip listeners
                    this.inventoryHoverHandler = (event) => {
                        if (event.target.classList.contains('item-slot')) {
                            this.showItemTooltip(event.target, event);
                        }
                    };
                    
                    this.inventoryLeaveHandler = (event) => {
                        if (event.target.classList.contains('item-slot')) {
                            this.hideItemTooltip();
                        }
                    };
                    
                    this.inventoryMoveHandler = (event) => {
                        if (event.target.classList.contains('item-slot')) {
                            this.updateTooltipPosition(event);
                        }
                    };
                    
                    inventoryDiv.addEventListener('click', this.inventoryClickHandler);
                    inventoryDiv.addEventListener('mouseover', this.inventoryHoverHandler);
                    inventoryDiv.addEventListener('mouseout', this.inventoryLeaveHandler);
                    inventoryDiv.addEventListener('mousemove', this.inventoryMoveHandler);
                }
            }
            
            showItemTooltip(element, event) {
                try {
                    const itemData = JSON.parse(element.getAttribute('data-item-data'));
                    const identified = element.getAttribute('data-identified') === 'true';
                    const tooltip = document.getElementById('item-tooltip');
                    const content = document.getElementById('tooltip-content');
                    
                    if (!tooltip || !content) return;
                    
                    // Generate tooltip content
                    let tooltipHTML = '';
                    
                    if (identified) {
                        // Full item details for identified items
                        const rarity = itemData.rarity || 'common';
                        const rarityColor = {
                            'common': '#95a5a6',
                            'uncommon': '#2ecc71', 
                            'rare': '#3498db',
                            'epic': '#9b59b6',
                            'legendary': '#f39c12'
                        }[rarity] || '#95a5a6';
                        
                        tooltipHTML = `
                            <div style="margin-bottom: 8px;">
                                <strong style="color: ${rarityColor};">${itemData.name}</strong>
                                <span style="color: #bdc3c7; font-size: 11px; float: right;">${rarity.toUpperCase()}</span>
                            </div>
                        `;
                        
                        if (itemData.type === 'equipment') {
                            tooltipHTML += `
                                <div style="color: #e67e22; margin: 4px 0;">⚔️ Bonus: +${itemData.bonus || 0}</div>
                                <div style="color: #3498db; margin: 4px 0;">🛡️ Type: ${itemData.subtype || 'Equipment'}</div>
                            `;
                            
                            // Compare with current equipment
                            const currentEquip = this.gameState.equipment[itemData.subtype];
                            if (currentEquip) {
                                const currentBonus = currentEquip.bonus || 0;
                                const difference = (itemData.bonus || 0) - currentBonus;
                                const comparisonColor = difference > 0 ? '#2ecc71' : difference < 0 ? '#e74c3c' : '#95a5a6';
                                const arrow = difference > 0 ? '↗️' : difference < 0 ? '↘️' : '→';
                                
                                tooltipHTML += `
                                    <hr style="border: 1px solid #34495e; margin: 8px 0;">
                                    <div style="color: #bdc3c7; font-size: 11px;">Currently equipped:</div>
                                    <div style="color: #95a5a6;">${currentEquip.name} (+${currentBonus})</div>
                                    <div style="color: ${comparisonColor};">${arrow} ${difference > 0 ? '+' : ''}${difference} bonus</div>
                                `;
                            }
                        } else if (itemData.type === 'potion') {
                            tooltipHTML += `
                                <div style="color: #e74c3c; margin: 4px 0;">💊 Effect: ${itemData.effect || 'Unknown'}</div>
                                <div style="color: #f39c12; margin: 4px 0;">🔄 Amount: ${itemData.amount || 'Variable'}</div>
                            `;
                        } else if (itemData.type === 'scroll') {
                            tooltipHTML += `
                                <div style="color: #8e44ad; margin: 4px 0;">📜 Spell: ${itemData.spell || 'Unknown'}</div>
                                <div style="color: #3498db; margin: 4px 0;">⚡ Effect: ${itemData.effect || 'Magical'}</div>
                            `;
                        }
                        
                        if (itemData.description) {
                            tooltipHTML += `
                                <hr style="border: 1px solid #34495e; margin: 8px 0;">
                                <div style="color: #bdc3c7; font-style: italic; font-size: 11px;">${itemData.description}</div>
                            `;
                        }
                        
                        tooltipHTML += `
                            <hr style="border: 1px solid #34495e; margin: 8px 0;">
                            <div style="color: #2ecc71; font-size: 11px;">💡 Click to use this item</div>
                        `;
                    } else {
                        // Limited info for unidentified items
                        tooltipHTML = `
                            <div style="margin-bottom: 8px;">
                                <strong style="color: #e67e22;">Unknown ${itemData.type}</strong>
                                <span style="color: #e74c3c; float: right;">❓</span>
                            </div>
                            <div style="color: #95a5a6; margin: 4px 0;">This item has not been identified.</div>
                            <div style="color: #95a5a6; margin: 4px 0;">Type: ${itemData.type}</div>
                            <hr style="border: 1px solid #34495e; margin: 8px 0;">
                            <div style="color: #f39c12; font-size: 11px;">🔍 Find a Scholar NPC to identify rare items</div>
                            <div style="color: #e74c3c; font-size: 11px;">⚠️ Magical items need gold to identify!</div>
                        `;
                    }
                    
                    content.innerHTML = tooltipHTML;
                    this.updateTooltipPosition(event);
                    tooltip.style.display = 'block';
                } catch (error) {
                    // Error showing tooltip - silently fail
                }
            }
            
            hideItemTooltip() {
                const tooltip = document.getElementById('item-tooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            }
            
            updateTooltipPosition(event) {
                const tooltip = document.getElementById('item-tooltip');
                if (!tooltip || tooltip.style.display === 'none') return;
                
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                const offsetX = 15;
                const offsetY = 15;
                
                // Position tooltip to the right and below cursor by default
                let left = mouseX + offsetX;
                let top = mouseY + offsetY;
                
                // Adjust if tooltip would go off screen
                const tooltipRect = tooltip.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if (left + tooltipRect.width > windowWidth) {
                    left = mouseX - tooltipRect.width - offsetX;
                }
                
                if (top + tooltipRect.height > windowHeight) {
                    top = mouseY - tooltipRect.height - offsetY;
                }
                
                tooltip.style.left = Math.max(5, left) + 'px';
                tooltip.style.top = Math.max(5, top) + 'px';
            }
            
            setupPerformanceMonitoring() {
                // Add FPS and performance display based on latest Phaser 3 docs
                this.performanceText = this.add.text(10, 10, 'Loading...', {
                    fontSize: '14px',
                    color: '#00ff00',
                    backgroundColor: '#000000',
                    padding: { x: 5, y: 5 }
                }).setDepth(1000).setScrollFactor(0);
                
                // Track performance metrics
                this.performanceData = {
                    frameCount: 0,
                    lastTime: 0,
                    fpsHistory: []
                };
                
                // Initial update to prevent empty box
                this.time.delayedCall(500, () => {
                    this.updatePerformanceDisplay();
                });
            }
            
            updatePerformanceDisplay() {
                try {
                    // Use Phaser's built-in renderer FPS tracking
                    const currentFPS = this.game.loop.actualFps || 60;
                    
                    // Track performance history
                    this.performanceData.fpsHistory.push(currentFPS);
                    if (this.performanceData.fpsHistory.length > 60) {
                        this.performanceData.fpsHistory.shift();
                    }
                    
                    const avgFPS = this.performanceData.fpsHistory.reduce((a, b) => a + b, 0) / this.performanceData.fpsHistory.length;
                    const minFPS = Math.min(...this.performanceData.fpsHistory);
                    
                    // Get WebGL info safely
                    const renderer = this.sys.renderer;
                    let pipelineName = 'Unknown';
                    
                    // Safe pipeline detection
                    if (renderer.type === Phaser.WEBGL) {
                        pipelineName = 'WebGL';
                        // Check for specific pipeline types safely
                        if (renderer.pipelines && renderer.pipelines.MULTI_PIPELINE) {
                            pipelineName = 'MultiTint';
                        }
                    } else if (renderer.type === Phaser.CANVAS) {
                        pipelineName = 'Canvas';
                    }
                    
                    // Display comprehensive performance info
                    this.performanceText.setText([
                        `FPS: ${Math.round(currentFPS)}`,
                        `Avg: ${Math.round(avgFPS)}`,
                        `Min: ${Math.round(minFPS)}`,
                        `Render: ${pipelineName}`,
                        `Entities: ${this.gameState.entities.length}`,
                        `Turn: ${this.gameState.turnCount}`
                    ]);
                } catch (e) {
                    // Fallback display if there are any errors
                    this.performanceText.setText([
                        `FPS: ${Math.round(this.game.loop.actualFps || 60)}`,
                        `Entities: ${this.gameState.entities.length}`,
                        `Turn: ${this.gameState.turnCount}`
                    ]);
                }
            }
            
            showEnemyHealthBar(enemy) {
                const health = enemy.getComponent('health');
                
                // Remove existing health bar if any
                if (enemy.healthBar) {
                    enemy.healthBar.destroy();
                }
                
                // Create health bar background
                const barWidth = 32;
                const barHeight = 4;
                const x = enemy.x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2 - barWidth/2;
                const y = enemy.y * GAME_CONFIG.TILE_SIZE - 8;
                
                enemy.healthBar = this.add.container(x, y);
                
                // Background (black)
                const bg = this.add.rectangle(0, 0, barWidth, barHeight, 0x000000)
                    .setOrigin(0.5)
                    .setDepth(200);
                
                // Health fill (red to green based on health %)
                const healthPercent = health.currentHealth / health.maxHealth;
                const fillWidth = barWidth * healthPercent;
                const fillColor = healthPercent > 0.5 ? 0x2ecc71 : 
                                 healthPercent > 0.25 ? 0xf39c12 : 0xe74c3c;
                
                const fill = this.add.rectangle(-barWidth/2 + fillWidth/2, 0, fillWidth, barHeight-1, fillColor)
                    .setOrigin(0.5)
                    .setDepth(201);
                
                enemy.healthBar.add([bg, fill]);
                
                // Auto-hide after 3 seconds
                this.time.delayedCall(3000, () => {
                    if (enemy.healthBar) {
                        enemy.healthBar.destroy();
                        enemy.healthBar = null;
                    }
                });
            }
            
            initializeMinimap() {
                this.minimapCanvas = document.getElementById('minimap');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                this.updateMinimap();
            }
            
            updateMinimap() {
                if (!this.minimapCanvas || !this.minimapCtx || !this.gameState || !this.gameState.gameMap) return;
                
                const ctx = this.minimapCtx;
                const canvas = this.minimapCanvas;
                
                // Clear minimap
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Calculate scale
                const scaleX = canvas.width / GAME_CONFIG.MAP_WIDTH;
                const scaleY = canvas.height / GAME_CONFIG.MAP_HEIGHT;
                
                // Minimap rendering
                
                // Draw map tiles
                for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
                    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
                        const tileType = this.gameState.gameMap[x][y];
                        let color = '#2c3e50'; // Default void
                        
                        switch (tileType) {
                            case TILES.FLOOR:
                                color = '#8b7355';
                                break;
                            case TILES.WALL:
                                color = '#34495e';
                                break;
                            case TILES.WATER:
                                color = '#3498db';
                                break;
                            case TILES.DEEP_WATER:
                                color = '#2980b9';
                                break;
                            case TILES.AIR_POCKET:
                                color = '#85c1e9';
                                break;
                            case TILES.TREASURE_FLOOR:
                                color = '#f1c40f';
                                break;
                            case TILES.CORAL_WALL:
                                color = '#e74c3c';
                                break;
                        }
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
                    }
                }
                
                // Draw entities
                for (const entity of this.gameState.entities) {
                    if (entity.type === ENTITY_TYPES.STAIRS) {
                        ctx.fillStyle = '#9b59b6';
                        ctx.fillRect(entity.x * scaleX, entity.y * scaleY, scaleX, scaleY);
                    } else if (entity.type === ENTITY_TYPES.ENEMY) {
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillRect(entity.x * scaleX - 1, entity.y * scaleY - 1, scaleX + 2, scaleY + 2);
                    } else if (entity.type === ENTITY_TYPES.ITEM || entity.type === ENTITY_TYPES.CHEST) {
                        ctx.fillStyle = '#f39c12';
                        ctx.fillRect(entity.x * scaleX, entity.y * scaleY, scaleX, scaleY);
                    }
                }
                
                // Draw player
                if (this.gameState.player) {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(
                        this.gameState.player.x * scaleX - 1, 
                        this.gameState.player.y * scaleY - 1, 
                        scaleX + 2, 
                        scaleY + 2
                    );
                }
            }
            
            showAchievementNotification(achievement) {
                // Create achievement popup overlay
                const overlay = this.add.rectangle(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY - 150,
                    400,
                    120,
                    0x2c3e50,
                    0.95
                );
                overlay.setScrollFactor(0);
                overlay.setDepth(2000);
                overlay.setStrokeStyle(4, 0xf1c40f);
                
                // Achievement icon and text
                const achievementText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY - 170,
                    `🏆 ACHIEVEMENT UNLOCKED!`,
                    {
                        fontSize: '24px',
                        color: '#f1c40f',
                        fontFamily: 'Courier New',
                        fontWeight: 'bold'
                    }
                );
                achievementText.setOrigin(0.5);
                achievementText.setScrollFactor(0);
                achievementText.setDepth(2001);
                
                const nameText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY - 140,
                    `${achievement.icon} ${achievement.name}`,
                    {
                        fontSize: '20px',
                        color: '#ffffff',
                        fontFamily: 'Courier New'
                    }
                );
                nameText.setOrigin(0.5);
                nameText.setScrollFactor(0);
                nameText.setDepth(2001);
                
                const descText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY - 115,
                    achievement.description,
                    {
                        fontSize: '14px',
                        color: '#95a5a6',
                        fontFamily: 'Courier New'
                    }
                );
                descText.setOrigin(0.5);
                descText.setScrollFactor(0);
                descText.setDepth(2001);
                
                // Animate in
                overlay.setScale(0);
                achievementText.setScale(0);
                nameText.setScale(0);
                descText.setScale(0);
                
                this.tweens.add({
                    targets: [overlay, achievementText, nameText, descText],
                    scaleX: 1,
                    scaleY: 1,
                    duration: 300,
                    ease: 'Back.easeOut'
                });
                
                // Auto-hide after 4 seconds
                this.time.delayedCall(4000, () => {
                    this.tweens.add({
                        targets: [overlay, achievementText, nameText, descText],
                        alpha: 0,
                        duration: 500,
                        onComplete: () => {
                            overlay.destroy();
                            achievementText.destroy();
                            nameText.destroy();
                            descText.destroy();
                        }
                    });
                });
            }
            
            // Turtle abilities implementation
            useShellRetreat() {
                const abilities = this.gameState.player.getComponent('abilities');
                if (abilities.shellRetreatCooldown > 0) {
                    this.gameState.addMessage(`🛡️ Shell retreat cooling down (${abilities.shellRetreatCooldown} turns)`, '#95a5a6');
                    return;
                }
                
                abilities.inShell = true;
                abilities.shellRetreatCooldown = 10;
                
                // Increase defense, but can't move or attack
                this.gameState.addMessage('🛡️ You retreat into your shell! +20 defense, cannot move.', '#2ecc71');
                
                // End turn automatically
                this.endPlayerTurn();
                
                // Auto-exit after 3 turns
                this.time.delayedCall(3000, () => {
                    abilities.inShell = false;
                    this.gameState.addMessage('🐢 You emerge from your shell.', '#3498db');
                });
            }
            
            useSwimBoost() {
                const abilities = this.gameState.player.getComponent('abilities');
                if (abilities.swimBoostCooldown > 0) {
                    this.gameState.addMessage(`🏊 Swim boost cooling down (${abilities.swimBoostCooldown} turns)`, '#95a5a6');
                    return;
                }
                
                abilities.swimBoosted = true;
                abilities.swimBoostCooldown = 15;
                
                this.gameState.addMessage('🏊 You activate swim boost! No oxygen loss in water for 5 turns.', '#1abc9c');
                
                // Auto-end after 5 turns
                this.time.delayedCall(5000, () => {
                    abilities.swimBoosted = false;
                    this.gameState.addMessage('🏊 Swim boost ends.', '#3498db');
                });
                
                this.endPlayerTurn();
            }
            
            handleTreasureFloor(x, y) {
                // Check if this treasure spot has already been claimed
                const treasureKey = `treasure_${x}_${y}`;
                if (this.gameState.claimedTreasures && this.gameState.claimedTreasures.has(treasureKey)) {
                    this.gameState.addMessage('✨ The golden chamber glistens, but its treasures have been claimed.', '#f39c12');
                    return;
                }
                
                // Initialize claimed treasures set if it doesn't exist
                if (!this.gameState.claimedTreasures) {
                    this.gameState.claimedTreasures = new Set();
                }
                
                // Mark this treasure as claimed
                this.gameState.claimedTreasures.add(treasureKey);
                
                // Generate treasure rewards based on depth
                const depth = this.gameState.currentDepth;
                const numRewards = Math.min(3, Math.max(1, depth)); // 1-3 rewards based on depth
                
                this.gameState.addMessage('💰 You discover precious treasures in the golden chamber!', '#f39c12');
                
                for (let i = 0; i < numRewards; i++) {
                    const rewardType = Math.random();
                    
                    if (rewardType < 0.4) {
                        // Gold (40% chance)
                        const goldAmount = Math.floor((depth + 1) * (50 + Math.random() * 100));
                        this.gameState.player.getComponent('stats').gold += goldAmount;
                        this.gameState.addMessage(`💰 You found ${goldAmount} gold pieces!`, '#f1c40f');
                        
                    } else if (rewardType < 0.7) {
                        // Random item (30% chance)
                        const itemPos = this.findEmptyAdjacentTile(x, y);
                        if (itemPos) {
                            this.generateTreasureItem(itemPos.x, itemPos.y, depth);
                        }
                        
                    } else if (rewardType < 0.9) {
                        // Experience boost (20% chance)
                        const xpBonus = Math.floor(depth * (100 + Math.random() * 200));
                        this.gameState.player.getComponent('stats').experience += xpBonus;
                        this.gameState.addMessage(`⭐ You gain ${xpBonus} experience from ancient knowledge!`, '#9b59b6');
                        this.checkLevelUp();
                        
                    } else {
                        // Rare blessing (10% chance)
                        const blessing = Math.random();
                        if (blessing < 0.33) {
                            // Health blessing
                            const health = this.gameState.player.getComponent('health');
                            health.maxHealth += 5;
                            health.currentHealth = health.maxHealth;
                            this.gameState.addMessage('❤️ The chamber blesses you with vitality! Max health increased!', '#e74c3c');
                        } else if (blessing < 0.66) {
                            // Mana blessing
                            const mana = this.gameState.player.getComponent('mana');
                            mana.maxMana += 10;
                            mana.currentMana = mana.maxMana;
                            this.gameState.addMessage('💙 The chamber blesses you with magical power! Max mana increased!', '#3498db');
                        } else {
                            // Oxygen blessing (for underwater theme)
                            const oxygen = this.gameState.player.getComponent('oxygen');
                            oxygen.maxOxygen += 20;
                            oxygen.currentOxygen = oxygen.maxOxygen;
                            this.gameState.addMessage('🫧 The chamber blesses you with enhanced lung capacity! Max oxygen increased!', '#1abc9c');
                        }
                    }
                }
                
                // Add sparkling particle effect
                this.createTreasureEffect(x, y);
                
                // Achievement check
                this.gameState.stats.treasureRoomsFound++;
                if (this.gameState.stats.treasureRoomsFound >= 3) {
                    this.checkAndUnlockAchievement('treasure_hunter');
                }
                
                // Play treasure sound
                this.playSpatialSound('treasure_found', x, y);
            }
            
            generateTreasureItem(x, y, depth) {
                // Generate a higher quality item than normal
                const itemData = this.generateRandomItem(depth + 2); // Bonus to item quality
                
                // Force better rarity for treasure room items
                if (itemData.rarity === 'common' && Math.random() < 0.6) {
                    itemData.rarity = 'uncommon';
                } else if (itemData.rarity === 'uncommon' && Math.random() < 0.4) {
                    itemData.rarity = 'rare';
                } else if (itemData.rarity === 'rare' && Math.random() < 0.2) {
                    itemData.rarity = 'epic';
                }
                
                this.createItem(x, y, itemData);
                this.gameState.addMessage(`✨ A ${itemData.rarity} ${itemData.name} materializes from the treasure chamber!`, '#e67e22');
            }
            
            findEmptyAdjacentTile(centerX, centerY) {
                const directions = [
                    {x: 0, y: -1}, {x: 1, y: 0}, {x: 0, y: 1}, {x: -1, y: 0},
                    {x: 1, y: -1}, {x: 1, y: 1}, {x: -1, y: 1}, {x: -1, y: -1}
                ];
                
                for (const dir of directions) {
                    const x = centerX + dir.x;
                    const y = centerY + dir.y;
                    
                    if (x >= 0 && x < GAME_CONFIG.MAP_WIDTH && y >= 0 && y < GAME_CONFIG.MAP_HEIGHT) {
                        const tile = this.gameState.gameMap[x][y];
                        const entity = this.getEntityAt(x, y);
                        
                        if ((tile === TILES.FLOOR || tile === TILES.TREASURE_FLOOR) && !entity) {
                            return {x, y};
                        }
                    }
                }
                return null;
            }
            
            createTreasureEffect(x, y) {
                // Create sparkling particle effect
                const worldX = x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE / 2;
                const worldY = y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE / 2;
                
                for (let i = 0; i < 8; i++) {
                    const sparkle = this.add.circle(worldX, worldY, 2, 0xffd700);
                    sparkle.setAlpha(0.8);
                    
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 20 + Math.random() * 10;
                    
                    this.tweens.add({
                        targets: sparkle,
                        x: worldX + Math.cos(angle) * distance,
                        y: worldY + Math.sin(angle) * distance,
                        alpha: 0,
                        duration: 800 + Math.random() * 400,
                        ease: 'Quad.easeOut',
                        onComplete: () => sparkle.destroy()
                    });
                }
            }
            
            handleWait() {
                this.gameState.addMessage('⏸️ You wait and rest...', '#95a5a6');
                
                // Regenerate mana and oxygen
                const mana = this.gameState.player.getComponent('mana');
                const oxygen = this.gameState.player.getComponent('oxygen');
                
                mana.currentMana = Math.min(mana.maxMana, mana.currentMana + 5);
                oxygen.currentOxygen = Math.min(100, oxygen.currentOxygen + 10);
                
                this.endPlayerTurn();
            }
            
            moveEntity(entity, newX, newY) {
                entity.x = newX;
                entity.y = newY;
                
                if (entity.sprite) {
                    entity.sprite.x = newX * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                    entity.sprite.y = newY * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                }
                
                if (entity === this.gameState.player) {
                    this.updateCamera();
                }
            }
            
            getEntityAt(x, y, type = null) {
                return this.gameState.entities.find(entity => 
                    entity.x === x && entity.y === y && (!type || entity.type === type)
                );
            }
            
            combat(attacker, defender) {
                const attackerCombat = attacker.getComponent('combat');
                const defenderHealth = defender.getComponent('health');
                const defenderCombat = defender.getComponent('combat');
                
                // Calculate equipment bonuses
                let attackBonus = 0;
                let defenseBonus = 0;
                
                if (attacker === this.gameState.player) {
                    if (this.gameState.equipment.weapon) {
                        attackBonus += this.gameState.equipment.weapon.bonus;
                    }
                    
                    const abilities = attacker.getComponent('abilities');
                    if (abilities.inShell) {
                        this.gameState.addMessage('🛡️ You cannot attack while in your shell!', '#e74c3c');
                        return;
                    }
                }
                
                if (defender === this.gameState.player) {
                    if (this.gameState.equipment.armor) {
                        defenseBonus += this.gameState.equipment.armor.bonus;
                    }
                    
                    const abilities = defender.getComponent('abilities');
                    if (abilities.inShell) {
                        defenseBonus += 20; // Shell retreat bonus
                    }
                }
                
                const totalAttack = attackerCombat.attackPower + attackBonus;
                const totalDefense = defenderCombat.defense + defenseBonus;
                const damage = Math.max(1, totalAttack - totalDefense);
                
                defenderHealth.currentHealth -= damage;
                
                // Play sound effects and create particle effects
                this.playSimpleSound('sword_hit');
                
                // Create combat particle effects
                this.createCombatEffect(defender.x, defender.y, damage);
                
                // Add modern Phaser FX for combat impact
                this.addCombatFX(defender);
                
                // Show enemy health bar when damaged
                if (defender.type === ENTITY_TYPES.ENEMY && defenderHealth.currentHealth > 0) {
                    this.showEnemyHealthBar(defender);
                }
                
                if (attacker === this.gameState.player) {
                    // Epic player attack messages
                    const defenderName = ENEMY_TYPES[defender.enemyType]?.name || 'enemy';
                    const attackMessages = [
                        `⚔️ Bob's claws slash the ${defenderName} for ${damage} damage!`,
                        `🐢 Bob strikes with turtle fury, dealing ${damage} damage to the ${defenderName}!`,
                        `💥 Bob's shell-powered attack crushes the ${defenderName} for ${damage} damage!`,
                        `⚡ Bob unleashes his Red-Eared Slider rage on the ${defenderName} for ${damage} damage!`
                    ];
                    const randomMessage = attackMessages[Math.floor(Math.random() * attackMessages.length)];
                    this.gameState.addMessage(randomMessage, '#e74c3c');
                } else {
                    // Epic enemy attack messages
                    const attackerName = ENEMY_TYPES[attacker.enemyType]?.name || 'enemy';
                    const enemyAttackMessages = [
                        `💥 The ${attackerName} strikes Bob with deadly force for ${damage} damage!`,
                        `🗡️ The ${attackerName} lashes out, dealing ${damage} damage to Bob!`,
                        `⚔️ The ${attackerName} attacks with primal fury, hitting Bob for ${damage} damage!`,
                        `💀 The ${attackerName} unleashes its wrath on Bob for ${damage} damage!`
                    ];
                    const randomMessage = enemyAttackMessages[Math.floor(Math.random() * enemyAttackMessages.length)];
                    this.gameState.addMessage(randomMessage, '#e74c3c');
                }
                
                if (defenderHealth.currentHealth <= 0) {
                    this.killEntity(defender);
                }
                
                this.updateUI();
            }
            
            killEntity(entity) {
                if (entity === this.gameState.player) {
                    this.gameOver('You have been defeated!');
                    return;
                }
                
                // Killing entity
                
                // Remove from entities list
                const index = this.gameState.entities.indexOf(entity);
                if (index > -1) {
                    this.gameState.entities.splice(index, 1);
                    // Removed entity from list
                }
                
                // Destroy sprite
                if (entity.sprite) {
                    entity.sprite.destroy();
                    // Destroyed sprite for entity
                } else {
                    // No sprite found for entity
                }
                
                // Award experience and track achievements
                if (entity.type === ENTITY_TYPES.ENEMY) {
                    const level = this.gameState.player.getComponent('level');
                    const expGain = (entity.expReward || 25) + (this.gameState.currentDepth * 2); // Bonus XP for deeper levels
                    level.experience += expGain;
                    
                    // Epic victory messages
                    const enemyName = ENEMY_TYPES[entity.enemyType]?.name || 'enemy';
                    const victoryMessages = [
                        `🏆 Bob triumphs! The ${enemyName} is defeated!`,
                        `⚡ Victory! Bob has slain the ${enemyName}!`,
                        `🐢 The ${enemyName} falls before Bob's might!`,
                        `💀 Bob emerges victorious over the ${enemyName}!`,
                        `🎯 Another ${enemyName} bites the dust! Bob reigns supreme!`
                    ];
                    const randomVictory = victoryMessages[Math.floor(Math.random() * victoryMessages.length)];
                    this.gameState.addMessage(randomVictory, '#2ecc71');
                    this.gameState.addMessage(`✨ +${expGain} XP`, '#f39c12');
                    
                    // Update stats and check achievements
                    this.gameState.stats.enemiesKilled++;
                    
                    // Check for first kill achievement
                    if (this.gameState.stats.enemiesKilled === 1) {
                        this.checkAndUnlockAchievement('first_blood');
                    }
                    
                    // Check for boss achievement
                    const enemyType = (entity.enemyType || '').toLowerCase();
                    if (enemyType.includes('kraken') || enemyType.includes('shark') || enemyType.includes('sea monster')) {
                        this.gameState.stats.bossesKilled++;
                        this.checkAndUnlockAchievement('boss_slayer');
                        
                        if (enemyType.includes('kraken')) {
                            this.checkAndUnlockAchievement('kraken_slayer');
                        }
                    }
                    
                    if (level.experience >= level.experienceToNext) {
                        this.levelUp();
                    }
                    
                    // Improved item drop rates
                    const dropChance = 0.35 + (this.gameState.currentDepth * 0.02); // Higher chance at deeper levels
                    if (Math.random() < dropChance) {
                        this.createItem(entity.x, entity.y);
                        this.gameState.addMessage('📦 Enemy dropped an item!', '#2ecc71');
                    }
                    
                    // Auto-save after significant progress
                    if (this.gameState.stats.enemiesKilled % 5 === 0) {
                        this.saveGameProgress();
                    }
                }
            }
            
            levelUp() {
                const level = this.gameState.player.getComponent('level');
                const health = this.gameState.player.getComponent('health');
                const mana = this.gameState.player.getComponent('mana');
                const oxygen = this.gameState.player.getComponent('oxygen');
                const combat = this.gameState.player.getComponent('combat');
                
                // Play level up sound
                this.playSimpleSound('level_up');
                
                level.experience -= level.experienceToNext;
                level.level++;
                level.experienceToNext = level.calculateExpToNext();
                
                // Increase stats
                health.maxHealth += 15;
                health.currentHealth = health.maxHealth;
                mana.maxMana += 8;
                mana.currentMana = mana.maxMana;
                oxygen.maxOxygen += 10;
                oxygen.currentOxygen = oxygen.maxOxygen;
                combat.attackPower += 3;
                combat.defense += 2;
                
                this.gameState.addMessage(`🎉 Level up! You are now level ${level.level}!`, '#f39c12');
                
                // Enhanced level up celebration effects
                this.createLevelUpCelebration(level.level);
            }
            
            createLevelUpCelebration(newLevel) {
                // Golden screen flash with multiple pulses
                this.cameras.main.flash(300, 255, 215, 0);
                
                // Add bloom effect to camera for magical glow
                if (this.cameras.main.postFX) {
                    const bloom = this.cameras.main.postFX.addBloom(0.8, 1, 1, 1, 1.2);
                    this.time.delayedCall(1000, () => {
                        if (bloom) bloom.destroy();
                    });
                }
                
                // Create floating "LEVEL UP!" text
                const playerWorldX = this.gameState.player.x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                const playerWorldY = this.gameState.player.y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                
                const levelUpText = this.add.text(playerWorldX, playerWorldY - 40, 'LEVEL UP!', {
                    fontSize: '32px',
                    color: '#FFD700',
                    fontFamily: 'Arial Black',
                    stroke: '#8B4513',
                    strokeThickness: 4
                });
                levelUpText.setOrigin(0.5);
                levelUpText.setDepth(300);
                
                // Animate level up text with scale and float
                this.tweens.add({
                    targets: levelUpText,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    y: playerWorldY - 80,
                    alpha: 0,
                    duration: 2000,
                    ease: 'Power2',
                    onComplete: () => levelUpText.destroy()
                });
                
                // Create celebration particles around player
                this.createCelebrationParticles(playerWorldX, playerWorldY);
                
                // Camera shake for impact
                this.cameras.main.shake(200, 0.02);
                
                // Show level number with style
                const levelText = this.add.text(playerWorldX, playerWorldY + 20, `${newLevel}`, {
                    fontSize: '48px',
                    color: '#FF6B35',
                    fontFamily: 'Arial Black',
                    stroke: '#000000',
                    strokeThickness: 3
                });
                levelText.setOrigin(0.5);
                levelText.setDepth(300);
                
                this.tweens.add({
                    targets: levelText,
                    scaleX: 2,
                    scaleY: 2,
                    alpha: 0,
                    duration: 1500,
                    ease: 'Back.easeOut',
                    onComplete: () => levelText.destroy()
                });
                
                // Achievement unlock notification if milestone level
                if (newLevel % 5 === 0) {
                    this.time.delayedCall(500, () => {
                        this.gameState.addMessage(`🏆 Milestone reached! Level ${newLevel} Turtle Hero!`, '#FFD700');
                    });
                }
            }
            
            createCelebrationParticles(x, y) {
                // Create golden sparks
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const distance = 30 + Math.random() * 20;
                    const endX = x + Math.cos(angle) * distance;
                    const endY = y + Math.sin(angle) * distance;
                    
                    const particle = this.add.graphics();
                    particle.fillStyle(0xFFD700);
                    particle.fillCircle(0, 0, 3);
                    particle.setPosition(x, y);
                    particle.setDepth(250);
                    
                    this.tweens.add({
                        targets: particle,
                        x: endX,
                        y: endY,
                        alpha: 0,
                        scaleX: 0.1,
                        scaleY: 0.1,
                        duration: 800 + Math.random() * 400,
                        ease: 'Power2',
                        onComplete: () => particle.destroy()
                    });
                }
                
                // Create larger golden rings
                for (let ring = 1; ring <= 3; ring++) {
                    const ringGraphic = this.add.graphics();
                    ringGraphic.lineStyle(3, 0xFFD700, 1);
                    ringGraphic.strokeCircle(0, 0, ring * 15);
                    ringGraphic.setPosition(x, y);
                    ringGraphic.setDepth(200);
                    
                    this.tweens.add({
                        targets: ringGraphic,
                        scaleX: 3,
                        scaleY: 3,
                        alpha: 0,
                        duration: 1000 + ring * 200,
                        ease: 'Power2',
                        onComplete: () => ringGraphic.destroy()
                    });
                }
            }
            
            createCombatEffect(x, y, damage) {
                // Create damage number floating text
                const worldX = x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                const worldY = y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                
                const damageText = this.add.text(worldX, worldY, `-${damage}`, {
                    fontSize: '18px',
                    color: '#ff4444',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 2
                });
                damageText.setOrigin(0.5);
                damageText.setDepth(200);
                
                // Animate damage text
                this.tweens.add({
                    targets: damageText,
                    y: worldY - 30,
                    alpha: 0,
                    duration: 800,
                    ease: 'Power2',
                    onComplete: () => damageText.destroy()
                });
                
                // Create hit particles
                this.createHitParticles(worldX, worldY);
            }
            
            createHitParticles(x, y) {
                // Create particle burst effect
                for (let i = 0; i < 8; i++) {
                    const particle = this.add.circle(x, y, 3, 0xff6b6b);
                    particle.setDepth(150);
                    
                    const angle = (i / 8) * Math.PI * 2;
                    const speed = 50 + Math.random() * 30;
                    const targetX = x + Math.cos(angle) * speed;
                    const targetY = y + Math.sin(angle) * speed;
                    
                    this.tweens.add({
                        targets: particle,
                        x: targetX,
                        y: targetY,
                        alpha: 0,
                        scaleX: 0.1,
                        scaleY: 0.1,
                        duration: 400 + Math.random() * 200,
                        ease: 'Power2',
                        onComplete: () => particle.destroy()
                    });
                }
            }
            
            createBossIntroduction(bossType, bossX, bossY) {
                // Boss data for different types
                const bossData = {
                    seamonster: {
                        name: "🐙 THE ANCIENT SEAMONSTER",
                        description: "A colossal tentacled horror from the abyss. This ancient creature has guarded these depths for centuries, crushing intruders with its massive tentacles.",
                        threat: "Early Boss",
                        abilities: "Tentacle Crush • Ink Cloud • Regeneration"
                    },
                    shark: {
                        name: "🦈 THE CAVE SHARK LEVIATHAN", 
                        description: "A massive prehistoric shark that has evolved to hunt in the darkest depths. Its razor-sharp teeth can tear through any armor.",
                        threat: "Dangerous Boss",
                        abilities: "Blood Frenzy • Lightning Speed • Bone Crusher"
                    },
                    kraken: {
                        name: "🐙 THE DEEP KRAKEN",
                        description: "The ultimate terror of the deep ocean. This legendary creature is said to be older than the ruins themselves, wielding unimaginable power.",
                        threat: "ULTIMATE BOSS",
                        abilities: "Tidal Wave • Crushing Depths • Ancient Magic"
                    }
                };
                
                const boss = bossData[bossType];
                if (!boss) return;
                
                // Store boss spawn info for later
                this.pendingBoss = { type: bossType, x: bossX, y: bossY };
                
                // Show boss introduction overlay
                const overlay = document.getElementById('boss-intro-overlay');
                const nameEl = document.getElementById('boss-name');
                const descEl = document.getElementById('boss-description');
                const statsEl = document.getElementById('boss-stats');
                const readyBtn = document.getElementById('boss-ready-btn');
                
                if (nameEl) nameEl.textContent = boss.name;
                if (descEl) descEl.textContent = boss.description;
                if (statsEl) {
                    statsEl.innerHTML = `
                        <div style="margin: 10px 0;">⚡ Threat Level: <span style="color: #e74c3c;">${boss.threat}</span></div>
                        <div style="margin: 10px 0;">🔥 Abilities: ${boss.abilities}</div>
                        <div style="margin: 15px 0; color: #e67e22;">💀 Defeat this boss to earn massive rewards and advance deeper!</div>
                    `;
                }
                
                // Set up ready button
                if (readyBtn) {
                    readyBtn.onclick = () => this.startBossBattle();
                }
                
                if (overlay) overlay.style.display = 'block';
                
                // Pause the game during introduction
                this.scene.pause();
                
                // Dramatic effects
                this.cameras.main.flash(1000, 100, 0, 0); // Red flash
                this.cameras.main.shake(500, 0.03);
                
                // Play ominous sound
                this.playSimpleSound('level_up');
                
                // Add warning message
                this.gameState.addMessage(`💀 WARNING: ${boss.name} has been spotted ahead!`, '#e74c3c');
            }
            
            startBossBattle() {
                // Hide boss intro overlay
                const overlay = document.getElementById('boss-intro-overlay');
                if (overlay) overlay.style.display = 'none';
                
                // Resume the game
                this.scene.resume();
                
                // Spawn the actual boss
                if (this.pendingBoss) {
                    const { type, x, y } = this.pendingBoss;
                    
                    // Create the boss enemy
                    this.createEnemy(x, y, type);
                    
                    // Epic boss entrance effects
                    this.createMagicEffect(x, y, 'boss');
                    this.cameras.main.shake(800, 0.04);
                    
                    // Special particle effects for boss spawn
                    this.createBossSpawnEffects(x, y);
                    
                    // Boss battle music (if we had different tracks)
                    this.playSimpleSound('achievement_unlock');
                    
                    // Clear pending boss
                    this.pendingBoss = null;
                    
                    // Final warning message
                    this.gameState.addMessage(`⚔️ The battle begins! May Bob's shell protect him!`, '#f39c12');
                }
            }
            
            createBossSpawnEffects(x, y) {
                const worldX = x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                const worldY = y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                
                // Create dramatic lightning-like effects
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const distance = 60 + Math.random() * 40;
                    const endX = worldX + Math.cos(angle) * distance;
                    const endY = worldY + Math.sin(angle) * distance;
                    
                    const lightning = this.add.graphics();
                    lightning.lineStyle(3, 0xFF0000, 1);
                    lightning.lineBetween(worldX, worldY, endX, endY);
                    lightning.setDepth(250);
                    
                    this.tweens.add({
                        targets: lightning,
                        alpha: 0,
                        duration: 300 + Math.random() * 200,
                        ease: 'Power2',
                        onComplete: () => lightning.destroy()
                    });
                }
                
                // Create expanding red warning circles
                for (let ring = 1; ring <= 5; ring++) {
                    const ringGraphic = this.add.graphics();
                    ringGraphic.lineStyle(4, 0xFF0000, 1);
                    ringGraphic.strokeCircle(0, 0, ring * 20);
                    ringGraphic.setPosition(worldX, worldY);
                    ringGraphic.setDepth(200);
                    
                    this.tweens.add({
                        targets: ringGraphic,
                        scaleX: 3,
                        scaleY: 3,
                        alpha: 0,
                        duration: 1000 + ring * 300,
                        ease: 'Power2',
                        onComplete: () => ringGraphic.destroy()
                    });
                }
            }
            
            createFallbackChestTexture() {
                // Create a simple treasure chest graphic as last resort
                if (!this.textures.exists('fallback_chest')) {
                    const graphics = this.add.graphics();
                    graphics.fillStyle(0x8B4513); // Brown
                    graphics.fillRect(0, 0, 32, 32);
                    graphics.fillStyle(0xFFD700); // Gold trim
                    graphics.fillRect(2, 2, 28, 6);
                    graphics.fillRect(2, 24, 28, 6);
                    graphics.fillRect(12, 8, 8, 16);
                    graphics.generateTexture('fallback_chest', 32, 32);
                    graphics.destroy();
                }
            }
            
            createMagicEffect(x, y, effectType = 'heal') {
                const worldX = x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                const worldY = y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                
                // Use professional PixelLab magic effect if available
                const textureKey = this.textures.exists('magic_effect') ? 'magic_effect' : null;
                
                if (textureKey) {
                    const effect = this.add.sprite(worldX, worldY, textureKey);
                    effect.setDepth(180);
                    effect.setScale(1.5);
                    
                    // Pulse and fade effect
                    this.tweens.add({
                        targets: effect,
                        scaleX: 2.0,
                        scaleY: 2.0,
                        alpha: 0,
                        duration: 1000,
                        ease: 'Power2',
                        onComplete: () => effect.destroy()
                    });
                } else {
                    // Fallback particle effect
                    for (let i = 0; i < 12; i++) {
                        const particle = this.add.circle(worldX, worldY, 4, effectType === 'heal' ? 0x2ecc71 : 0x3498db);
                        particle.setDepth(180);
                        
                        const angle = (i / 12) * Math.PI * 2;
                        const radius = 20 + Math.random() * 15;
                        const targetX = worldX + Math.cos(angle) * radius;
                        const targetY = worldY + Math.sin(angle) * radius;
                        
                        this.tweens.add({
                            targets: particle,
                            x: targetX,
                            y: targetY,
                            alpha: 0,
                            scaleX: 0,
                            scaleY: 0,
                            duration: 800,
                            delay: i * 50,
                            ease: 'Power2',
                            onComplete: () => particle.destroy()
                        });
                    }
                }
            }
            
            autoEquipIfBetter(equipment) {
                const currentEquip = this.gameState.equipment[equipment.slot];
                if (!currentEquip || equipment.bonus > currentEquip.bonus) {
                    if (currentEquip) {
                        this.gameState.addMessage(`📤 Unequipped ${currentEquip.name}`, '#95a5a6');
                        this.gameState.addToInventory(currentEquip); // Add old equipment to inventory
                    }
                    this.gameState.equipment[equipment.slot] = equipment;
                    this.gameState.addMessage(`✨ Equipped ${equipment.name}!`, '#f39c12');
                    
                    // Remove from inventory since it's now equipped
                    const index = this.gameState.inventory.findIndex(item => item === equipment);
                    if (index > -1) {
                        this.gameState.inventory.splice(index, 1);
                    }
                    
                    // Apply equipment bonuses
                    this.updateEquipmentBonuses();
                }
            }
            
            updateEquipmentBonuses() {
                // Reset swim boost
                const abilities = this.gameState.player.getComponent('abilities');
                abilities.swimBoosted = false;
                
                // Apply ring effects
                const ring = this.gameState.equipment.ring;
                if (ring && ring.special === 'swim_boost') {
                    abilities.swimBoosted = true;
                    this.gameState.addMessage('🏊 Your pearl ring reduces oxygen consumption!', '#1abc9c');
                }
            }
            
            updatePlayerDirection(dx, dy) {
                if (!this.gameState.player || !this.gameState.player.sprite) return;
                
                let direction = 'south';
                
                if (dx > 0 && dy > 0) direction = 'south_east';
                else if (dx > 0 && dy < 0) direction = 'north_east';
                else if (dx < 0 && dy > 0) direction = 'south_west';
                else if (dx < 0 && dy < 0) direction = 'north_west';
                else if (dx > 0) direction = 'east';
                else if (dx < 0) direction = 'west';
                else if (dy > 0) direction = 'south';
                else if (dy < 0) direction = 'north';
                
                this.gameState.player.sprite.currentDirection = direction;
                
                // Update sprite texture if available
                const textureKey = `bob_${direction}`;
                if (this.textures.exists(textureKey)) {
                    this.gameState.player.sprite.setTexture(textureKey);
                }
            }
            
            endPlayerTurn() {
                this.playerTurn = false;
                this.gameState.nextTurn();
                
                // Update ability cooldowns
                const abilities = this.gameState.player.getComponent('abilities');
                if (abilities.shellRetreatCooldown > 0) abilities.shellRetreatCooldown--;
                if (abilities.swimBoostCooldown > 0) abilities.swimBoostCooldown--;
                
                // Process enemy turns
                this.time.delayedCall(200, () => {
                    this.processEnemyTurns();
                });
            }
            
            processEnemyTurns() {
                const enemies = this.gameState.entities.filter(e => e.type === ENTITY_TYPES.ENEMY);
                // Processing enemy turns
                
                for (const enemy of enemies) {
                    // Processing enemy turn
                    this.processEnemyTurn(enemy);
                }
                
                this.playerTurn = true;
                this.updateUI();
            }
            
            processEnemyTurn(enemy) {
                const ai = enemy.getComponent('ai');
                const player = this.gameState.player;
                
                // Processing enemy AI
                
                // Handle confusion
                if (ai.confused > 0) {
                    ai.confused--;
                    // Move randomly when confused
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    const newX = enemy.x + dir[0];
                    const newY = enemy.y + dir[1];
                    
                    if (newX >= 0 && newX < GAME_CONFIG.MAP_WIDTH && 
                        newY >= 0 && newY < GAME_CONFIG.MAP_HEIGHT &&
                        this.gameState.gameMap[newX][newY] !== TILES.WALL &&
                        this.gameState.gameMap[newX][newY] !== TILES.VOID &&
                        !this.getEntityAt(newX, newY)) {
                        this.moveEntity(enemy, newX, newY);
                    }
                    return;
                }
                
                const distance = Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y);
                
                if (distance === 1) {
                    // Adjacent to player, attack
                    this.combat(enemy, player);
                } else if (distance <= 10) {
                    // Move towards player using simple pathfinding
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    
                    let moveX = 0, moveY = 0;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = dx > 0 ? 1 : -1;
                    } else {
                        moveY = dy > 0 ? 1 : -1;
                    }
                    
                    const newX = enemy.x + moveX;
                    const newY = enemy.y + moveY;
                    
                    // Check if move is valid (fix coordinate order)
                    if (newX >= 0 && newX < GAME_CONFIG.MAP_WIDTH && 
                        newY >= 0 && newY < GAME_CONFIG.MAP_HEIGHT &&
                        this.gameState.gameMap[newX][newY] !== TILES.WALL &&
                        this.gameState.gameMap[newX][newY] !== TILES.VOID &&
                        !this.getEntityAt(newX, newY)) {
                        this.moveEntity(enemy, newX, newY);
                        // Enemy moved
                    } else {
                        // Enemy movement blocked
                    }
                }
            }
            
            createFloorCompletionCelebration(completedDepth) {
                // Calculate completion rewards and bonuses
                const depthBonus = completedDepth * 100;
                const timeBonus = Math.max(50, 300 - (Date.now() - this.gameState.levelStartTime) / 1000);
                const enemyBonus = (this.gameState.stats.enemiesKilled || 0) * 25;
                const totalBonus = Math.floor(depthBonus + timeBonus + enemyBonus);
                
                // Award bonus gold
                this.gameState.gold += totalBonus;
                
                // Flash effect for celebration
                this.cameras.main.flash(500, 100, 255, 100);
                
                // Player position for effects
                const playerWorldX = this.gameState.player.x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                const playerWorldY = this.gameState.player.y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                
                // "FLOOR CLEARED!" text
                const completionText = this.add.text(playerWorldX, playerWorldY - 60, 'FLOOR CLEARED!', {
                    fontSize: '28px',
                    color: '#FFD700',
                    fontFamily: 'Arial Black',
                    stroke: '#8B4513',
                    strokeThickness: 3
                });
                completionText.setOrigin(0.5);
                completionText.setDepth(300);
                
                // Animate completion text
                this.tweens.add({
                    targets: completionText,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    y: playerWorldY - 100,
                    alpha: 0,
                    duration: 3000,
                    ease: 'Power2',
                    onComplete: () => completionText.destroy()
                });
                
                // Bonus summary text
                const bonusText = this.add.text(playerWorldX, playerWorldY + 20, 
                    [
                        `🏆 Depth Bonus: ${depthBonus}g`,
                        `⚡ Speed Bonus: ${Math.floor(timeBonus)}g`,
                        `⚔️ Combat Bonus: ${enemyBonus}g`,
                        `💰 Total Earned: ${totalBonus}g`
                    ].join('\n'), {
                    fontSize: '14px',
                    color: '#3498db',
                    fontFamily: 'Arial',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 2
                });
                bonusText.setOrigin(0.5);
                bonusText.setDepth(300);
                bonusText.setAlpha(0);
                
                // Delayed bonus text animation
                this.time.delayedCall(800, () => {
                    this.tweens.add({
                        targets: bonusText,
                        alpha: 1,
                        duration: 1000,
                        onComplete: () => {
                            this.time.delayedCall(2000, () => {
                                this.tweens.add({
                                    targets: bonusText,
                                    alpha: 0,
                                    duration: 800,
                                    onComplete: () => bonusText.destroy()
                                });
                            });
                        }
                    });
                });
                
                // Sparkle effects around player
                this.createFloorClearSparkles(playerWorldX, playerWorldY);
                
                // Sound effect for completion
                this.playSimpleSound('level_up');
                
                // Camera shake for impact
                this.cameras.main.shake(300, 0.015);
                
                // Add to message log
                this.gameState.addMessage(`🎉 Floor ${completedDepth} cleared! Earned ${totalBonus} gold bonus!`, '#FFD700');
                
                // Special messages for milestone depths
                if (completedDepth % 5 === 0) {
                    this.time.delayedCall(1500, () => {
                        this.gameState.addMessage(`🏆 Milestone! You've cleared ${completedDepth} floors!`, '#ff6b35');
                    });
                }
                
                // Record level start time for next floor
                this.gameState.levelStartTime = Date.now();
            }
            
            createFloorClearSparkles(x, y) {
                // Create celebratory sparkle effects
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const distance = 40 + Math.random() * 30;
                    const endX = x + Math.cos(angle) * distance;
                    const endY = y + Math.sin(angle) * distance;
                    
                    const sparkle = this.add.graphics();
                    sparkle.fillStyle(0x00FFFF);
                    sparkle.fillStar(0, 0, 4, 2, 4);
                    sparkle.setPosition(x, y);
                    sparkle.setDepth(250);
                    
                    this.tweens.add({
                        targets: sparkle,
                        x: endX,
                        y: endY,
                        alpha: 0,
                        scaleX: 0.2,
                        scaleY: 0.2,
                        rotation: Math.PI * 2,
                        duration: 1000 + Math.random() * 500,
                        ease: 'Power2',
                        onComplete: () => sparkle.destroy()
                    });
                }
                
                // Create expanding victory rings
                for (let ring = 1; ring <= 4; ring++) {
                    const ringGraphic = this.add.graphics();
                    ringGraphic.lineStyle(2, 0x00FFFF, 1);
                    ringGraphic.strokeCircle(0, 0, ring * 12);
                    ringGraphic.setPosition(x, y);
                    ringGraphic.setDepth(200);
                    
                    this.tweens.add({
                        targets: ringGraphic,
                        scaleX: 4,
                        scaleY: 4,
                        alpha: 0,
                        duration: 1500 + ring * 150,
                        ease: 'Power2',
                        onComplete: () => ringGraphic.destroy()
                    });
                }
            }
            
            descendStairs() {
                // Floor completion celebration before descending
                this.createFloorCompletionCelebration(this.gameState.currentDepth);
                
                this.gameState.currentDepth++;
                this.gameState.stats.deepestDepth = Math.max(this.gameState.stats.deepestDepth, this.gameState.currentDepth);
                
                this.gameState.addMessage(`🏰 You descend to depth ${this.gameState.currentDepth}!`, '#f39c12');
                
                // Check depth achievements
                if (this.gameState.currentDepth >= 5) {
                    this.checkAndUnlockAchievement('deep_diver');
                }
                if (this.gameState.currentDepth >= 10) {
                    this.checkAndUnlockAchievement('abyss_walker');
                }
                
                // Check for victory condition
                this.checkVictoryCondition();
                
                // Auto-save on level change
                this.saveGameProgress();
                
                // Clear current level entities (except player)
                this.gameState.entities = this.gameState.entities.filter(e => e === this.gameState.player);
                
                // Clear sprites
                this.gameState.entities.forEach(entity => {
                    if (entity.sprite && entity !== this.gameState.player) {
                        entity.sprite.destroy();
                    }
                });
                
                // Generate new level
                this.generateLevel();
                
                // Screen transition effect
                this.cameras.main.fade(300, 0, 0, 0);
                this.cameras.main.once('camerafadeoutcomplete', () => {
                    this.cameras.main.fadeIn(300);
                });
                
                // Change music every 5 floors
                if (this.gameState.currentDepth % 5 === 0) {
                    this.startMusic();
                }
            }
            
            teleportPlayer() {
                let attempts = 0;
                let newX, newY;
                
                do {
                    newX = Math.floor(Math.random() * GAME_CONFIG.MAP_WIDTH);
                    newY = Math.floor(Math.random() * GAME_CONFIG.MAP_HEIGHT);
                    attempts++;
                } while ((this.gameState.gameMap[newX][newY] !== TILES.FLOOR || this.getEntityAt(newX, newY)) && attempts < 100);
                
                if (attempts < 100) {
                    this.moveEntity(this.gameState.player, newX, newY);
                    this.gameState.addMessage('✨ You teleport to a random location!', '#9b59b6');
                }
            }
            
            revealMap() {
                this.gameState.addMessage('🗺️ The dungeon layout is revealed in your mind!', '#3498db');
                // In a real implementation, this would reveal the entire map
            }
            
            confuseEnemies() {
                let confusedCount = 0;
                this.gameState.entities.forEach(entity => {
                    if (entity.type === ENTITY_TYPES.ENEMY) {
                        const ai = entity.getComponent('ai');
                        ai.confused = 5;
                        confusedCount++;
                    }
                });
                
                this.gameState.addMessage(`😵‍💫 ${confusedCount} enemies are confused!`, '#9b59b6');
            }
            
            lightningAttack() {
                let hitCount = 0;
                const player = this.gameState.player;
                
                this.gameState.entities.forEach(entity => {
                    if (entity.type === ENTITY_TYPES.ENEMY) {
                        const distance = Math.abs(entity.x - player.x) + Math.abs(entity.y - player.y);
                        if (distance <= 5) {
                            const health = entity.getComponent('health');
                            health.currentHealth -= 30;
                            hitCount++;
                            
                            if (health.currentHealth <= 0) {
                                this.killEntity(entity);
                            }
                        }
                    }
                });
                
                this.gameState.addMessage(`⚡ Lightning strikes ${hitCount} nearby enemies!`, '#f1c40f');
            }
            
            updateCamera() {
                // Center camera on player
                const playerScreenX = this.gameState.player.x * GAME_CONFIG.TILE_SIZE;
                const playerScreenY = this.gameState.player.y * GAME_CONFIG.TILE_SIZE;
                
                this.cameras.main.centerOn(playerScreenX, playerScreenY);
            }
            
            updateUI() {
                if (!this.gameState.player) return;
                
                const player = this.gameState.player;
                const health = player.getComponent('health');
                const mana = player.getComponent('mana');
                const oxygen = player.getComponent('oxygen');
                const level = player.getComponent('level');
                const abilities = player.getComponent('abilities');
                
                // Update health
                document.getElementById('health-text').textContent = `${health.currentHealth}/${health.maxHealth}`;
                document.getElementById('health-bar').style.width = `${(health.currentHealth / health.maxHealth) * 100}%`;
                
                // Update mana
                document.getElementById('mana-text').textContent = `${mana.currentMana}/${mana.maxMana}`;
                document.getElementById('mana-bar').style.width = `${(mana.currentMana / mana.maxMana) * 100}%`;
                
                // Update oxygen
                document.getElementById('oxygen-text').textContent = `${oxygen.currentOxygen}/${oxygen.maxOxygen}`;
                document.getElementById('oxygen-bar').style.width = `${(oxygen.currentOxygen / oxygen.maxOxygen) * 100}%`;
                
                // Update level
                document.getElementById('level-text').textContent = level.level;
                document.getElementById('exp-text').textContent = `${level.experience}/${level.experienceToNext}`;
                document.getElementById('exp-bar').style.width = `${(level.experience / level.experienceToNext) * 100}%`;
                
                // Update depth and gold
                document.getElementById('depth-text').textContent = this.gameState.currentDepth;
                document.getElementById('gold-text').textContent = this.gameState.gold;
                document.getElementById('turn-text').textContent = this.gameState.turnCount;
                
                // Update minimap occasionally (not every turn for performance)
                if (this.gameState.turnCount % 5 === 0) {
                    this.updateMinimap();
                }
                
                // Update equipment
                document.getElementById('weapon-text').textContent = this.gameState.equipment.weapon ? 
                    `${this.gameState.equipment.weapon.name} (+${this.gameState.equipment.weapon.bonus})` : 'None';
                document.getElementById('armor-text').textContent = this.gameState.equipment.armor ? 
                    `${this.gameState.equipment.armor.name} (+${this.gameState.equipment.armor.bonus})` : 'None';
                document.getElementById('ring-text').textContent = this.gameState.equipment.ring ? 
                    this.gameState.equipment.ring.name : 'None';
                
                // Update ability buttons
                const shellBtn = document.getElementById('shell-retreat-btn');
                const swimBtn = document.getElementById('swim-boost-btn');
                
                shellBtn.disabled = abilities.shellRetreatCooldown > 0 || abilities.inShell;
                swimBtn.disabled = abilities.swimBoostCooldown > 0 || abilities.swimBoosted;
                
                if (abilities.shellRetreatCooldown > 0) {
                    shellBtn.textContent = `🛡️ Shell (${abilities.shellRetreatCooldown})`;
                } else if (abilities.inShell) {
                    shellBtn.textContent = '🛡️ In Shell';
                } else {
                    shellBtn.textContent = '🛡️ Shell Retreat';
                }
                
                if (abilities.swimBoostCooldown > 0) {
                    swimBtn.textContent = `🏊 Swim (${abilities.swimBoostCooldown})`;
                } else if (abilities.swimBoosted) {
                    swimBtn.textContent = '🏊 Boosted';
                } else {
                    swimBtn.textContent = '🏊 Swim Boost';
                }
            }
            
            startMusic() {
                const trackNumber = Math.floor(Math.random() * 28) + 1;
                try {
                    this.sound.stopAll();
                    if (this.sound.get(`music_${trackNumber}`)) {
                        this.sound.play(`music_${trackNumber}`, { 
                            loop: true, 
                            volume: 0.2 
                        });
                    }
                } catch (error) {
                    console.warn('Failed to play music:', error);
                }
            }
            
            gameOver(reason) {
                if (this.gameOverShown) return;
                this.gameOverShown = true;
                
                this.gameState.addMessage(`💀 GAME OVER: ${reason}`, '#e74c3c');
                
                // Stop music
                this.sound.stopAll();
                
                // Calculate final score and survival time
                const timeAlive = Math.floor((Date.now() - this.gameState.gameStartTime) / 1000);
                const score = this.gameState.currentDepth * 1000 + this.gameState.gold * 10 + timeAlive;
                
                // Check survival achievement
                if (timeAlive >= 1800) { // 30 minutes
                    this.checkAndUnlockAchievement('survivor');
                }
                
                // Submit final score to leaderboard
                this.submitFinalScore(score, timeAlive);
                
                // Epic screen shake
                this.cameras.main.shake(800, 0.03);
                
                // Dark overlay
                const overlay = this.add.rectangle(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY, 
                    this.cameras.main.width, 
                    this.cameras.main.height, 
                    0x000000, 
                    0.9
                );
                overlay.setScrollFactor(0);
                overlay.setDepth(1000);
                
                // Enhanced game over screen
                this.createEnhancedGameOverScreen(reason, score, timeAlive);
                
                // Game over
            }
            
            createEnhancedGameOverScreen(reason, score, timeAlive) {
                // Animated game over title with dramatic entrance
                const gameOverText = this.add.text(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY - 200, 
                    '💀 GAME OVER', {
                    fontSize: '72px',
                    color: '#ff0000',
                    fontFamily: 'Arial Black',
                    stroke: '#000000',
                    strokeThickness: 8
                });
                gameOverText.setOrigin(0.5);
                gameOverText.setScrollFactor(0);
                gameOverText.setDepth(1001);
                gameOverText.setAlpha(0);
                gameOverText.setScale(0.5);
                
                // Animate title entrance
                this.tweens.add({
                    targets: gameOverText,
                    alpha: 1,
                    scaleX: 1,
                    scaleY: 1,
                    y: this.cameras.main.centerY - 150,
                    duration: 1000,
                    ease: 'Back.easeOut'
                });
                
                // Reason text
                const reasonText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY - 100,
                    reason, {
                    fontSize: '24px',
                    color: '#ffaaaa',
                    fontFamily: 'Arial',
                    stroke: '#000000',
                    strokeThickness: 2,
                    align: 'center'
                });
                reasonText.setOrigin(0.5);
                reasonText.setScrollFactor(0);
                reasonText.setDepth(1001);
                reasonText.setAlpha(0);
                
                // Animate reason
                this.time.delayedCall(500, () => {
                    this.tweens.add({
                        targets: reasonText,
                        alpha: 1,
                        duration: 800
                    });
                });
                
                // Comprehensive final stats
                const level = this.gameState.player.getComponent('level').level;
                const health = this.gameState.player.getComponent('health');
                const statsText = this.add.text(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY - 20, 
                    [
                        `🏆 Final Score: ${score.toLocaleString()}`,
                        `🏔️ Deepest Depth: ${this.gameState.currentDepth}`,
                        `🐢 Level Reached: ${level}`,
                        `💰 Gold Collected: ${this.gameState.gold}`,
                        `⏱️ Survival Time: ${Math.floor(timeAlive / 60)}m ${timeAlive % 60}s`,
                        `🏥 Max Health: ${health.maxHealth}`,
                        `⚔️ Enemies Defeated: ${this.gameState.stats.enemiesKilled || 0}`,
                        `📦 Items Found: ${this.gameState.stats.itemsFound || 0}`,
                        `🏆 Achievements: ${this.gameState.achievements.length}/10`
                    ].join('\n'), {
                    fontSize: '18px',
                    color: '#ffffff',
                    fontFamily: 'Arial',
                    align: 'center',
                    lineSpacing: 8
                });
                statsText.setOrigin(0.5);
                statsText.setScrollFactor(0);
                statsText.setDepth(1001);
                statsText.setAlpha(0);
                
                // Animate stats
                this.time.delayedCall(1000, () => {
                    this.tweens.add({
                        targets: statsText,
                        alpha: 1,
                        duration: 1000
                    });
                });
                
                // Interactive restart buttons
                const restartText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY + 120,
                    '🔄 Press R to Restart Game', {
                    fontSize: '20px',
                    color: '#3498db',
                    fontFamily: 'Arial Bold',
                    stroke: '#000000',
                    strokeThickness: 2
                });
                restartText.setOrigin(0.5);
                restartText.setScrollFactor(0);
                restartText.setDepth(1001);
                restartText.setAlpha(0);
                
                const menuText = this.add.text(
                    this.cameras.main.centerX,
                    this.cameras.main.centerY + 150,
                    '🏠 Press M for Main Menu', {
                    fontSize: '20px',
                    color: '#95a5a6',
                    fontFamily: 'Arial Bold',
                    stroke: '#000000',
                    strokeThickness: 2
                });
                menuText.setOrigin(0.5);
                menuText.setScrollFactor(0);
                menuText.setDepth(1001);
                menuText.setAlpha(0);
                
                // Animate restart options
                this.time.delayedCall(1500, () => {
                    this.tweens.add({
                        targets: [restartText, menuText],
                        alpha: 1,
                        duration: 800
                    });
                    
                    // Pulsing effect for restart button
                    this.tweens.add({
                        targets: restartText,
                        scaleX: 1.1,
                        scaleY: 1.1,
                        duration: 1000,
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                });
                
                // Input handlers
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
                
                this.input.keyboard.on('keydown-M', () => {
                    // Go to main menu
                    if (window.game) {
                        window.game.destroy(true);
                        window.game = null;
                    }
                    if (window.mainMenu) {
                        window.mainMenu.showMainMenu();
                    }
                });
            }
            
            async submitFinalScore(score, timeAlive) {
                try {
                    if (!this.gameState.player) return;
                    
                    const levelComp = this.gameState.player.getComponent('level');
                    const level = levelComp ? levelComp.level : 1;
                    
                    const result = await dbManager.submitScore(
                        score, 
                        this.gameState.currentDepth, 
                        level, 
                        timeAlive
                    );
                    
                    if (result.success) {
                        const rank = result.rank;
                        if (rank <= 10) {
                            this.gameState.addMessage(`🏆 NEW HIGH SCORE! Rank #${rank} on global leaderboard!`, '#f1c40f');
                        } else {
                            this.gameState.addMessage(`📊 Score submitted! Global rank: #${rank}`, '#3498db');
                        }
                    }
                } catch (error) {
                    console.error('Failed to submit score:', error);
                }
            }
            
            // Victory condition - if they reach depth 20, they "win"
            checkVictoryCondition() {
                if (this.gameState.currentDepth >= 20) {
                    this.gameVictory();
                }
            }
            
            gameVictory() {
                if (this.gameOverShown) return;
                this.gameOverShown = true;
                
                this.gameState.addMessage(`🏆 VICTORY! You've conquered the deepest turtle dungeon depths!`, '#f1c40f');
                
                // Stop music
                this.sound.stopAll();
                
                // Calculate victory bonus score
                const timeAlive = Math.floor((Date.now() - this.gameState.gameStartTime) / 1000);
                const victoryBonus = 10000; // Big bonus for winning
                const score = this.gameState.currentDepth * 1000 + this.gameState.gold * 10 + timeAlive + victoryBonus;
                
                // Ultimate achievement
                this.checkAndUnlockAchievement('turtle_master');
                
                // Submit victory score
                this.submitFinalScore(score, timeAlive);
                
                // Epic celebration effect
                this.cameras.main.shake(1000, 0.05);
                this.createMagicEffect(this.gameState.player.x, this.gameState.player.y, 'victory');
                
                // Victory overlay
                const overlay = this.add.rectangle(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY, 
                    this.cameras.main.width, 
                    this.cameras.main.height, 
                    0xf1c40f, 
                    0.8
                );
                overlay.setScrollFactor(0);
                overlay.setDepth(1000);
                
                // Victory text
                const victoryText = this.add.text(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY - 100, 
                    '🏆 VICTORY! 🏆', {
                    fontSize: '64px',
                    color: '#2c3e50',
                    fontFamily: 'Courier New',
                    stroke: '#ffffff',
                    strokeThickness: 6
                });
                victoryText.setOrigin(0.5);
                victoryText.setScrollFactor(0);
                victoryText.setDepth(1001);
                
                // Victory stats
                const levelComp = this.gameState.player.getComponent('level');
                const statsText = this.add.text(
                    this.cameras.main.centerX, 
                    this.cameras.main.centerY, 
                    [
                        `🐢 Bob the Red-Eared Slider Conquers All!`,
                        `Final Score: ${score}`,
                        `Depth Reached: ${this.gameState.currentDepth}`,
                        `Level: ${levelComp ? levelComp.level : 1}`,
                        `Enemies Defeated: ${this.gameState.stats.enemiesKilled}`,
                        `Time Survived: ${Math.floor(timeAlive / 60)}m ${timeAlive % 60}s`,
                        `Gold Collected: ${this.gameState.gold}`,
                        '',
                        '🎮 Press R to play again'
                    ].join('\n'), {
                    fontSize: '20px',
                    color: '#2c3e50',
                    fontFamily: 'Courier New',
                    align: 'center'
                });
                statsText.setOrigin(0.5);
                statsText.setScrollFactor(0);
                statsText.setDepth(1001);
                
                // Restart functionality
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
                
                // Victory achieved
            }
        }
        
        // Game configuration
        const gameConfig = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            backgroundColor: '#1a1a1a',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            render: {
                antialias: false,
                pixelArt: true,
                roundPixels: true
            },
            fps: {
                target: 60
            },
            scene: CompleteRoguelikeScene
        };
        
            // Start the complete game
            gameInstance = new Phaser.Game(gameConfig);
            window.game = gameInstance;
            window.gameInstance = gameInstance; // Make available globally for UI buttons
            // Game ready to play
        }
        
        // Make main menu globally accessible
        window.mainMenu = null;
        window.addEventListener('load', function() {
            window.mainMenu = mainMenu;
            // Main menu is now ready
        });
    </script>
</body>
</html>
