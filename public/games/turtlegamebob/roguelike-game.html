<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê¢ Bob The Turtle: Hero Of Turtle Dungeon Depths - Roguelike Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #2c3e50 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
            border: 2px solid #34495e;
        }
        
        /* Game UI */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #game-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            border: 2px solid #34495e;
            pointer-events: auto;
        }
        
        #inventory-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            border: 2px solid #34495e;
            pointer-events: auto;
        }
        
        #message-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            border: 2px solid #34495e;
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .stat-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            display: inline-block;
            margin-left: 5px;
        }
        
        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .health-fill { background: #e74c3c; }
        .mana-fill { background: #3498db; }
        .exp-fill { background: #f39c12; }
        
        @media (max-width: 768px) {
            #game-stats, #inventory-panel {
                font-size: 11px;
                padding: 10px;
            }
            #message-log {
                height: 80px;
                font-size: 10px;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rot-js@2.2.0/dist/rot.min.js"></script>
</head>
<body>
    <!-- Game UI Overlay -->
    <div id="ui-overlay">
        <div id="game-stats">
            <div><strong>üê¢ Bob The Turtle</strong></div>
            <div>‚ù§Ô∏è Health: <span id="health-text">100/100</span><div class="stat-bar"><div class="stat-fill health-fill" id="health-bar"></div></div></div>
            <div>üíô Mana: <span id="mana-text">50/50</span><div class="stat-bar"><div class="stat-fill mana-fill" id="mana-bar"></div></div></div>
            <div>‚≠ê Level: <span id="level-text">1</span></div>
            <div>üèÜ EXP: <span id="exp-text">0/100</span><div class="stat-bar"><div class="stat-fill exp-fill" id="exp-bar"></div></div></div>
            <div>üè∞ Depth: <span id="depth-text">1</span></div>
            <div>üéØ Turn: <span id="turn-text">1</span></div>
        </div>
        
        <div id="inventory-panel">
            <div><strong>üéí Inventory</strong></div>
            <div id="equipped-items">
                <div>‚öîÔ∏è Weapon: <span id="weapon-text">Shell Claw</span></div>
                <div>üõ°Ô∏è Armor: <span id="armor-text">Turtle Shell</span></div>
                <div>üíç Ring: <span id="ring-text">None</span></div>
            </div>
            <div style="margin-top: 10px;"><strong>üì¶ Items:</strong></div>
            <div id="inventory-items" style="max-height: 200px; overflow-y: auto;">
                <!-- Items will be populated by JavaScript -->
            </div>
        </div>
        
        <div id="message-log">
            <div id="messages">
                <div style="color: #3498db;">üê¢ Welcome to the Turtle Dungeon Depths!</div>
                <div style="color: #2ecc71;">Move with arrow keys or click. Press SPACE for special actions.</div>
                <div style="color: #f39c12;">Find the stairs to descend deeper into the dungeon!</div>
            </div>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <script>
        // INDUSTRY STANDARD ROGUELIKE IMPLEMENTATION
        // Using ROT.js (industry standard roguelike library) + Phaser
        
        // Game constants
        const GAME_CONFIG = {
            TILE_SIZE: 32,
            MAP_WIDTH: 40,
            MAP_HEIGHT: 25,
            VIEWPORT_WIDTH: 21,
            VIEWPORT_HEIGHT: 15
        };
        
        // Tile types
        const TILES = {
            FLOOR: 0,
            WALL: 1,
            DOOR: 2,
            STAIRS_DOWN: 3,
            WATER: 4,
            DEEP_WATER: 5
        };
        
        // Entity types
        const ENTITY_TYPES = {
            PLAYER: 'player',
            ENEMY: 'enemy',
            ITEM: 'item',
            STAIRS: 'stairs'
        };
        
        // Item types for inventory system
        const ITEM_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            RING: 'ring',
            POTION: 'potion',
            SCROLL: 'scroll',
            FOOD: 'food',
            TREASURE: 'treasure'
        };
        
        // Game state manager (industry standard pattern)
        class GameState {
            constructor() {
                this.currentDepth = 1;
                this.turnCount = 1;
                this.gameMap = null;
                this.player = null;
                this.entities = [];
                this.messageLog = [];
                this.inventory = [];
                this.equipment = {
                    weapon: null,
                    armor: null,
                    ring: null
                };
            }
            
            addMessage(text, color = '#ffffff') {
                this.messageLog.push({ text, color, turn: this.turnCount });
                this.updateMessageDisplay();
                
                // Keep only last 50 messages for performance
                if (this.messageLog.length > 50) {
                    this.messageLog = this.messageLog.slice(-50);
                }
            }
            
            updateMessageDisplay() {
                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = this.messageLog.slice(-10).map(msg => 
                    `<div style="color: ${msg.color};">${msg.text}</div>`
                ).join('');
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            nextTurn() {
                this.turnCount++;
                document.getElementById('turn-text').textContent = this.turnCount;
            }
        }
        
        // Entity component system (industry standard ECS pattern)
        class Entity {
            constructor(x, y, type, sprite = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.sprite = sprite;
                this.components = {};
            }
            
            addComponent(name, component) {
                this.components[name] = component;
                return this;
            }
            
            getComponent(name) {
                return this.components[name];
            }
            
            hasComponent(name) {
                return name in this.components;
            }
        }
        
        // Component classes (industry standard)
        class HealthComponent {
            constructor(maxHealth, currentHealth = null) {
                this.maxHealth = maxHealth;
                this.currentHealth = currentHealth || maxHealth;
            }
        }
        
        class ManaComponent {
            constructor(maxMana, currentMana = null) {
                this.maxMana = maxMana;
                this.currentMana = currentMana || maxMana;
            }
        }
        
        class CombatComponent {
            constructor(attackPower, defense) {
                this.attackPower = attackPower;
                this.defense = defense;
            }
        }
        
        class LevelComponent {
            constructor(level = 1, experience = 0) {
                this.level = level;
                this.experience = experience;
                this.experienceToNext = this.calculateExpToNext();
            }
            
            calculateExpToNext() {
                return Math.floor(100 * Math.pow(1.2, this.level - 1));
            }
        }
        
        class InventoryComponent {
            constructor(capacity = 20) {
                this.items = [];
                this.capacity = capacity;
            }
            
            addItem(item) {
                if (this.items.length < this.capacity) {
                    this.items.push(item);
                    return true;
                }
                return false;
            }
            
            removeItem(item) {
                const index = this.items.indexOf(item);
                if (index > -1) {
                    this.items.splice(index, 1);
                    return true;
                }
                return false;
            }
        }
        
        class AIComponent {
            constructor(type = 'hostile') {
                this.type = type;
                this.target = null;
                this.lastKnownPlayerPos = null;
            }
        }
        
        // Map generation using ROT.js (industry standard)
        class DungeonGenerator {
            static generateMap(width, height, depth) {
                const map = new Array(width);
                for (let i = 0; i < width; i++) {
                    map[i] = new Array(height).fill(TILES.WALL);
                }
                
                // Use ROT.js Cellular Automata for organic cave-like dungeons
                const cellularMap = new ROT.Map.Cellular(width, height);
                cellularMap.randomize(0.5);
                
                // Generate cellular automata
                for (let i = 0; i < 5; i++) {
                    cellularMap.create();
                }
                
                cellularMap.create((x, y, value) => {
                    map[x][y] = value ? TILES.WALL : TILES.FLOOR;
                });
                
                // Add water features for turtle theme
                this.addWaterFeatures(map, width, height, depth);
                
                // Ensure connectivity using ROT.js pathfinding
                this.ensureConnectivity(map, width, height);
                
                return map;
            }
            
            static addWaterFeatures(map, width, height, depth) {
                // Add water pools (more on deeper levels)
                const waterPools = Math.floor(depth / 2) + 2;
                
                for (let i = 0; i < waterPools; i++) {
                    const centerX = Math.floor(Math.random() * (width - 10)) + 5;
                    const centerY = Math.floor(Math.random() * (height - 10)) + 5;
                    const radius = Math.floor(Math.random() * 3) + 2;
                    
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const x = centerX + dx;
                            const y = centerY + dy;
                            
                            if (x >= 0 && x < width && y >= 0 && y < height) {
                                if (distance <= radius && map[x][y] === TILES.FLOOR) {
                                    map[x][y] = distance < radius - 1 ? TILES.DEEP_WATER : TILES.WATER;
                                }
                            }
                        }
                    }
                }
            }
            
            static ensureConnectivity(map, width, height) {
                // Use ROT.js pathfinding to ensure all floor tiles are connected
                const passableCallback = (x, y) => {
                    return map[x] && map[x][y] === TILES.FLOOR;
                };
                
                // Find all floor tiles
                const floorTiles = [];
                for (let x = 0; x < width; x++) {
                    for (let y = 0; y < height; y++) {
                        if (map[x][y] === TILES.FLOOR) {
                            floorTiles.push({x, y});
                        }
                    }
                }
                
                if (floorTiles.length < 2) return;
                
                // Use dijkstra to find unreachable areas
                const dijkstra = new ROT.Path.Dijkstra(floorTiles[0].x, floorTiles[0].y, passableCallback);
                const reachable = new Set();
                
                dijkstra.compute(floorTiles[0].x, floorTiles[0].y, (x, y) => {
                    reachable.add(`${x},${y}`);
                });
                
                // Connect unreachable areas
                for (const tile of floorTiles) {
                    if (!reachable.has(`${tile.x},${tile.y}`)) {
                        this.connectTileToReachable(map, tile, reachable, width, height);
                    }
                }
            }
            
            static connectTileToReachable(map, tile, reachable, width, height) {
                // Simple corridor carving to connect isolated areas
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                let current = {x: tile.x, y: tile.y};
                
                while (!reachable.has(`${current.x},${current.y}`)) {
                    // Carve towards the nearest reachable tile
                    let bestDir = directions[0];
                    let bestDistance = Infinity;
                    
                    for (const dir of directions) {
                        const newX = current.x + dir[0];
                        const newY = current.y + dir[1];
                        
                        if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                            // Simple distance check to move towards center
                            const distance = Math.abs(newX - width/2) + Math.abs(newY - height/2);
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                bestDir = dir;
                            }
                        }
                    }
                    
                    current.x += bestDir[0];
                    current.y += bestDir[1];
                    
                    if (current.x >= 0 && current.x < width && current.y >= 0 && current.y < height) {
                        map[current.x][current.y] = TILES.FLOOR;
                    }
                    
                    // Safety break
                    if (Math.abs(current.x - tile.x) + Math.abs(current.y - tile.y) > 50) break;
                }
            }
            
            static placeStairs(map, width, height) {
                // Find a good spot for stairs (far from edges)
                const candidates = [];
                for (let x = 5; x < width - 5; x++) {
                    for (let y = 5; y < height - 5; y++) {
                        if (map[x][y] === TILES.FLOOR) {
                            candidates.push({x, y});
                        }
                    }
                }
                
                if (candidates.length > 0) {
                    const stairs = candidates[Math.floor(Math.random() * candidates.length)];
                    map[stairs.x][stairs.y] = TILES.STAIRS_DOWN;
                    return stairs;
                }
                
                return null;
            }
        }
        
        // Main game scene using Phaser + ROT.js
        class RoguelikeScene extends Phaser.Scene {
            constructor() {
                super({ key: 'RoguelikeScene' });
                this.gameState = new GameState();
                this.cameraOffsetX = 0;
                this.cameraOffsetY = 0;
                this.tileSprites = [];
                this.entitySprites = [];
                this.playerTurn = true;
            }
            
            preload() {
                console.log('üé® Loading roguelike assets...');
                
                // Create placeholder tiles
                this.createTileTextures();
                
                // Load our existing PixelLab assets
                this.load.image('hero_south', 'assets/sprites/green_turtle/rotations/south.png');
                this.load.image('hero_north', 'assets/sprites/green_turtle/rotations/north.png');
                this.load.image('hero_east', 'assets/sprites/green_turtle/rotations/east.png');
                this.load.image('hero_west', 'assets/sprites/green_turtle/rotations/west.png');
                
                this.load.image('enemy_south', 'assets/sprites/enemies/rotations/south.png');
                this.load.image('enemy_north', 'assets/sprites/enemies/rotations/north.png');
                this.load.image('enemy_east', 'assets/sprites/enemies/rotations/east.png');
                this.load.image('enemy_west', 'assets/sprites/enemies/rotations/west.png');
                
                // Load music
                for (let i = 1; i <= 28; i++) {
                    this.load.audio(`music_${i}`, `assets/music/${i}.mp3`);
                }
                
                // Handle load errors gracefully
                this.load.on('loaderror', (file) => {
                    console.warn(`Failed to load: ${file.key}`);
                });
            }
            
            createTileTextures() {
                const graphics = this.add.graphics();
                
                // Floor tile (sandy/underwater floor)
                graphics.fillStyle(0x8B7355);
                graphics.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                graphics.generateTexture('tile_floor', GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                
                // Wall tile (rock/coral)
                graphics.clear();
                graphics.fillStyle(0x4A4A4A);
                graphics.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                graphics.fillStyle(0x6A6A6A);
                graphics.fillRect(2, 2, GAME_CONFIG.TILE_SIZE-4, GAME_CONFIG.TILE_SIZE-4);
                graphics.generateTexture('tile_wall', GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                
                // Water tile (shallow)
                graphics.clear();
                graphics.fillStyle(0x3498DB);
                graphics.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                graphics.fillStyle(0x5DADE2);
                graphics.fillCircle(GAME_CONFIG.TILE_SIZE/2, GAME_CONFIG.TILE_SIZE/2, GAME_CONFIG.TILE_SIZE/3);
                graphics.generateTexture('tile_water', GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                
                // Deep water tile
                graphics.clear();
                graphics.fillStyle(0x2980B9);
                graphics.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                graphics.generateTexture('tile_deep_water', GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                
                // Stairs down
                graphics.clear();
                graphics.fillStyle(0x8B7355);
                graphics.fillRect(0, 0, GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                graphics.fillStyle(0x2C3E50);
                graphics.fillRect(8, 8, 16, 16);
                graphics.fillStyle(0xF39C12);
                graphics.fillRect(10, 10, 12, 12);
                graphics.generateTexture('tile_stairs', GAME_CONFIG.TILE_SIZE, GAME_CONFIG.TILE_SIZE);
                
                graphics.destroy();
            }
            
            create() {
                console.log('üéÆ Creating roguelike game...');
                
                // Generate first level
                this.generateLevel();
                
                // Set up input
                this.setupInput();
                
                // Start music
                this.startMusic();
                
                // Initial UI update
                this.updateUI();
                
                this.gameState.addMessage('üê¢ Bob The Turtle awakens in the dungeon depths!', '#3498db');
            }
            
            generateLevel() {
                // Generate map using ROT.js
                this.gameState.gameMap = DungeonGenerator.generateMap(
                    GAME_CONFIG.MAP_WIDTH, 
                    GAME_CONFIG.MAP_HEIGHT, 
                    this.gameState.currentDepth
                );
                
                // Place stairs
                const stairsPos = DungeonGenerator.placeStairs(
                    this.gameState.gameMap, 
                    GAME_CONFIG.MAP_WIDTH, 
                    GAME_CONFIG.MAP_HEIGHT
                );
                
                // Find player spawn position
                const playerPos = this.findSpawnPosition();
                
                // Create player entity
                this.createPlayer(playerPos.x, playerPos.y);
                
                // Spawn enemies
                this.spawnEnemies();
                
                // Create visual representation
                this.renderMap();
                
                console.log(`üè∞ Generated level ${this.gameState.currentDepth}`);
            }
            
            findSpawnPosition() {
                // Find a good spawn position away from walls
                for (let attempt = 0; attempt < 100; attempt++) {
                    const x = Math.floor(Math.random() * GAME_CONFIG.MAP_WIDTH);
                    const y = Math.floor(Math.random() * GAME_CONFIG.MAP_HEIGHT);
                    
                    if (this.gameState.gameMap[x][y] === TILES.FLOOR) {
                        return {x, y};
                    }
                }
                
                // Fallback: find any floor tile
                for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
                    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
                        if (this.gameState.gameMap[x][y] === TILES.FLOOR) {
                            return {x, y};
                        }
                    }
                }
                
                return {x: 10, y: 10}; // Emergency fallback
            }
            
            createPlayer(x, y) {
                const textureKey = this.textures.exists('hero_south') ? 'hero_south' : 'hero_south_placeholder';
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(0.8);
                sprite.setDepth(100);
                
                this.gameState.player = new Entity(x, y, ENTITY_TYPES.PLAYER, sprite)
                    .addComponent('health', new HealthComponent(100))
                    .addComponent('mana', new ManaComponent(50))
                    .addComponent('combat', new CombatComponent(15, 10))
                    .addComponent('level', new LevelComponent())
                    .addComponent('inventory', new InventoryComponent());
                
                this.gameState.entities.push(this.gameState.player);
                
                // Center camera on player
                this.updateCamera();
            }
            
            spawnEnemies() {
                const enemyCount = Math.min(3 + this.gameState.currentDepth, 8);
                
                for (let i = 0; i < enemyCount; i++) {
                    const pos = this.findSpawnPosition();
                    
                    // Don't spawn too close to player
                    const distance = Math.abs(pos.x - this.gameState.player.x) + Math.abs(pos.y - this.gameState.player.y);
                    if (distance < 5) continue;
                    
                    this.createEnemy(pos.x, pos.y);
                }
            }
            
            createEnemy(x, y) {
                const textureKey = this.textures.exists('enemy_south') ? 'enemy_south' : 'enemy_south_placeholder';
                const sprite = this.add.sprite(
                    x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                    textureKey
                );
                sprite.setScale(0.7);
                sprite.setDepth(90);
                
                const enemy = new Entity(x, y, ENTITY_TYPES.ENEMY, sprite)
                    .addComponent('health', new HealthComponent(20 + this.gameState.currentDepth * 5))
                    .addComponent('combat', new CombatComponent(8 + this.gameState.currentDepth * 2, 5))
                    .addComponent('ai', new AIComponent('hostile'));
                
                this.gameState.entities.push(enemy);
            }
            
            renderMap() {
                // Clear existing tiles
                this.tileSprites.forEach(sprite => sprite.destroy());
                this.tileSprites = [];
                
                // Render visible portion of map
                for (let x = 0; x < GAME_CONFIG.MAP_WIDTH; x++) {
                    for (let y = 0; y < GAME_CONFIG.MAP_HEIGHT; y++) {
                        const tileType = this.gameState.gameMap[x][y];
                        let textureKey = 'tile_floor';
                        
                        switch (tileType) {
                            case TILES.WALL:
                                textureKey = 'tile_wall';
                                break;
                            case TILES.WATER:
                                textureKey = 'tile_water';
                                break;
                            case TILES.DEEP_WATER:
                                textureKey = 'tile_deep_water';
                                break;
                            case TILES.STAIRS_DOWN:
                                textureKey = 'tile_stairs';
                                break;
                        }
                        
                        const sprite = this.add.sprite(
                            x * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            y * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2,
                            textureKey
                        );
                        sprite.setDepth(1);
                        this.tileSprites.push(sprite);
                    }
                }
            }
            
            setupInput() {
                // Keyboard input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasdKeys = this.input.keyboard.addKeys('W,S,A,D,SPACE');
                
                // Mouse/touch input for mobile
                this.input.on('pointerdown', (pointer) => {
                    if (!this.playerTurn) return;
                    
                    const worldX = pointer.worldX;
                    const worldY = pointer.worldY;
                    const tileX = Math.floor(worldX / GAME_CONFIG.TILE_SIZE);
                    const tileY = Math.floor(worldY / GAME_CONFIG.TILE_SIZE);
                    
                    this.handleMovement(tileX - this.gameState.player.x, tileY - this.gameState.player.y);
                });
            }
            
            update() {
                if (!this.playerTurn) return;
                
                // Handle keyboard input
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.W)) {
                    this.handleMovement(0, -1);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.down) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.S)) {
                    this.handleMovement(0, 1);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.left) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.A)) {
                    this.handleMovement(-1, 0);
                } else if (Phaser.Input.Keyboard.JustDown(this.cursors.right) || Phaser.Input.Keyboard.JustDown(this.wasdKeys.D)) {
                    this.handleMovement(1, 0);
                } else if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.SPACE)) {
                    this.handleWait();
                }
            }
            
            handleMovement(dx, dy) {
                const newX = this.gameState.player.x + dx;
                const newY = this.gameState.player.y + dy;
                
                // Check bounds
                if (newX < 0 || newX >= GAME_CONFIG.MAP_WIDTH || newY < 0 || newY >= GAME_CONFIG.MAP_HEIGHT) {
                    return;
                }
                
                // Check if position is passable
                const tileType = this.gameState.gameMap[newX][newY];
                if (tileType === TILES.WALL) {
                    this.gameState.addMessage('üö´ You bump into the wall.', '#e74c3c');
                    return;
                }
                
                // Check for enemies
                const enemy = this.getEntityAt(newX, newY, ENTITY_TYPES.ENEMY);
                if (enemy) {
                    this.combat(this.gameState.player, enemy);
                    this.endPlayerTurn();
                    return;
                }
                
                // Move player
                this.moveEntity(this.gameState.player, newX, newY);
                
                // Check for stairs
                if (tileType === TILES.STAIRS_DOWN) {
                    this.descendStairs();
                }
                
                // Handle water effects
                if (tileType === TILES.WATER) {
                    this.gameState.addMessage('üíß You wade through shallow water.', '#3498db');
                } else if (tileType === TILES.DEEP_WATER) {
                    this.gameState.addMessage('üåä You swim through deep water!', '#2980b9');
                    // Could add oxygen mechanics here later
                }
                
                this.endPlayerTurn();
            }
            
            handleWait() {
                this.gameState.addMessage('‚è∏Ô∏è You wait and rest...', '#95a5a6');
                
                // Regenerate a bit of mana
                const mana = this.gameState.player.getComponent('mana');
                if (mana.currentMana < mana.maxMana) {
                    mana.currentMana = Math.min(mana.maxMana, mana.currentMana + 2);
                }
                
                this.endPlayerTurn();
            }
            
            moveEntity(entity, newX, newY) {
                entity.x = newX;
                entity.y = newY;
                
                if (entity.sprite) {
                    entity.sprite.x = newX * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                    entity.sprite.y = newY * GAME_CONFIG.TILE_SIZE + GAME_CONFIG.TILE_SIZE/2;
                }
                
                if (entity === this.gameState.player) {
                    this.updateCamera();
                }
            }
            
            getEntityAt(x, y, type = null) {
                return this.gameState.entities.find(entity => 
                    entity.x === x && entity.y === y && (!type || entity.type === type)
                );
            }
            
            combat(attacker, defender) {
                const attackerCombat = attacker.getComponent('combat');
                const defenderHealth = defender.getComponent('health');
                const defenderCombat = defender.getComponent('combat');
                
                const damage = Math.max(1, attackerCombat.attackPower - defenderCombat.defense);
                defenderHealth.currentHealth -= damage;
                
                if (attacker === this.gameState.player) {
                    this.gameState.addMessage(`‚öîÔ∏è You attack for ${damage} damage!`, '#e74c3c');
                } else {
                    this.gameState.addMessage(`üí• The enemy attacks you for ${damage} damage!`, '#e74c3c');
                }
                
                if (defenderHealth.currentHealth <= 0) {
                    this.killEntity(defender);
                }
                
                this.updateUI();
            }
            
            killEntity(entity) {
                if (entity === this.gameState.player) {
                    this.gameOver();
                    return;
                }
                
                // Remove from entities list
                const index = this.gameState.entities.indexOf(entity);
                if (index > -1) {
                    this.gameState.entities.splice(index, 1);
                }
                
                // Destroy sprite
                if (entity.sprite) {
                    entity.sprite.destroy();
                }
                
                // Award experience
                if (entity.type === ENTITY_TYPES.ENEMY) {
                    const level = this.gameState.player.getComponent('level');
                    level.experience += 25;
                    
                    if (level.experience >= level.experienceToNext) {
                        this.levelUp();
                    }
                    
                    this.gameState.addMessage('üíÄ Enemy defeated! +25 XP', '#f39c12');
                }
            }
            
            levelUp() {
                const level = this.gameState.player.getComponent('level');
                const health = this.gameState.player.getComponent('health');
                const mana = this.gameState.player.getComponent('mana');
                const combat = this.gameState.player.getComponent('combat');
                
                level.experience -= level.experienceToNext;
                level.level++;
                level.experienceToNext = level.calculateExpToNext();
                
                // Increase stats
                health.maxHealth += 15;
                health.currentHealth = health.maxHealth;
                mana.maxMana += 8;
                mana.currentMana = mana.maxMana;
                combat.attackPower += 3;
                combat.defense += 2;
                
                this.gameState.addMessage(`üéâ Level up! You are now level ${level.level}!`, '#f39c12');
                
                // Screen flash effect
                this.cameras.main.flash(300, 255, 215, 0);
            }
            
            endPlayerTurn() {
                this.playerTurn = false;
                this.gameState.nextTurn();
                
                // Process enemy turns
                this.time.delayedCall(200, () => {
                    this.processEnemyTurns();
                });
            }
            
            processEnemyTurns() {
                const enemies = this.gameState.entities.filter(e => e.type === ENTITY_TYPES.ENEMY);
                
                for (const enemy of enemies) {
                    this.processEnemyTurn(enemy);
                }
                
                this.playerTurn = true;
                this.updateUI();
            }
            
            processEnemyTurn(enemy) {
                const ai = enemy.getComponent('ai');
                const player = this.gameState.player;
                
                // Simple AI: move towards player if in range
                const distance = Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y);
                
                if (distance === 1) {
                    // Adjacent to player, attack
                    this.combat(enemy, player);
                } else if (distance <= 8) {
                    // Move towards player using simple pathfinding
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    
                    let moveX = 0, moveY = 0;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = dx > 0 ? 1 : -1;
                    } else {
                        moveY = dy > 0 ? 1 : -1;
                    }
                    
                    const newX = enemy.x + moveX;
                    const newY = enemy.y + moveY;
                    
                    // Check if move is valid
                    if (newX >= 0 && newX < GAME_CONFIG.MAP_WIDTH && 
                        newY >= 0 && newY < GAME_CONFIG.MAP_HEIGHT &&
                        this.gameState.gameMap[newX][newY] !== TILES.WALL &&
                        !this.getEntityAt(newX, newY)) {
                        this.moveEntity(enemy, newX, newY);
                    }
                }
            }
            
            descendStairs() {
                this.gameState.currentDepth++;
                this.gameState.addMessage(`üè∞ You descend to depth ${this.gameState.currentDepth}!`, '#f39c12');
                
                // Clear current level
                this.gameState.entities = [this.gameState.player];
                
                // Generate new level
                this.generateLevel();
                
                // Screen transition effect
                this.cameras.main.fade(300, 0, 0, 0);
                this.cameras.main.once('camerafadeoutcomplete', () => {
                    this.cameras.main.fadeIn(300);
                });
            }
            
            updateCamera() {
                // Center camera on player
                const playerScreenX = this.gameState.player.x * GAME_CONFIG.TILE_SIZE;
                const playerScreenY = this.gameState.player.y * GAME_CONFIG.TILE_SIZE;
                
                this.cameras.main.centerOn(playerScreenX, playerScreenY);
            }
            
            updateUI() {
                const player = this.gameState.player;
                const health = player.getComponent('health');
                const mana = player.getComponent('mana');
                const level = player.getComponent('level');
                
                // Update health
                document.getElementById('health-text').textContent = `${health.currentHealth}/${health.maxHealth}`;
                document.getElementById('health-bar').style.width = `${(health.currentHealth / health.maxHealth) * 100}%`;
                
                // Update mana
                document.getElementById('mana-text').textContent = `${mana.currentMana}/${mana.maxMana}`;
                document.getElementById('mana-bar').style.width = `${(mana.currentMana / mana.maxMana) * 100}%`;
                
                // Update level
                document.getElementById('level-text').textContent = level.level;
                document.getElementById('exp-text').textContent = `${level.experience}/${level.experienceToNext}`;
                document.getElementById('exp-bar').style.width = `${(level.experience / level.experienceToNext) * 100}%`;
                
                // Update depth
                document.getElementById('depth-text').textContent = this.gameState.currentDepth;
            }
            
            startMusic() {
                const trackNumber = Math.floor(Math.random() * 28) + 1;
                try {
                    if (this.sound.get(`music_${trackNumber}`)) {
                        this.sound.play(`music_${trackNumber}`, { 
                            loop: true, 
                            volume: 0.3 
                        });
                    }
                } catch (error) {
                    console.warn('Failed to play music:', error);
                }
            }
            
            gameOver() {
                this.gameState.addMessage('üíÄ You have died! Game Over!', '#e74c3c');
                
                // Stop music
                this.sound.stopAll();
                
                // Show game over screen
                this.cameras.main.fade(1000, 0, 0, 0);
                
                this.time.delayedCall(2000, () => {
                    this.scene.restart();
                });
            }
        }
        
        // Game configuration
        const gameConfig = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            parent: 'game-container',
            backgroundColor: '#1a1a1a',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                min: { width: 640, height: 360 },
                max: { width: 1920, 1080 }
            },
            render: {
                antialias: false,
                pixelArt: true,
                roundPixels: true
            },
            scene: RoguelikeScene
        };
        
        // Start the game
        window.addEventListener('load', function() {
            const game = new Phaser.Game(gameConfig);
            window.game = game;
            console.log('üê¢ Bob The Turtle Roguelike - Ready to play!');
        });
    </script>
</body>
</html>
