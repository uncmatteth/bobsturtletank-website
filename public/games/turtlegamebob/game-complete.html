<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê¢ Bob The Turtle: Hero Of Turtle Dungeon Depths - COMPLETE EDITION</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.5);
            border: 2px solid #34495e;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1000;
        }
        
        .virtual-joystick {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(52, 73, 94, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
            margin: 0 20px;
            display: inline-block;
        }
        
        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }
        
        .action-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .action-button:active {
            background: rgba(231, 76, 60, 1);
            transform: scale(0.95);
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                align-items: center;
            }
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        
        .loading-title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .loading-progress {
            width: 400px;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-text {
            font-size: 18px;
            margin-top: 10px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-title">üê¢ Bob The Turtle</div>
        <div>Hero Of Turtle Dungeon Depths</div>
        <div class="loading-progress">
            <div id="loading-bar" class="loading-bar"></div>
        </div>
        <div id="loading-text" class="loading-text">Initializing legendary adventure...</div>
    </div>
    
    <div id="game-container"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="attack-button" class="action-button">‚öîÔ∏è</div>
        <div id="ability-button" class="action-button">‚ú®</div>
        <div id="inventory-button" class="action-button">üéí</div>
    </div>
    
    <script>
        // COMPLETE LEGENDARY ROGUELIKE RPG IMPLEMENTATION
        
        // Global game state
        let gameInstance = null;
        let isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Shell Classes - Core game mechanic
        const SHELL_CLASSES = {
            DEFENDER: {
                name: 'Shell Defender',
                description: 'Tanky turtle with high defense and protective abilities',
                baseStats: { hp: 150, mp: 50, attack: 15, defense: 25, speed: 80 },
                abilities: ['Shell Shield', 'Taunt', 'Regeneration'],
                color: 0x2ecc71
            },
            SWIFT: {
                name: 'Swift Current',
                description: 'Fast turtle with high damage and mobility',
                baseStats: { hp: 100, mp: 75, attack: 25, defense: 15, speed: 120 },
                abilities: ['Water Dash', 'Precision Strike', 'Evasion'],
                color: 0x3498db
            },
            FIRE: {
                name: 'Fire Belly',
                description: 'Magical turtle with powerful spells and area damage',
                baseStats: { hp: 80, mp: 100, attack: 30, defense: 10, speed: 100 },
                abilities: ['Flame Burst', 'Fire Aura', 'Meteor'],
                color: 0xe74c3c
            }
        };
        
        // Equipment system
        const EQUIPMENT_TYPES = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            ACCESSORY: 'accessory'
        };
        
        const RARITY_TIERS = {
            COMMON: { name: 'Common', color: 0xffffff, multiplier: 1.0 },
            UNCOMMON: { name: 'Uncommon', color: 0x2ecc71, multiplier: 1.2 },
            RARE: { name: 'Rare', color: 0x3498db, multiplier: 1.5 },
            EPIC: { name: 'Epic', color: 0x9b59b6, multiplier: 2.0 },
            LEGENDARY: { name: 'Legendary', color: 0xf39c12, multiplier: 3.0 },
            MYTHIC: { name: 'Mythic', color: 0xe74c3c, multiplier: 5.0 }
        };
        
        // Enemy types with AI behaviors
        const ENEMY_TYPES = {
            CRAB: {
                name: 'Sea Crab',
                baseHp: 30,
                baseAttack: 8,
                speed: 60,
                behavior: 'aggressive',
                color: 0xff6b6b,
                abilities: ['Pincer Attack']
            },
            JELLYFISH: {
                name: 'Electric Jellyfish',
                baseHp: 20,
                baseAttack: 12,
                speed: 40,
                behavior: 'patrol',
                color: 0x4ecdc4,
                abilities: ['Electric Shock']
            },
            SHARK: {
                name: 'Deep Shark',
                baseHp: 60,
                baseAttack: 15,
                speed: 100,
                behavior: 'hunt',
                color: 0x45b7d1,
                abilities: ['Bite', 'Charge']
            },
            OCTOPUS: {
                name: 'Giant Octopus',
                baseHp: 80,
                baseAttack: 20,
                speed: 80,
                behavior: 'defensive',
                color: 0x96ceb4,
                abilities: ['Ink Cloud', 'Tentacle Slam']
            },
            LEVIATHAN: {
                name: 'Corrupted Leviathan',
                baseHp: 200,
                baseAttack: 35,
                speed: 120,
                behavior: 'boss',
                color: 0x8b0000,
                abilities: ['Tidal Wave', 'Corruption Beam', 'Summon Minions']
            }
        };
        
        // Achievement system
        const ACHIEVEMENTS = [
            { id: 'first_kill', name: 'First Blood', description: 'Defeat your first enemy', reward: { xp: 50, gold: 25 } },
            { id: 'floor_5', name: 'Deep Diver', description: 'Reach floor 5', reward: { xp: 100, gold: 50 } },
            { id: 'floor_10', name: 'Abyss Walker', description: 'Reach floor 10', reward: { xp: 200, gold: 100 } },
            { id: 'level_10', name: 'Veteran Turtle', description: 'Reach level 10', reward: { xp: 150, gold: 75 } },
            { id: 'legendary_item', name: 'Legendary Hunter', description: 'Find a legendary item', reward: { xp: 300, gold: 150 } },
            { id: 'boss_killer', name: 'Boss Slayer', description: 'Defeat a boss enemy', reward: { xp: 500, gold: 250 } },
            { id: 'collector', name: 'Treasure Collector', description: 'Collect 50 items', reward: { xp: 200, gold: 100 } },
            { id: 'survivor', name: 'Survivor', description: 'Survive for 30 minutes', reward: { xp: 400, gold: 200 } },
            { id: 'master_turtle', name: 'Master Turtle', description: 'Reach level 25', reward: { xp: 1000, gold: 500 } },
            { id: 'floor_25', name: 'Depths Master', description: 'Reach floor 25', reward: { xp: 1500, gold: 750 } }
        ];
        
        class LoadingManager {
            constructor() {
                this.loadingScreen = document.getElementById('loading-screen');
                this.loadingBar = document.getElementById('loading-bar');
                this.loadingText = document.getElementById('loading-text');
                this.progress = 0;
            }
            
            updateProgress(progress, text) {
                this.progress = Math.min(100, Math.max(0, progress));
                this.loadingBar.style.width = this.progress + '%';
                if (text) this.loadingText.textContent = text;
            }
            
            hide() {
                this.loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    this.loadingScreen.style.display = 'none';
                }, 500);
            }
        }
        
        // Mobile controls manager
        class MobileControls {
            constructor(scene) {
                this.scene = scene;
                this.joystick = null;
                this.knob = null;
                this.isDragging = false;
                this.joystickCenter = { x: 0, y: 0 };
                this.currentInput = { x: 0, y: 0 };
                
                if (isMobile) {
                    this.setupControls();
                }
            }
            
            setupControls() {
                this.joystick = document.getElementById('virtual-joystick');
                this.knob = document.getElementById('joystick-knob');
                
                // Joystick events
                this.joystick.addEventListener('touchstart', this.onJoystickStart.bind(this));
                this.joystick.addEventListener('touchmove', this.onJoystickMove.bind(this));
                this.joystick.addEventListener('touchend', this.onJoystickEnd.bind(this));
                
                // Action buttons
                document.getElementById('attack-button').addEventListener('touchstart', () => {
                    this.scene.hero.attack();
                });
                
                document.getElementById('ability-button').addEventListener('touchstart', () => {
                    this.scene.hero.useAbility();
                });
                
                document.getElementById('inventory-button').addEventListener('touchstart', () => {
                    this.scene.toggleInventory();
                });
                
                // Get joystick center
                const rect = this.joystick.getBoundingClientRect();
                this.joystickCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }
            
            onJoystickStart(e) {
                e.preventDefault();
                this.isDragging = true;
            }
            
            onJoystickMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const dx = touch.clientX - this.joystickCenter.x;
                const dy = touch.clientY - this.joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 40;
                
                if (distance <= maxDistance) {
                    this.knob.style.transform = `translate(${dx - 20}px, ${dy - 20}px)`;
                    this.currentInput.x = dx / maxDistance;
                    this.currentInput.y = dy / maxDistance;
                } else {
                    const angle = Math.atan2(dy, dx);
                    const limitedX = Math.cos(angle) * maxDistance;
                    const limitedY = Math.sin(angle) * maxDistance;
                    this.knob.style.transform = `translate(${limitedX - 20}px, ${limitedY - 20}px)`;
                    this.currentInput.x = Math.cos(angle);
                    this.currentInput.y = Math.sin(angle);
                }
            }
            
            onJoystickEnd(e) {
                e.preventDefault();
                this.isDragging = false;
                this.knob.style.transform = 'translate(-50%, -50%)';
                this.currentInput = { x: 0, y: 0 };
            }
            
            getInput() {
                return this.currentInput;
            }
        }
        
        // Hero class with all shell classes
        class Hero extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, shellClass = 'DEFENDER') {
                super(scene, x, y, 'hero');
                
                this.scene = scene;
                this.shellClass = SHELL_CLASSES[shellClass];
                
                // Initialize stats
                this.level = 1;
                this.experience = 0;
                this.experienceToNext = 100;
                this.maxHealth = this.shellClass.baseStats.hp;
                this.health = this.maxHealth;
                this.maxMana = this.shellClass.baseStats.mp;
                this.mana = this.maxMana;
                this.attack = this.shellClass.baseStats.attack;
                this.defense = this.shellClass.baseStats.defense;
                this.speed = this.shellClass.baseStats.speed;
                
                // Equipment slots
                this.equipment = {
                    weapon: null,
                    armor: null,
                    accessory: null
                };
                
                // Abilities and cooldowns
                this.abilities = [...this.shellClass.abilities];
                this.abilityCooldowns = {};
                this.abilities.forEach(ability => this.abilityCooldowns[ability] = 0);
                
                // Combat state
                this.isAttacking = false;
                this.attackCooldown = 0;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                
                // Add to scene
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.setCollideWorldBounds(true);
                this.setScale(1.5);
                this.setTint(this.shellClass.color);
                
                console.log(`üê¢ Hero created: ${this.shellClass.name}`);
            }
            
            update(time, delta) {
                // Update cooldowns
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }
                
                if (this.invulnerabilityTime > 0) {
                    this.invulnerabilityTime -= delta;
                    if (this.invulnerabilityTime <= 0) {
                        this.invulnerable = false;
                        this.clearTint();
                        this.setTint(this.shellClass.color);
                    }
                }
                
                // Update ability cooldowns
                Object.keys(this.abilityCooldowns).forEach(ability => {
                    if (this.abilityCooldowns[ability] > 0) {
                        this.abilityCooldowns[ability] -= delta;
                    }
                });
                
                // Regenerate mana
                if (this.mana < this.maxMana) {
                    this.mana = Math.min(this.maxMana, this.mana + (delta * 0.01));
                }
            }
            
            attack() {
                if (this.attackCooldown > 0 || this.isAttacking) return;
                
                this.isAttacking = true;
                this.attackCooldown = 500; // 0.5 second cooldown
                
                // Create attack effect
                this.scene.createAttackEffect(this.x, this.y, this.attack);
                
                // Screen shake
                this.scene.cameras.main.shake(100, 0.01);
                
                setTimeout(() => {
                    this.isAttacking = false;
                }, 200);
            }
            
            useAbility(abilityIndex = 0) {
                const ability = this.abilities[abilityIndex];
                if (!ability || this.abilityCooldowns[ability] > 0) return;
                
                const manaCost = this.getAbilityManaCost(ability);
                if (this.mana < manaCost) return;
                
                this.mana -= manaCost;
                this.abilityCooldowns[ability] = this.getAbilityCooldown(ability);
                
                this.executeAbility(ability);
            }
            
            executeAbility(ability) {
                switch (ability) {
                    case 'Shell Shield':
                        this.defense += 10;
                        this.scene.createSpellEffect(this.x, this.y, 'earth');
                        setTimeout(() => this.defense -= 10, 5000);
                        break;
                        
                    case 'Water Dash':
                        const dashDistance = 150;
                        const angle = this.rotation;
                        const targetX = this.x + Math.cos(angle) * dashDistance;
                        const targetY = this.y + Math.sin(angle) * dashDistance;
                        
                        this.scene.tweens.add({
                            targets: this,
                            x: targetX,
                            y: targetY,
                            duration: 200,
                            ease: 'Power2'
                        });
                        
                        this.scene.createSpellEffect(this.x, this.y, 'water');
                        break;
                        
                    case 'Flame Burst':
                        this.scene.createAreaDamage(this.x, this.y, 100, this.attack * 1.5);
                        this.scene.createSpellEffect(this.x, this.y, 'fire');
                        break;
                }
                
                this.scene.showFloatingText(this.x, this.y - 30, ability, '#ffff00');
            }
            
            getAbilityManaCost(ability) {
                const costs = {
                    'Shell Shield': 20,
                    'Taunt': 15,
                    'Regeneration': 25,
                    'Water Dash': 30,
                    'Precision Strike': 25,
                    'Evasion': 20,
                    'Flame Burst': 35,
                    'Fire Aura': 40,
                    'Meteor': 50
                };
                return costs[ability] || 20;
            }
            
            getAbilityCooldown(ability) {
                const cooldowns = {
                    'Shell Shield': 10000,
                    'Taunt': 8000,
                    'Regeneration': 15000,
                    'Water Dash': 5000,
                    'Precision Strike': 3000,
                    'Evasion': 12000,
                    'Flame Burst': 6000,
                    'Fire Aura': 8000,
                    'Meteor': 20000
                };
                return cooldowns[ability] || 5000;
            }
            
            takeDamage(amount) {
                if (this.invulnerable) return;
                
                const actualDamage = Math.max(1, amount - this.defense);
                this.health -= actualDamage;
                
                // Invulnerability frames
                this.invulnerable = true;
                this.invulnerabilityTime = 1000;
                this.setTint(0xff0000);
                
                // Screen flash
                this.scene.cameras.main.flash(200, 255, 0, 0, 0.3);
                
                // Floating damage text
                this.scene.showFloatingText(this.x, this.y - 20, `-${actualDamage}`, '#ff0000');
                
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            addExperience(amount) {
                this.experience += amount;
                
                while (this.experience >= this.experienceToNext) {
                    this.experience -= this.experienceToNext;
                    this.levelUp();
                }
            }
            
            levelUp() {
                this.level++;
                this.experienceToNext = Math.floor(this.experienceToNext * 1.2);
                
                // Stat increases
                this.maxHealth += 10;
                this.health = this.maxHealth;
                this.maxMana += 5;
                this.mana = this.maxMana;
                this.attack += 2;
                this.defense += 1;
                
                // Epic level up effects
                this.scene.cameras.main.flash(300, 255, 215, 0, true);
                this.scene.cameras.main.shake(200, 0.02);
                this.scene.createSpellEffect(this.x, this.y, 'magic');
                this.scene.showFloatingText(this.x, this.y - 50, `LEVEL ${this.level}!`, '#ffd700');
                
                console.log(`üéâ Level up! Now level ${this.level}`);
            }
            
            die() {
                this.scene.gameOver();
            }
            
            equipItem(item) {
                if (this.equipment[item.type]) {
                    // Unequip current item
                    this.unequipItem(item.type);
                }
                
                this.equipment[item.type] = item;
                this.applyItemStats(item, 1);
                
                this.scene.showFloatingText(this.x, this.y - 40, `Equipped ${item.name}`, '#00ff00');
            }
            
            unequipItem(type) {
                const item = this.equipment[type];
                if (item) {
                    this.applyItemStats(item, -1);
                    this.equipment[type] = null;
                }
            }
            
            applyItemStats(item, multiplier) {
                this.attack += (item.stats.attack || 0) * multiplier;
                this.defense += (item.stats.defense || 0) * multiplier;
                this.maxHealth += (item.stats.health || 0) * multiplier;
                this.maxMana += (item.stats.mana || 0) * multiplier;
                this.speed += (item.stats.speed || 0) * multiplier;
            }
        }
        
        // Enemy class with AI
        class Enemy extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, type, level = 1) {
                super(scene, x, y, 'enemy');
                
                this.scene = scene;
                this.enemyType = ENEMY_TYPES[type];
                this.level = level;
                
                // Scale stats by level
                this.maxHealth = Math.floor(this.enemyType.baseHp * (1 + level * 0.2));
                this.health = this.maxHealth;
                this.attack = Math.floor(this.enemyType.baseAttack * (1 + level * 0.15));
                this.speed = this.enemyType.speed;
                this.behavior = this.enemyType.behavior;
                
                // AI state
                this.target = null;
                this.lastSeen = null;
                this.patrolPoint = { x: x, y: y };
                this.alertRadius = 150;
                this.attackRange = 50;
                this.attackCooldown = 0;
                this.stateTimer = 0;
                this.currentState = 'patrol';
                
                // Add to scene
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.setCollideWorldBounds(true);
                this.setScale(1.2);
                this.setTint(this.enemyType.color);
                
                // Health bar
                this.healthBar = scene.add.graphics();
                this.updateHealthBar();
            }
            
            update(time, delta) {
                // Update cooldowns
                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }
                
                this.stateTimer += delta;
                
                // AI behavior
                this.updateAI(delta);
                
                // Update health bar position
                this.healthBar.x = this.x - 20;
                this.healthBar.y = this.y - 30;
            }
            
            updateAI(delta) {
                const hero = this.scene.hero;
                const distanceToHero = Phaser.Math.Distance.Between(this.x, this.y, hero.x, hero.y);
                
                switch (this.behavior) {
                    case 'aggressive':
                        if (distanceToHero < this.alertRadius) {
                            this.target = hero;
                            this.currentState = 'chase';
                        }
                        break;
                        
                    case 'patrol':
                        if (distanceToHero < this.alertRadius) {
                            this.target = hero;
                            this.currentState = 'chase';
                        } else if (this.currentState === 'patrol') {
                            this.patrol();
                        }
                        break;
                        
                    case 'hunt':
                        this.target = hero;
                        this.currentState = 'chase';
                        break;
                        
                    case 'defensive':
                        if (distanceToHero < this.alertRadius / 2) {
                            this.target = hero;
                            this.currentState = 'chase';
                        }
                        break;
                        
                    case 'boss':
                        this.target = hero;
                        this.currentState = 'boss_ai';
                        this.updateBossAI(delta);
                        return;
                }
                
                // Execute current state
                if (this.currentState === 'chase' && this.target) {
                    this.chaseTarget();
                }
            }
            
            patrol() {
                if (this.stateTimer > 3000) { // Change direction every 3 seconds
                    this.patrolPoint = {
                        x: this.x + Phaser.Math.Between(-100, 100),
                        y: this.y + Phaser.Math.Between(-100, 100)
                    };
                    this.stateTimer = 0;
                }
                
                this.scene.physics.moveToObject(this, this.patrolPoint, this.speed * 0.5);
            }
            
            chaseTarget() {
                if (!this.target) return;
                
                const distance = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
                
                if (distance < this.attackRange && this.attackCooldown <= 0) {
                    this.attack();
                } else if (distance < this.alertRadius * 2) {
                    this.scene.physics.moveToObject(this, this.target, this.speed);
                } else {
                    this.target = null;
                    this.currentState = 'patrol';
                }
            }
            
            updateBossAI(delta) {
                // Boss-specific AI patterns
                const hero = this.scene.hero;
                const distance = Phaser.Math.Distance.Between(this.x, this.y, hero.x, hero.y);
                
                if (this.stateTimer > 5000) { // Special attack every 5 seconds
                    this.useSpecialAbility();
                    this.stateTimer = 0;
                } else if (distance < this.attackRange && this.attackCooldown <= 0) {
                    this.attack();
                } else {
                    this.scene.physics.moveToObject(this, hero, this.speed * 0.8);
                }
            }
            
            attack() {
                this.attackCooldown = 1500; // 1.5 second cooldown
                
                if (this.target) {
                    const distance = Phaser.Math.Distance.Between(this.x, this.y, this.target.x, this.target.y);
                    if (distance < this.attackRange) {
                        this.target.takeDamage(this.attack);
                        this.scene.createImpactEffect(this.target.x, this.target.y, 0xff4444);
                    }
                }
            }
            
            useSpecialAbility() {
                const abilities = this.enemyType.abilities;
                if (abilities.length === 0) return;
                
                const ability = Phaser.Utils.Array.GetRandom(abilities);
                
                switch (ability) {
                    case 'Electric Shock':
                        this.scene.createAreaDamage(this.x, this.y, 80, this.attack * 0.8);
                        this.scene.createSpellEffect(this.x, this.y, 'lightning');
                        break;
                        
                    case 'Ink Cloud':
                        this.scene.createSpellEffect(this.x, this.y, 'dark');
                        // Reduce hero visibility temporarily
                        break;
                        
                    case 'Tidal Wave':
                        this.scene.createAreaDamage(this.x, this.y, 200, this.attack * 1.5);
                        this.scene.createSpellEffect(this.x, this.y, 'water');
                        break;
                }
            }
            
            takeDamage(amount) {
                this.health -= amount;
                this.setTint(0xff0000);
                
                // Flash back to original color
                this.scene.time.delayedCall(200, () => {
                    this.setTint(this.enemyType.color);
                });
                
                this.updateHealthBar();
                this.scene.showFloatingText(this.x, this.y - 20, `-${amount}`, '#ff4444');
                
                if (this.health <= 0) {
                    this.die();
                }
            }
            
            updateHealthBar() {
                this.healthBar.clear();
                
                // Background
                this.healthBar.fillStyle(0x000000);
                this.healthBar.fillRect(0, 0, 40, 6);
                
                // Health
                const healthPercent = this.health / this.maxHealth;
                const color = healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000;
                this.healthBar.fillStyle(color);
                this.healthBar.fillRect(1, 1, 38 * healthPercent, 4);
            }
            
            die() {
                // Drop loot
                this.scene.dropLoot(this.x, this.y, this.level);
                
                // Give experience
                const xpReward = Math.floor(10 * (1 + this.level * 0.5));
                this.scene.hero.addExperience(xpReward);
                
                // Death effect
                this.scene.createSpellEffect(this.x, this.y, 'death');
                this.scene.cameras.main.shake(100, 0.01);
                
                // Remove from scene
                this.healthBar.destroy();
                this.destroy();
                
                // Check achievements
                this.scene.checkAchievement('first_kill');
                if (this.behavior === 'boss') {
                    this.scene.checkAchievement('boss_killer');
                }
            }
        }
        
        // Item class
        class Item extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, itemData) {
                super(scene, x, y, 'item');
                
                this.scene = scene;
                this.itemData = itemData;
                
                scene.add.existing(this);
                scene.physics.add.existing(this);
                
                this.setScale(0.8);
                this.setTint(itemData.rarity.color);
                
                // Floating animation
                scene.tweens.add({
                    targets: this,
                    y: y - 10,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Glow effect
                this.glowEffect = scene.add.circle(x, y, 20, itemData.rarity.color, 0.2);
                scene.tweens.add({
                    targets: this.glowEffect,
                    alpha: 0.4,
                    duration: 800,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
            
            collect() {
                this.scene.hero.equipItem(this.itemData);
                this.scene.showFloatingText(this.x, this.y, `+${this.itemData.name}`, '#00ff88');
                
                // Collection effect
                this.scene.createSpellEffect(this.x, this.y, 'collect');
                
                this.glowEffect.destroy();
                this.destroy();
                
                this.scene.checkAchievement('collector');
                if (this.itemData.rarity === RARITY_TIERS.LEGENDARY) {
                    this.scene.checkAchievement('legendary_item');
                }
            }
        }
        
        // Main Game Scene
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                
                // Game state
                this.hero = null;
                this.enemies = null;
                this.items = null;
                this.cursors = null;
                this.wasdKeys = null;
                this.mobileControls = null;
                
                // UI elements
                this.healthBar = null;
                this.manaBar = null;
                this.statsText = null;
                this.floorText = null;
                this.messageText = null;
                
                // Game data
                this.currentFloor = 1;
                this.score = 0;
                this.gold = 0;
                this.gameTime = 0;
                this.achievements = new Set();
                this.inventory = [];
                
                // Systems
                this.dungeonWidth = 40;
                this.dungeonHeight = 30;
                this.tileSize = 32;
                this.dungeon = [];
                
                // Visual effects
                this.particles = null;
                this.lights = null;
                this.dynamicLights = [];
                this.floatingTexts = [];
            }
            
            preload() {
                // Create textures programmatically (pixel art style)
                this.createTextures();
                
                // Load audio (placeholder - would load real audio files)
                this.createAudioPlaceholders();
            }
            
            createTextures() {
                // Hero texture (turtle)
                const heroCanvas = this.textures.createCanvas('hero', 32, 32);
                const heroCtx = heroCanvas.getContext();
                
                // Shell (dark green)
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(6, 6, 20, 20);
                
                // Shell pattern (lighter green)
                heroCtx.fillStyle = '#4a7c23';
                heroCtx.fillRect(8, 8, 16, 16);
                heroCtx.fillRect(10, 10, 12, 12);
                
                // Head (medium green)
                heroCtx.fillStyle = '#3d6b1a';
                heroCtx.fillRect(2, 10, 8, 12);
                
                // Eyes
                heroCtx.fillStyle = '#ffffff';
                heroCtx.fillRect(3, 12, 2, 2);
                heroCtx.fillRect(3, 18, 2, 2);
                heroCtx.fillStyle = '#000000';
                heroCtx.fillRect(3, 12, 1, 1);
                heroCtx.fillRect(3, 18, 1, 1);
                
                // Legs
                heroCtx.fillStyle = '#2d5016';
                heroCtx.fillRect(4, 4, 4, 4);   // front left
                heroCtx.fillRect(4, 24, 4, 4);  // front right
                heroCtx.fillRect(24, 4, 4, 4);  // back left
                heroCtx.fillRect(24, 24, 4, 4); // back right
                
                heroCanvas.refresh();
                
                // Enemy texture
                const enemyCanvas = this.textures.createCanvas('enemy', 32, 32);
                const enemyCtx = enemyCanvas.getContext();
                
                enemyCtx.fillStyle = '#8b0000';
                enemyCtx.fillRect(6, 6, 20, 20);
                enemyCtx.fillStyle = '#660000';
                enemyCtx.fillRect(8, 8, 16, 16);
                enemyCtx.fillStyle = '#ffff00';
                enemyCtx.fillRect(10, 10, 3, 3);
                enemyCtx.fillRect(19, 10, 3, 3);
                enemyCtx.fillStyle = '#000000';
                enemyCtx.fillRect(10, 10, 1, 1);
                enemyCtx.fillRect(19, 10, 1, 1);
                
                enemyCanvas.refresh();
                
                // Item texture
                const itemCanvas = this.textures.createCanvas('item', 24, 24);
                const itemCtx = itemCanvas.getContext();
                
                itemCtx.fillStyle = '#ffd700';
                itemCtx.fillRect(4, 4, 16, 16);
                itemCtx.fillStyle = '#ffff00';
                itemCtx.fillRect(6, 6, 12, 12);
                itemCtx.fillStyle = '#ffffff';
                itemCtx.fillRect(8, 8, 8, 8);
                
                itemCanvas.refresh();
                
                // Floor texture
                const floorCanvas = this.textures.createCanvas('floor', 32, 32);
                const floorCtx = floorCanvas.getContext();
                floorCtx.fillStyle = '#8B4513';
                floorCtx.fillRect(0, 0, 32, 32);
                floorCtx.fillStyle = '#A0522D';
                floorCtx.fillRect(2, 2, 28, 28);
                floorCtx.fillStyle = '#CD853F';
                floorCtx.fillRect(4, 4, 24, 24);
                floorCanvas.refresh();
                
                // Wall texture
                const wallCanvas = this.textures.createCanvas('wall', 32, 32);
                const wallCtx = wallCanvas.getContext();
                wallCtx.fillStyle = '#555555';
                wallCtx.fillRect(0, 0, 32, 32);
                wallCtx.fillStyle = '#777777';
                wallCtx.fillRect(2, 2, 28, 28);
                wallCtx.fillStyle = '#999999';
                wallCtx.fillRect(4, 4, 24, 24);
                wallCanvas.refresh();
            }
            
            createAudioPlaceholders() {
                // In a real implementation, these would load actual audio files
                this.audioContext = {
                    playMusic: (track) => console.log(`üéµ Playing: ${track}`),
                    playSound: (sound) => console.log(`üîä Sound: ${sound}`),
                    setVolume: (volume) => console.log(`üîä Volume: ${volume}`)
                };
            }
            
            create() {
                console.log('üéÆ Creating legendary game scene...');
                
                // Enable lighting
                this.lights.enable();
                this.lights.setAmbientColor(0x404040);
                
                // Create world bounds
                this.physics.world.setBounds(0, 0, this.dungeonWidth * this.tileSize, this.dungeonHeight * this.tileSize);
                
                // Generate dungeon
                this.generateDungeon();
                
                // Initialize visual effects
                this.setupVisualEffects();
                
                // Create hero
                const selectedClass = 'DEFENDER'; // Default, would come from menu
                this.hero = new Hero(this, 200, 200, selectedClass);
                
                // Create groups
                this.enemies = this.physics.add.group();
                this.items = this.physics.add.group();
                
                // Spawn initial enemies
                this.spawnEnemies();
                
                // Set up physics collisions
                this.physics.add.overlap(this.hero, this.enemies, this.heroEnemyCollision, null, this);
                this.physics.add.overlap(this.hero, this.items, this.heroItemCollision, null, this);
                
                // Set up controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wasdKeys = this.input.keyboard.addKeys('W,S,A,D,SPACE,E,Q,I');
                
                // Mobile controls
                this.mobileControls = new MobileControls(this);
                
                // Camera follows hero
                this.cameras.main.startFollow(this.hero);
                this.cameras.main.setZoom(1.2);
                
                // Create UI
                this.createUI();
                
                // Start background music
                this.audioContext.playMusic('dungeon_ambient');
                
                // Welcome message
                this.showMessage('üê¢ Welcome to the Turtle Dungeon Depths!');
                
                console.log('‚úÖ Game scene created successfully!');
            }
            
            generateDungeon() {
                console.log('üèóÔ∏è Generating procedural dungeon...');
                
                // Initialize dungeon array
                this.dungeon = [];
                for (let x = 0; x < this.dungeonWidth; x++) {
                    this.dungeon[x] = [];
                    for (let y = 0; y < this.dungeonHeight; y++) {
                        this.dungeon[x][y] = 1; // 1 = wall, 0 = floor
                    }
                }
                
                // Generate rooms using simple algorithm
                const rooms = [];
                const numRooms = 8 + Math.floor(this.currentFloor / 3);
                
                for (let i = 0; i < numRooms; i++) {
                    const room = {
                        x: Phaser.Math.Between(1, this.dungeonWidth - 8),
                        y: Phaser.Math.Between(1, this.dungeonHeight - 8),
                        width: Phaser.Math.Between(4, 8),
                        height: Phaser.Math.Between(4, 8)
                    };
                    
                    // Check for overlap
                    let overlap = false;
                    for (const existingRoom of rooms) {
                        if (room.x < existingRoom.x + existingRoom.width &&
                            room.x + room.width > existingRoom.x &&
                            room.y < existingRoom.y + existingRoom.height &&
                            room.y + room.height > existingRoom.y) {
                            overlap = true;
                            break;
                        }
                    }
                    
                    if (!overlap) {
                        rooms.push(room);
                        
                        // Carve out room
                        for (let x = room.x; x < room.x + room.width; x++) {
                            for (let y = room.y; y < room.y + room.height; y++) {
                                this.dungeon[x][y] = 0;
                            }
                        }
                    }
                }
                
                // Connect rooms with corridors
                for (let i = 1; i < rooms.length; i++) {
                    const prevRoom = rooms[i - 1];
                    const currentRoom = rooms[i];
                    
                    const prevCenterX = Math.floor(prevRoom.x + prevRoom.width / 2);
                    const prevCenterY = Math.floor(prevRoom.y + prevRoom.height / 2);
                    const currentCenterX = Math.floor(currentRoom.x + currentRoom.width / 2);
                    const currentCenterY = Math.floor(currentRoom.y + currentRoom.height / 2);
                    
                    // Horizontal corridor
                    const startX = Math.min(prevCenterX, currentCenterX);
                    const endX = Math.max(prevCenterX, currentCenterX);
                    for (let x = startX; x <= endX; x++) {
                        this.dungeon[x][prevCenterY] = 0;
                    }
                    
                    // Vertical corridor
                    const startY = Math.min(prevCenterY, currentCenterY);
                    const endY = Math.max(prevCenterY, currentCenterY);
                    for (let y = startY; y <= endY; y++) {
                        this.dungeon[currentCenterX][y] = 0;
                    }
                }
                
                // Render dungeon
                this.renderDungeon();
                
                console.log(`‚úÖ Generated dungeon with ${rooms.length} rooms`);
            }
            
            renderDungeon() {
                // Clear existing tiles
                if (this.dungeonGroup) {
                    this.dungeonGroup.clear(true, true);
                }
                
                this.dungeonGroup = this.physics.add.staticGroup();
                
                for (let x = 0; x < this.dungeonWidth; x++) {
                    for (let y = 0; y < this.dungeonHeight; y++) {
                        const tileX = x * this.tileSize + this.tileSize / 2;
                        const tileY = y * this.tileSize + this.tileSize / 2;
                        
                        if (this.dungeon[x][y] === 1) {
                            // Wall
                            const wall = this.physics.add.staticSprite(tileX, tileY, 'wall');
                            wall.setPipeline('Light2D');
                            this.dungeonGroup.add(wall);
                        } else {
                            // Floor
                            const floor = this.add.sprite(tileX, tileY, 'floor');
                            floor.setPipeline('Light2D');
                        }
                    }
                }
                
                // Set up collisions
                this.physics.add.collider(this.hero, this.dungeonGroup);
                this.physics.add.collider(this.enemies, this.dungeonGroup);
            }
            
            spawnEnemies() {
                const enemyCount = Math.min(3 + this.currentFloor, 15);
                const enemyTypes = Object.keys(ENEMY_TYPES);
                
                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    let attempts = 0;
                    
                    // Find valid spawn position
                    do {
                        x = Phaser.Math.Between(1, this.dungeonWidth - 1) * this.tileSize;
                        y = Phaser.Math.Between(1, this.dungeonHeight - 1) * this.tileSize;
                        attempts++;
                    } while (this.dungeon[Math.floor(x / this.tileSize)][Math.floor(y / this.tileSize)] === 1 && attempts < 50);
                    
                    if (attempts < 50) {
                        // Choose enemy type based on floor
                        let enemyType;
                        if (this.currentFloor < 5) {
                            enemyType = Phaser.Utils.Array.GetRandom(['CRAB', 'JELLYFISH']);
                        } else if (this.currentFloor < 10) {
                            enemyType = Phaser.Utils.Array.GetRandom(['CRAB', 'JELLYFISH', 'SHARK']);
                        } else if (this.currentFloor < 20) {
                            enemyType = Phaser.Utils.Array.GetRandom(['JELLYFISH', 'SHARK', 'OCTOPUS']);
                        } else {
                            enemyType = Phaser.Utils.Array.GetRandom(['SHARK', 'OCTOPUS', 'LEVIATHAN']);
                        }
                        
                        const enemy = new Enemy(this, x, y, enemyType, this.currentFloor);
                        enemy.setPipeline('Light2D');
                        this.enemies.add(enemy);
                        
                        // Add enemy light
                        const enemyLight = this.lights.addLight(x, y, 60, enemy.enemyType.color, 0.3);
                        this.dynamicLights.push(enemyLight);
                        enemy.light = enemyLight;
                    }
                }
                
                console.log(`üëπ Spawned ${this.enemies.children.entries.length} enemies on floor ${this.currentFloor}`);
            }
            
            setupVisualEffects() {
                // Particle system
                this.particles = this.add.particles();
                
                // Hero light
                const heroLight = this.lights.addLight(this.hero?.x || 200, this.hero?.y || 200, 120, 0x00ff88, 0.8);
                this.dynamicLights.push(heroLight);
                
                // Ambient dungeon lights
                this.addAmbientLighting();
            }
            
            addAmbientLighting() {
                // Add some torch-like lights around the dungeon
                const torchPositions = [
                    { x: 100, y: 100 },
                    { x: this.dungeonWidth * this.tileSize - 100, y: 100 },
                    { x: 100, y: this.dungeonHeight * this.tileSize - 100 },
                    { x: this.dungeonWidth * this.tileSize - 100, y: this.dungeonHeight * this.tileSize - 100 },
                    { x: this.dungeonWidth * this.tileSize / 2, y: 100 },
                    { x: this.dungeonWidth * this.tileSize / 2, y: this.dungeonHeight * this.tileSize - 100 }
                ];
                
                torchPositions.forEach((pos, index) => {
                    const torchLight = this.lights.addLight(pos.x, pos.y, 100, 0xff8844, 0.4);
                    this.dynamicLights.push(torchLight);
                    
                    // Flickering effect
                    this.time.addEvent({
                        delay: 100 + index * 50,
                        callback: () => {
                            if (torchLight) {
                                torchLight.intensity = 0.3 + Math.random() * 0.3;
                                torchLight.radius = 80 + Math.random() * 40;
                            }
                        },
                        loop: true
                    });
                });
            }
            
            createUI() {
                // UI background
                const uiHeight = 80;
                const uiBg = this.add.rectangle(640, 40, 1280, uiHeight, 0x000000, 0.8);
                uiBg.setScrollFactor(0);
                
                // Health bar
                this.healthBarBg = this.add.rectangle(200, 30, 300, 25, 0x660000);
                this.healthBarBg.setScrollFactor(0);
                this.healthBar = this.add.rectangle(200, 30, 300, 25, 0x00ff00);
                this.healthBar.setScrollFactor(0);
                
                // Mana bar
                this.manaBarBg = this.add.rectangle(200, 55, 300, 15, 0x000066);
                this.manaBarBg.setScrollFactor(0);
                this.manaBar = this.add.rectangle(200, 55, 300, 15, 0x0066ff);
                this.manaBar.setScrollFactor(0);
                
                // Stats text
                this.statsText = this.add.text(20, 15, '', {
                    fontSize: '16px',
                    color: '#ffffff',
                    fontFamily: 'Courier New'
                });
                this.statsText.setScrollFactor(0);
                
                // Floor and score
                this.floorText = this.add.text(1100, 15, '', {
                    fontSize: '16px',
                    color: '#00ff88',
                    fontFamily: 'Courier New'
                });
                this.floorText.setScrollFactor(0);
                
                // Ability cooldowns
                this.abilityUI = this.add.text(20, 80, '', {
                    fontSize: '14px',
                    color: '#ffff00',
                    fontFamily: 'Courier New'
                });
                this.abilityUI.setScrollFactor(0);
                
                // Message text
                this.messageText = this.add.text(640, 150, '', {
                    fontSize: '24px',
                    color: '#ffff00',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 4
                });
                this.messageText.setOrigin(0.5);
                this.messageText.setScrollFactor(0);
                
                // Achievement notifications
                this.achievementText = this.add.text(640, 200, '', {
                    fontSize: '20px',
                    color: '#ffd700',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 3
                });
                this.achievementText.setOrigin(0.5);
                this.achievementText.setScrollFactor(0);
            }
            
            update(time, delta) {
                if (!this.hero || !this.hero.active) return;
                
                this.gameTime += delta;
                
                // Update hero
                this.hero.update(time, delta);
                
                // Handle input
                this.handleInput();
                
                // Update enemies
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        enemy.update(time, delta);
                        
                        // Update enemy light position
                        if (enemy.light) {
                            enemy.light.x = enemy.x;
                            enemy.light.y = enemy.y;
                        }
                    }
                });
                
                // Update dynamic lighting
                this.updateLighting();
                
                // Update UI
                this.updateUI();
                
                // Check for floor completion
                if (this.enemies.children.entries.length === 0 || this.enemies.children.entries.every(e => !e.active)) {
                    this.nextFloor();
                }
                
                // Check time-based achievements
                if (this.gameTime > 1800000) { // 30 minutes
                    this.checkAchievement('survivor');
                }
            }
            
            handleInput() {
                const speed = this.hero.speed;
                this.hero.setVelocity(0);
                
                // Keyboard input
                let moveX = 0;
                let moveY = 0;
                
                if (this.cursors.left.isDown || this.wasdKeys.A.isDown) {
                    moveX = -1;
                } else if (this.cursors.right.isDown || this.wasdKeys.D.isDown) {
                    moveX = 1;
                }
                
                if (this.cursors.up.isDown || this.wasdKeys.W.isDown) {
                    moveY = -1;
                } else if (this.cursors.down.isDown || this.wasdKeys.S.isDown) {
                    moveY = 1;
                }
                
                // Mobile input
                if (isMobile && this.mobileControls) {
                    const mobileInput = this.mobileControls.getInput();
                    moveX = mobileInput.x;
                    moveY = mobileInput.y;
                }
                
                // Apply movement
                if (moveX !== 0 || moveY !== 0) {
                    // Normalize diagonal movement
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length;
                    moveY /= length;
                    
                    this.hero.setVelocity(moveX * speed, moveY * speed);
                }
                
                // Abilities
                if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.SPACE)) {
                    this.hero.attack();
                }
                
                if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.E)) {
                    this.hero.useAbility(0);
                }
                
                if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.Q)) {
                    this.hero.useAbility(1);
                }
                
                if (Phaser.Input.Keyboard.JustDown(this.wasdKeys.I)) {
                    this.toggleInventory();
                }
            }
            
            updateLighting() {
                // Update hero light
                if (this.dynamicLights[0]) {
                    this.dynamicLights[0].x = this.hero.x;
                    this.dynamicLights[0].y = this.hero.y;
                    
                    // Pulse effect
                    const time = this.time.now * 0.003;
                    this.dynamicLights[0].radius = 100 + Math.sin(time) * 20;
                    this.dynamicLights[0].intensity = 0.7 + Math.sin(time * 1.5) * 0.1;
                }
            }
            
            updateUI() {
                if (!this.hero) return;
                
                // Health bar
                const healthPercent = this.hero.health / this.hero.maxHealth;
                this.healthBar.scaleX = healthPercent;
                this.healthBar.fillColor = healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000;
                
                // Mana bar
                const manaPercent = this.hero.mana / this.hero.maxMana;
                this.manaBar.scaleX = manaPercent;
                
                // Stats text
                this.statsText.setText([
                    `‚ù§Ô∏è ${Math.ceil(this.hero.health)}/${this.hero.maxHealth}`,
                    `üíô ${Math.ceil(this.hero.mana)}/${this.hero.maxMana}`,
                    `‚≠ê Lv.${this.hero.level} (${this.hero.experience}/${this.hero.experienceToNext})`,
                    `üí∞ ${this.gold}G  ‚öîÔ∏è ${this.hero.attack}  üõ°Ô∏è ${this.hero.defense}`
                ].join('  '));
                
                // Floor and score
                this.floorText.setText([
                    `üè∞ Floor ${this.currentFloor}`,
                    `üéØ Score: ${this.score}`,
                    `üëπ Enemies: ${this.enemies.children.entries.filter(e => e.active).length}`,
                    `‚è±Ô∏è ${Math.floor(this.gameTime / 60000)}:${Math.floor((this.gameTime % 60000) / 1000).toString().padStart(2, '0')}`
                ].join('  '));
                
                // Ability cooldowns
                const cooldownTexts = [];
                this.hero.abilities.forEach((ability, index) => {
                    const cooldown = this.hero.abilityCooldowns[ability];
                    const key = index === 0 ? 'E' : index === 1 ? 'Q' : `${index + 1}`;
                    if (cooldown > 0) {
                        cooldownTexts.push(`${key}: ${ability} (${Math.ceil(cooldown / 1000)}s)`);
                    } else {
                        cooldownTexts.push(`${key}: ${ability} ‚úì`);
                    }
                });
                this.abilityUI.setText(cooldownTexts.join('  '));
            }
            
            heroEnemyCollision(hero, enemy) {
                // Handled by enemy attack logic
            }
            
            heroItemCollision(hero, item) {
                item.collect();
            }
            
            createAttackEffect(x, y, damage) {
                // Create attack area
                const attackRadius = 60;
                const attackArea = this.add.circle(x, y, attackRadius, 0xffffff, 0.3);
                
                // Damage enemies in range
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        const distance = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
                        if (distance < attackRadius) {
                            enemy.takeDamage(damage);
                        }
                    }
                });
                
                // Remove attack effect
                this.tweens.add({
                    targets: attackArea,
                    alpha: 0,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    duration: 200,
                    onComplete: () => attackArea.destroy()
                });
                
                // Sound effect
                this.audioContext.playSound('sword_hit');
            }
            
            createAreaDamage(x, y, radius, damage) {
                // Visual effect
                const areaEffect = this.add.circle(x, y, radius, 0xff4444, 0.4);
                
                // Damage enemies in area
                this.enemies.children.entries.forEach(enemy => {
                    if (enemy.active) {
                        const distance = Phaser.Math.Distance.Between(x, y, enemy.x, enemy.y);
                        if (distance < radius) {
                            enemy.takeDamage(damage);
                        }
                    }
                });
                
                // Remove effect
                this.tweens.add({
                    targets: areaEffect,
                    alpha: 0,
                    scaleX: 1.3,
                    scaleY: 1.3,
                    duration: 500,
                    onComplete: () => areaEffect.destroy()
                });
            }
            
            createSpellEffect(x, y, type = 'magic') {
                const colors = {
                    magic: 0x00ff88,
                    fire: 0xff4444,
                    water: 0x4488ff,
                    earth: 0x88ff44,
                    lightning: 0xffff44,
                    dark: 0x444444,
                    death: 0x8b0000,
                    collect: 0xffd700
                };
                
                const color = colors[type] || colors.magic;
                
                // Particle effect
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 50, max: 150 },
                    scale: { start: 0.5, end: 0 },
                    tint: color,
                    lifespan: 800,
                    quantity: 15,
                    blendMode: 'ADD'
                });
                
                this.time.delayedCall(100, () => emitter.stop());
            }
            
            createImpactEffect(x, y, color = 0xffffff) {
                // Particle burst
                const emitter = this.particles.createEmitter({
                    x: x,
                    y: y,
                    speed: { min: 80, max: 200 },
                    scale: { start: 0.4, end: 0 },
                    tint: color,
                    lifespan: 400,
                    quantity: 10
                });
                
                this.time.delayedCall(50, () => emitter.stop());
            }
            
            showFloatingText(x, y, text, color = '#ffffff', size = '18px') {
                const floatingText = this.add.text(x, y, text, {
                    fontSize: size,
                    color: color,
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 3
                });
                floatingText.setOrigin(0.5);
                
                this.tweens.add({
                    targets: floatingText,
                    y: y - 80,
                    alpha: 0,
                    duration: 2000,
                    ease: 'Power2',
                    onComplete: () => floatingText.destroy()
                });
            }
            
            showMessage(text, duration = 3000) {
                this.messageText.setText(text);
                this.messageText.setAlpha(1);
                
                this.tweens.add({
                    targets: this.messageText,
                    alpha: 0,
                    duration: duration,
                    ease: 'Power2'
                });
            }
            
            dropLoot(x, y, level) {
                // Chance to drop item
                const dropChance = 0.3 + (level * 0.02);
                if (Math.random() > dropChance) return;
                
                // Generate random item
                const item = this.generateRandomItem(level);
                const itemSprite = new Item(this, x, y, item);
                this.items.add(itemSprite);
                
                // Drop gold
                const goldAmount = Phaser.Math.Between(5, 15) * level;
                this.gold += goldAmount;
                this.showFloatingText(x + 20, y, `+${goldAmount}G`, '#ffd700');
            }
            
            generateRandomItem(level) {
                const types = Object.values(EQUIPMENT_TYPES);
                const rarities = Object.values(RARITY_TIERS);
                
                // Higher level = better rarity chance
                let rarityIndex = 0;
                const rand = Math.random();
                if (rand < 0.5) rarityIndex = 0; // Common
                else if (rand < 0.75) rarityIndex = 1; // Uncommon
                else if (rand < 0.9) rarityIndex = 2; // Rare
                else if (rand < 0.97) rarityIndex = 3; // Epic
                else if (rand < 0.995) rarityIndex = 4; // Legendary
                else rarityIndex = 5; // Mythic
                
                // Adjust for level
                rarityIndex = Math.min(rarities.length - 1, rarityIndex + Math.floor(level / 5));
                
                const type = Phaser.Utils.Array.GetRandom(types);
                const rarity = rarities[rarityIndex];
                
                // Generate stats based on type and rarity
                const baseStats = this.getBaseStatsForType(type);
                const stats = {};
                
                Object.keys(baseStats).forEach(stat => {
                    stats[stat] = Math.floor(baseStats[stat] * rarity.multiplier * (0.8 + Math.random() * 0.4));
                });
                
                return {
                    name: this.generateItemName(type, rarity),
                    type: type,
                    rarity: rarity,
                    stats: stats,
                    level: level
                };
            }
            
            getBaseStatsForType(type) {
                switch (type) {
                    case EQUIPMENT_TYPES.WEAPON:
                        return { attack: 10, speed: 2 };
                    case EQUIPMENT_TYPES.ARMOR:
                        return { defense: 8, health: 20 };
                    case EQUIPMENT_TYPES.ACCESSORY:
                        return { mana: 15, attack: 3, defense: 3 };
                    default:
                        return { attack: 5, defense: 5 };
                }
            }
            
            generateItemName(type, rarity) {
                const prefixes = ['Ancient', 'Blessed', 'Cursed', 'Divine', 'Ethereal', 'Forgotten', 'Glowing', 'Haunted'];
                const weaponNames = ['Blade', 'Sword', 'Axe', 'Mace', 'Staff', 'Wand', 'Trident', 'Harpoon'];
                const armorNames = ['Shell', 'Plate', 'Mail', 'Robe', 'Cloak', 'Shield', 'Helm', 'Gauntlets'];
                const accessoryNames = ['Ring', 'Amulet', 'Charm', 'Talisman', 'Orb', 'Crystal', 'Gem', 'Pendant'];
                
                let baseName;
                switch (type) {
                    case EQUIPMENT_TYPES.WEAPON:
                        baseName = Phaser.Utils.Array.GetRandom(weaponNames);
                        break;
                    case EQUIPMENT_TYPES.ARMOR:
                        baseName = Phaser.Utils.Array.GetRandom(armorNames);
                        break;
                    case EQUIPMENT_TYPES.ACCESSORY:
                        baseName = Phaser.Utils.Array.GetRandom(accessoryNames);
                        break;
                    default:
                        baseName = 'Item';
                }
                
                if (rarity.name !== 'Common') {
                    const prefix = Phaser.Utils.Array.GetRandom(prefixes);
                    return `${prefix} ${baseName}`;
                }
                
                return baseName;
            }
            
            nextFloor() {
                this.currentFloor++;
                
                // Heal player partially
                this.hero.health = Math.min(this.hero.maxHealth, this.hero.health + Math.floor(this.hero.maxHealth * 0.2));
                this.hero.mana = Math.min(this.hero.maxMana, this.hero.mana + Math.floor(this.hero.maxMana * 0.3));
                
                // Clear items
                this.items.clear(true, true);
                
                // Generate new dungeon
                this.generateDungeon();
                
                // Spawn new enemies
                this.spawnEnemies();
                
                // Move hero to start position
                this.hero.setPosition(200, 200);
                
                // Update score
                this.score += 1000 * this.currentFloor;
                
                // Floor completion message
                this.showMessage(`üè∞ Floor ${this.currentFloor} - Deeper into the abyss!`);
                
                // Screen flash
                this.cameras.main.flash(500, 0, 100, 255, 0.3);
                
                // Check achievements
                if (this.currentFloor === 5) this.checkAchievement('floor_5');
                if (this.currentFloor === 10) this.checkAchievement('floor_10');
                if (this.currentFloor === 25) this.checkAchievement('floor_25');
                
                // Play floor transition sound
                this.audioContext.playSound('level_up');
                
                console.log(`üè∞ Advanced to floor ${this.currentFloor}`);
            }
            
            checkAchievement(achievementId) {
                if (this.achievements.has(achievementId)) return;
                
                const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
                if (!achievement) return;
                
                // Check specific conditions
                let unlocked = false;
                switch (achievementId) {
                    case 'first_kill':
                        unlocked = true; // Called when enemy dies
                        break;
                    case 'level_10':
                        unlocked = this.hero.level >= 10;
                        break;
                    case 'master_turtle':
                        unlocked = this.hero.level >= 25;
                        break;
                    case 'collector':
                        unlocked = this.inventory.length >= 50;
                        break;
                    default:
                        unlocked = true; // For floor-based achievements
                }
                
                if (unlocked) {
                    this.achievements.add(achievementId);
                    
                    // Apply rewards
                    if (achievement.reward.xp) {
                        this.hero.addExperience(achievement.reward.xp);
                    }
                    if (achievement.reward.gold) {
                        this.gold += achievement.reward.gold;
                    }
                    
                    // Show achievement notification
                    this.showAchievementNotification(achievement);
                    
                    console.log(`üèÜ Achievement unlocked: ${achievement.name}`);
                }
            }
            
            showAchievementNotification(achievement) {
                this.achievementText.setText(`üèÜ ${achievement.name}\n${achievement.description}`);
                this.achievementText.setAlpha(1);
                
                // Achievement sound
                this.audioContext.playSound('achievement_unlock');
                
                // Golden flash
                this.cameras.main.flash(300, 255, 215, 0, true);
                
                this.tweens.add({
                    targets: this.achievementText,
                    alpha: 0,
                    duration: 4000,
                    delay: 2000,
                    ease: 'Power2'
                });
            }
            
            toggleInventory() {
                // Placeholder for inventory system
                this.showMessage('üì¶ Inventory system - Coming soon!');
            }
            
            gameOver() {
                // Stop all tweens and timers
                this.tweens.killAll();
                this.time.removeAllEvents();
                
                // Dark overlay
                this.add.rectangle(640, 360, 1280, 720, 0x000000, 0.8).setScrollFactor(0);
                
                // Game over text
                const gameOverText = this.add.text(640, 250, 'üíÄ GAME OVER', {
                    fontSize: '72px',
                    color: '#ff0000',
                    fontFamily: 'Courier New',
                    stroke: '#000000',
                    strokeThickness: 8
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Animate game over text
                this.tweens.add({
                    targets: gameOverText,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
                
                // Final stats
                const statsText = this.add.text(640, 350, [
                    `Final Score: ${this.score}`,
                    `Floor Reached: ${this.currentFloor}`,
                    `Level: ${this.hero.level}`,
                    `Time Survived: ${Math.floor(this.gameTime / 60000)}:${Math.floor((this.gameTime % 60000) / 1000).toString().padStart(2, '0')}`,
                    `Achievements: ${this.achievements.size}/${ACHIEVEMENTS.length}`,
                    `Gold Collected: ${this.gold}G`
                ].join('\n'), {
                    fontSize: '24px',
                    color: '#ffffff',
                    fontFamily: 'Courier New',
                    align: 'center'
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Restart instructions
                const restartText = this.add.text(640, 500, 'Press R to Restart or ESC for Menu', {
                    fontSize: '20px',
                    color: '#00ff88',
                    fontFamily: 'Courier New'
                }).setOrigin(0.5).setScrollFactor(0);
                
                // Input handlers
                this.input.keyboard.on('keydown-R', () => {
                    this.scene.restart();
                });
                
                this.input.keyboard.on('keydown-ESC', () => {
                    // Would go to menu scene
                    this.scene.restart();
                });
                
                // Epic screen shake
                this.cameras.main.shake(1000, 0.03);
                
                console.log('üíÄ Game Over - Final stats recorded');
            }
        }
        
        // Loading manager instance
        const loadingManager = new LoadingManager();
        
        // Game configuration
        const gameConfig = {
            type: Phaser.AUTO,
            width: 1280,
            height: 720,
            parent: 'game-container',
            backgroundColor: '#1a1a1a',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                min: { width: 640, height: 360 },
                max: { width: 1920, height: 1080 }
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { x: 0, y: 0 },
                    debug: false,
                    fps: 60
                }
            },
            render: {
                antialias: false,
                pixelArt: true,
                roundPixels: true
            },
            audio: {
                disableWebAudio: false
            },
            scene: GameScene
        };
        
        // Initialize game after loading
        window.addEventListener('load', function() {
            loadingManager.updateProgress(20, 'Loading game engine...');
            
            setTimeout(() => {
                loadingManager.updateProgress(40, 'Initializing systems...');
                
                setTimeout(() => {
                    loadingManager.updateProgress(60, 'Loading assets...');
                    
                    setTimeout(() => {
                        loadingManager.updateProgress(80, 'Preparing dungeon...');
                        
                        setTimeout(() => {
                            loadingManager.updateProgress(100, 'Ready to play!');
                            
                            setTimeout(() => {
                                loadingManager.hide();
                                
                                // Start the game
                                gameInstance = new Phaser.Game(gameConfig);
                                
                                // Global access for debugging
                                window.game = gameInstance;
                                
                                console.log('üê¢ Bob The Turtle: Complete Edition - READY TO PLAY!');
                            }, 500);
                        }, 300);
                    }, 300);
                }, 300);
            }, 300);
        });
    </script>
</body>
</html>
